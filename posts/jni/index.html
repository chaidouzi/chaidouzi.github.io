<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="JNI" /><meta property="og:locale" content="en" /><meta name="description" content="看代码的时候碰到个 System.identityHashCode(obj)，没见过，更没用过。 直接看了下 doc，描述如下： Returns the same hash code for the given object as would be returned by the default method hashCode(), whether or not the given object’s class overrides hashCode(). The hash code for the null reference is zero. Params: x – object for which the hashCode is to be calculated Returns: the hashCode Since: 1.1 意思是说，不管传进去的参数类有没有重写过 hashcode 方法，identityHashCode 都会返回其默认的 Object.hashcode() 返回值。 那么它有什么用呢？这里给了答案：When to use System.identityhashcode() and hashcode() method? 简单来说，当一个类重写了 equal 和 hashcode 方法，它多个实例的 hashcode 是可能返回相同值的，当我需要区分不同的实例时，就可以用 identityHashCode 方法。 在搜索用法的时候发现了另一篇文章，对 identityHashCode 的底层实现也给了说明，是有关 JNI 的。所以我又看了下 JNI 相关的两篇文章，做个备忘。 System.identityHashCode(obj) 与 obj.hashcode() - 简书 (jianshu.com) 使用JNI（Java Native Interface）的总结 - 简书 (jianshu.com) Jni教程（一）—Linux下jni调用 - 简书 (jianshu.com) 1. 自顶向下 JNI 看 Java 工程源码时，遇到各种 API 都可以在 IDE 里通过鼠标点击进行跳转，但有的时候跳转到 native 方法就没法再往下看了。譬如上边的 identityHashCode 方法，它只有下边这么一个声明，并没有具体的实现。 1 2 @HotSpotIntrinsicCandidate public static native int identityHashCode(Object x); 其实，它并不是没有具体实现，而是 native 方法都是通过 c 或者 c++ 来实现的。native 方法大体可以这么理解：在 jdk 的 java 代码中定义接口（头文件），然后在 c、c++ 中实现接口（实现头文件中定义的方法）。 要查看 native 方法的实现，就需要下载 jdk 的源码。在 jdk 源码里有各个平台的 c、c++ 实现。源码可以从这里下载：JDK Builds from Oracle (java.net)，选择不同的 jdk 版本之后，在 RI Source Code 有源码下载链接。 我下载的 jdk 11，跟 identityHashCode 实现相关的文件路径如下： 1) openjdk/src/java.base/share/native/libjava/System.c，是 Java_java_lang_System_identityHashCode 的实现。（可以看出来 c 中的方法名和 java 中的方法名不一样，转换规则可以参考这里：【转】对于JNI方法名，数据类型和方法签名的一些认识 - InfantSorrow - 博客园 (cnblogs.com)） 1 2 3 4 5 JNIEXPORT jint JNICALL Java_java_lang_System_identityHashCode(JNIEnv *env, jobject this, jobject x) { return JVM_IHashCode(env, x); } 上边的方法里调用了 jvm 的 JVM_IHashCode 方法。 2) openjdk/src/hotspot/share/prims/jvm.cpp，给出了 JVM_IHashCode 的实现，它又调用了 ObjectSynchronizer::FastHashCode。 1 2 3 4 5 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle)) JVMWrapper(&quot;JVM_IHashCode&quot;); // as implemented in the classic virtual machine; return 0 if object is NULL return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ; JVM_END 3) openjdk/src/hotspot/share/runtime/synchronizer.cpp，最终的 hashcode 实现。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 intptr_t ObjectSynchronizer::FastHashCode(Thread * Self, oop obj) { ... hash = get_next_hash(Self, obj); // allocate a new hash code ... } static inline intptr_t get_next_hash(Thread * Self, oop obj) { intptr_t value = 0; if (hashCode == 0) { // This form uses global Park-Miller RNG. // On MP system we&#39;ll have lots of RW access to a global, so the // mechanism induces lots of coherency traffic. value = os::random(); } else if (hashCode == 1) { // This variation has the property of being stable (idempotent) // between STW operations. This can be useful in some of the 1-0 // synchronization schemes. intptr_t addrBits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3; value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom; } else if (hashCode == 2) { value = 1; // for sensitivity testing } else if (hashCode == 3) { value = ++GVars.hcSequence; } else if (hashCode == 4) { value = cast_from_oop&lt;intptr_t&gt;(obj); } else { // Marsaglia&#39;s xor-shift scheme with thread-specific state // This is probably the best overall implementation -- we&#39;ll // likely make this the default in future releases. unsigned t = Self-&gt;_hashStateX; t ^= (t &lt;&lt; 11); Self-&gt;_hashStateX = Self-&gt;_hashStateY; Self-&gt;_hashStateY = Self-&gt;_hashStateZ; Self-&gt;_hashStateZ = Self-&gt;_hashStateW; unsigned v = Self-&gt;_hashStateW; v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)); Self-&gt;_hashStateW = v; value = v; } value &amp;= markOopDesc::hash_mask; if (value == 0) value = 0xBAD; assert(value != markOopDesc::no_hash, &quot;invariant&quot;); TEVENT(hashCode: GENERATE); return value; } 以上就是怎么去看 native 方法的实现。 2. 自底向上 JNI 当我想要自己实现一个 native 方法时，应该怎么做呢？在这部分给出一个最简单的例子。 总共分为两个大步骤：声明接口（生成头文件）、实现接口（编译 so/dll）。 2.1 声明接口 先创建一个最简单的 Java 项目，结构和代码如下，这一步只关注 java 代码，先不用关心 .h .so .c 和 makefile。 LocalLib 中声明了 sayHi 方法，加载了 locallib 这个我们将在后边生成的动态链接库。 1 2 3 4 5 6 7 8 package com.cy; public class LocalLib { static{ System.loadLibrary(&quot;locallib&quot;); } public static native void sayHi(); } JniMain 调用了 LocalLib 的 sayHi 方法。 1 2 3 4 5 6 7 package com.cy; public class JniMain { public static void main(String[] args) { LocalLib.sayHi(); } } 在 src 目录下，也就是 com 同级的目录下使用 javah 命令生成头文件。 1 $ javah com.cy.LocalLib 执行完以上命令，会在同一目录下生成 com_cy_LocalLib.h 头文件，其内容声明了 sayHi 方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_cy_LocalLib */ #ifndef _Included_com_cy_LocalLib #define _Included_com_cy_LocalLib #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: com_cy_LocalLib * Method: sayHi * Signature: ()V */ JNIEXPORT void JNICALL Java_com_cy_LocalLib_sayHi (JNIEnv *, jclass); #ifdef __cplusplus } #endif #endif 这样程序主体搭建和 native 接口声明就完成了。 2.2 实现接口 实现接口就是实现 com_cy_LocalLib.h 头文件里声明的方法。 创建 LocalLib.c 文件，在其中包含 com_cy_LocalLib.h 头文件，并实现 sayHi 方法。 1 2 3 4 5 6 #include &lt;stdio.h&gt; #include &quot;com_cy_LocalLib.h&quot; JNIEXPORT void JNICALL Java_com_cy_LocalLib_sayHi(JNIEnv *, jclass) { printf(&quot;Hi World!\n&quot;); } 创建 makefile，不同平台的写法不同，下边是 Linux 的写法。 1 2 3 4 5 6 liblocallib.so : LocalLib.c g++ -o $@ $+ -fPIC -shared -I/usr/lib/jvm/java-11-openjdk-amd64/include -I/usr/lib/jvm/java-11-openjdk-amd64/include/linux .PHONY : clean clean : -rm liblocallib.so 生成 so 动态链接库（Windows 下是 dll），生成动态链接库需要相应的工具链：make 和 g++。Ubuntu 通过命令：sudo apt install build-essential 进行安装。 1 $ make make 之后会在目录下生成一个 liblocallib.so 的文件，这个就是包含了 sayHi 方法的动态链接库。 2.3 运行 在 idea 里运行的话，把 so 的路径加到 vm 参数 -Djava.library.path 就可以了，譬如：-Djava.library.path=/home/enchyaa/Coding/jni/src。 1 2 3 4 5 6 7 8 9 /usr/lib/jvm/java-11-openjdk-amd64/bin/java -Djava.library.path=/home/cy/Coding/jni/src -javaagent:/opt/idea-IC-212.4746.92/lib/idea_rt.jar=45911:/opt/idea-IC-212.4746.92/bin -Dfile.encoding=UTF-8 -classpath /home/cy/Coding/jni/out/production/jni com.cy.JniMain Hi World! Process finished with exit code 0" /><meta property="og:description" content="看代码的时候碰到个 System.identityHashCode(obj)，没见过，更没用过。 直接看了下 doc，描述如下： Returns the same hash code for the given object as would be returned by the default method hashCode(), whether or not the given object’s class overrides hashCode(). The hash code for the null reference is zero. Params: x – object for which the hashCode is to be calculated Returns: the hashCode Since: 1.1 意思是说，不管传进去的参数类有没有重写过 hashcode 方法，identityHashCode 都会返回其默认的 Object.hashcode() 返回值。 那么它有什么用呢？这里给了答案：When to use System.identityhashcode() and hashcode() method? 简单来说，当一个类重写了 equal 和 hashcode 方法，它多个实例的 hashcode 是可能返回相同值的，当我需要区分不同的实例时，就可以用 identityHashCode 方法。 在搜索用法的时候发现了另一篇文章，对 identityHashCode 的底层实现也给了说明，是有关 JNI 的。所以我又看了下 JNI 相关的两篇文章，做个备忘。 System.identityHashCode(obj) 与 obj.hashcode() - 简书 (jianshu.com) 使用JNI（Java Native Interface）的总结 - 简书 (jianshu.com) Jni教程（一）—Linux下jni调用 - 简书 (jianshu.com) 1. 自顶向下 JNI 看 Java 工程源码时，遇到各种 API 都可以在 IDE 里通过鼠标点击进行跳转，但有的时候跳转到 native 方法就没法再往下看了。譬如上边的 identityHashCode 方法，它只有下边这么一个声明，并没有具体的实现。 1 2 @HotSpotIntrinsicCandidate public static native int identityHashCode(Object x); 其实，它并不是没有具体实现，而是 native 方法都是通过 c 或者 c++ 来实现的。native 方法大体可以这么理解：在 jdk 的 java 代码中定义接口（头文件），然后在 c、c++ 中实现接口（实现头文件中定义的方法）。 要查看 native 方法的实现，就需要下载 jdk 的源码。在 jdk 源码里有各个平台的 c、c++ 实现。源码可以从这里下载：JDK Builds from Oracle (java.net)，选择不同的 jdk 版本之后，在 RI Source Code 有源码下载链接。 我下载的 jdk 11，跟 identityHashCode 实现相关的文件路径如下： 1) openjdk/src/java.base/share/native/libjava/System.c，是 Java_java_lang_System_identityHashCode 的实现。（可以看出来 c 中的方法名和 java 中的方法名不一样，转换规则可以参考这里：【转】对于JNI方法名，数据类型和方法签名的一些认识 - InfantSorrow - 博客园 (cnblogs.com)） 1 2 3 4 5 JNIEXPORT jint JNICALL Java_java_lang_System_identityHashCode(JNIEnv *env, jobject this, jobject x) { return JVM_IHashCode(env, x); } 上边的方法里调用了 jvm 的 JVM_IHashCode 方法。 2) openjdk/src/hotspot/share/prims/jvm.cpp，给出了 JVM_IHashCode 的实现，它又调用了 ObjectSynchronizer::FastHashCode。 1 2 3 4 5 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle)) JVMWrapper(&quot;JVM_IHashCode&quot;); // as implemented in the classic virtual machine; return 0 if object is NULL return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ; JVM_END 3) openjdk/src/hotspot/share/runtime/synchronizer.cpp，最终的 hashcode 实现。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 intptr_t ObjectSynchronizer::FastHashCode(Thread * Self, oop obj) { ... hash = get_next_hash(Self, obj); // allocate a new hash code ... } static inline intptr_t get_next_hash(Thread * Self, oop obj) { intptr_t value = 0; if (hashCode == 0) { // This form uses global Park-Miller RNG. // On MP system we&#39;ll have lots of RW access to a global, so the // mechanism induces lots of coherency traffic. value = os::random(); } else if (hashCode == 1) { // This variation has the property of being stable (idempotent) // between STW operations. This can be useful in some of the 1-0 // synchronization schemes. intptr_t addrBits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3; value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom; } else if (hashCode == 2) { value = 1; // for sensitivity testing } else if (hashCode == 3) { value = ++GVars.hcSequence; } else if (hashCode == 4) { value = cast_from_oop&lt;intptr_t&gt;(obj); } else { // Marsaglia&#39;s xor-shift scheme with thread-specific state // This is probably the best overall implementation -- we&#39;ll // likely make this the default in future releases. unsigned t = Self-&gt;_hashStateX; t ^= (t &lt;&lt; 11); Self-&gt;_hashStateX = Self-&gt;_hashStateY; Self-&gt;_hashStateY = Self-&gt;_hashStateZ; Self-&gt;_hashStateZ = Self-&gt;_hashStateW; unsigned v = Self-&gt;_hashStateW; v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)); Self-&gt;_hashStateW = v; value = v; } value &amp;= markOopDesc::hash_mask; if (value == 0) value = 0xBAD; assert(value != markOopDesc::no_hash, &quot;invariant&quot;); TEVENT(hashCode: GENERATE); return value; } 以上就是怎么去看 native 方法的实现。 2. 自底向上 JNI 当我想要自己实现一个 native 方法时，应该怎么做呢？在这部分给出一个最简单的例子。 总共分为两个大步骤：声明接口（生成头文件）、实现接口（编译 so/dll）。 2.1 声明接口 先创建一个最简单的 Java 项目，结构和代码如下，这一步只关注 java 代码，先不用关心 .h .so .c 和 makefile。 LocalLib 中声明了 sayHi 方法，加载了 locallib 这个我们将在后边生成的动态链接库。 1 2 3 4 5 6 7 8 package com.cy; public class LocalLib { static{ System.loadLibrary(&quot;locallib&quot;); } public static native void sayHi(); } JniMain 调用了 LocalLib 的 sayHi 方法。 1 2 3 4 5 6 7 package com.cy; public class JniMain { public static void main(String[] args) { LocalLib.sayHi(); } } 在 src 目录下，也就是 com 同级的目录下使用 javah 命令生成头文件。 1 $ javah com.cy.LocalLib 执行完以上命令，会在同一目录下生成 com_cy_LocalLib.h 头文件，其内容声明了 sayHi 方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_cy_LocalLib */ #ifndef _Included_com_cy_LocalLib #define _Included_com_cy_LocalLib #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: com_cy_LocalLib * Method: sayHi * Signature: ()V */ JNIEXPORT void JNICALL Java_com_cy_LocalLib_sayHi (JNIEnv *, jclass); #ifdef __cplusplus } #endif #endif 这样程序主体搭建和 native 接口声明就完成了。 2.2 实现接口 实现接口就是实现 com_cy_LocalLib.h 头文件里声明的方法。 创建 LocalLib.c 文件，在其中包含 com_cy_LocalLib.h 头文件，并实现 sayHi 方法。 1 2 3 4 5 6 #include &lt;stdio.h&gt; #include &quot;com_cy_LocalLib.h&quot; JNIEXPORT void JNICALL Java_com_cy_LocalLib_sayHi(JNIEnv *, jclass) { printf(&quot;Hi World!\n&quot;); } 创建 makefile，不同平台的写法不同，下边是 Linux 的写法。 1 2 3 4 5 6 liblocallib.so : LocalLib.c g++ -o $@ $+ -fPIC -shared -I/usr/lib/jvm/java-11-openjdk-amd64/include -I/usr/lib/jvm/java-11-openjdk-amd64/include/linux .PHONY : clean clean : -rm liblocallib.so 生成 so 动态链接库（Windows 下是 dll），生成动态链接库需要相应的工具链：make 和 g++。Ubuntu 通过命令：sudo apt install build-essential 进行安装。 1 $ make make 之后会在目录下生成一个 liblocallib.so 的文件，这个就是包含了 sayHi 方法的动态链接库。 2.3 运行 在 idea 里运行的话，把 so 的路径加到 vm 参数 -Djava.library.path 就可以了，譬如：-Djava.library.path=/home/enchyaa/Coding/jni/src。 1 2 3 4 5 6 7 8 9 /usr/lib/jvm/java-11-openjdk-amd64/bin/java -Djava.library.path=/home/cy/Coding/jni/src -javaagent:/opt/idea-IC-212.4746.92/lib/idea_rt.jar=45911:/opt/idea-IC-212.4746.92/bin -Dfile.encoding=UTF-8 -classpath /home/cy/Coding/jni/out/production/jni com.cy.JniMain Hi World! Process finished with exit code 0" /><link rel="canonical" href="/posts/jni/" /><meta property="og:url" content="/posts/jni/" /><meta property="og:site_name" content="Chai Yan" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-03T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="JNI" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"看代码的时候碰到个 System.identityHashCode(obj)，没见过，更没用过。 直接看了下 doc，描述如下： Returns the same hash code for the given object as would be returned by the default method hashCode(), whether or not the given object’s class overrides hashCode(). The hash code for the null reference is zero. Params: x – object for which the hashCode is to be calculated Returns: the hashCode Since: 1.1 意思是说，不管传进去的参数类有没有重写过 hashcode 方法，identityHashCode 都会返回其默认的 Object.hashcode() 返回值。 那么它有什么用呢？这里给了答案：When to use System.identityhashcode() and hashcode() method? 简单来说，当一个类重写了 equal 和 hashcode 方法，它多个实例的 hashcode 是可能返回相同值的，当我需要区分不同的实例时，就可以用 identityHashCode 方法。 在搜索用法的时候发现了另一篇文章，对 identityHashCode 的底层实现也给了说明，是有关 JNI 的。所以我又看了下 JNI 相关的两篇文章，做个备忘。 System.identityHashCode(obj) 与 obj.hashcode() - 简书 (jianshu.com) 使用JNI（Java Native Interface）的总结 - 简书 (jianshu.com) Jni教程（一）—Linux下jni调用 - 简书 (jianshu.com) 1. 自顶向下 JNI 看 Java 工程源码时，遇到各种 API 都可以在 IDE 里通过鼠标点击进行跳转，但有的时候跳转到 native 方法就没法再往下看了。譬如上边的 identityHashCode 方法，它只有下边这么一个声明，并没有具体的实现。 1 2 @HotSpotIntrinsicCandidate public static native int identityHashCode(Object x); 其实，它并不是没有具体实现，而是 native 方法都是通过 c 或者 c++ 来实现的。native 方法大体可以这么理解：在 jdk 的 java 代码中定义接口（头文件），然后在 c、c++ 中实现接口（实现头文件中定义的方法）。 要查看 native 方法的实现，就需要下载 jdk 的源码。在 jdk 源码里有各个平台的 c、c++ 实现。源码可以从这里下载：JDK Builds from Oracle (java.net)，选择不同的 jdk 版本之后，在 RI Source Code 有源码下载链接。 我下载的 jdk 11，跟 identityHashCode 实现相关的文件路径如下： 1) openjdk/src/java.base/share/native/libjava/System.c，是 Java_java_lang_System_identityHashCode 的实现。（可以看出来 c 中的方法名和 java 中的方法名不一样，转换规则可以参考这里：【转】对于JNI方法名，数据类型和方法签名的一些认识 - InfantSorrow - 博客园 (cnblogs.com)） 1 2 3 4 5 JNIEXPORT jint JNICALL Java_java_lang_System_identityHashCode(JNIEnv *env, jobject this, jobject x) { return JVM_IHashCode(env, x); } 上边的方法里调用了 jvm 的 JVM_IHashCode 方法。 2) openjdk/src/hotspot/share/prims/jvm.cpp，给出了 JVM_IHashCode 的实现，它又调用了 ObjectSynchronizer::FastHashCode。 1 2 3 4 5 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle)) JVMWrapper(&quot;JVM_IHashCode&quot;); // as implemented in the classic virtual machine; return 0 if object is NULL return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ; JVM_END 3) openjdk/src/hotspot/share/runtime/synchronizer.cpp，最终的 hashcode 实现。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 intptr_t ObjectSynchronizer::FastHashCode(Thread * Self, oop obj) { ... hash = get_next_hash(Self, obj); // allocate a new hash code ... } static inline intptr_t get_next_hash(Thread * Self, oop obj) { intptr_t value = 0; if (hashCode == 0) { // This form uses global Park-Miller RNG. // On MP system we&#39;ll have lots of RW access to a global, so the // mechanism induces lots of coherency traffic. value = os::random(); } else if (hashCode == 1) { // This variation has the property of being stable (idempotent) // between STW operations. This can be useful in some of the 1-0 // synchronization schemes. intptr_t addrBits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3; value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom; } else if (hashCode == 2) { value = 1; // for sensitivity testing } else if (hashCode == 3) { value = ++GVars.hcSequence; } else if (hashCode == 4) { value = cast_from_oop&lt;intptr_t&gt;(obj); } else { // Marsaglia&#39;s xor-shift scheme with thread-specific state // This is probably the best overall implementation -- we&#39;ll // likely make this the default in future releases. unsigned t = Self-&gt;_hashStateX; t ^= (t &lt;&lt; 11); Self-&gt;_hashStateX = Self-&gt;_hashStateY; Self-&gt;_hashStateY = Self-&gt;_hashStateZ; Self-&gt;_hashStateZ = Self-&gt;_hashStateW; unsigned v = Self-&gt;_hashStateW; v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)); Self-&gt;_hashStateW = v; value = v; } value &amp;= markOopDesc::hash_mask; if (value == 0) value = 0xBAD; assert(value != markOopDesc::no_hash, &quot;invariant&quot;); TEVENT(hashCode: GENERATE); return value; } 以上就是怎么去看 native 方法的实现。 2. 自底向上 JNI 当我想要自己实现一个 native 方法时，应该怎么做呢？在这部分给出一个最简单的例子。 总共分为两个大步骤：声明接口（生成头文件）、实现接口（编译 so/dll）。 2.1 声明接口 先创建一个最简单的 Java 项目，结构和代码如下，这一步只关注 java 代码，先不用关心 .h .so .c 和 makefile。 LocalLib 中声明了 sayHi 方法，加载了 locallib 这个我们将在后边生成的动态链接库。 1 2 3 4 5 6 7 8 package com.cy; public class LocalLib { static{ System.loadLibrary(&quot;locallib&quot;); } public static native void sayHi(); } JniMain 调用了 LocalLib 的 sayHi 方法。 1 2 3 4 5 6 7 package com.cy; public class JniMain { public static void main(String[] args) { LocalLib.sayHi(); } } 在 src 目录下，也就是 com 同级的目录下使用 javah 命令生成头文件。 1 $ javah com.cy.LocalLib 执行完以上命令，会在同一目录下生成 com_cy_LocalLib.h 头文件，其内容声明了 sayHi 方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_cy_LocalLib */ #ifndef _Included_com_cy_LocalLib #define _Included_com_cy_LocalLib #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: com_cy_LocalLib * Method: sayHi * Signature: ()V */ JNIEXPORT void JNICALL Java_com_cy_LocalLib_sayHi (JNIEnv *, jclass); #ifdef __cplusplus } #endif #endif 这样程序主体搭建和 native 接口声明就完成了。 2.2 实现接口 实现接口就是实现 com_cy_LocalLib.h 头文件里声明的方法。 创建 LocalLib.c 文件，在其中包含 com_cy_LocalLib.h 头文件，并实现 sayHi 方法。 1 2 3 4 5 6 #include &lt;stdio.h&gt; #include &quot;com_cy_LocalLib.h&quot; JNIEXPORT void JNICALL Java_com_cy_LocalLib_sayHi(JNIEnv *, jclass) { printf(&quot;Hi World!\\n&quot;); } 创建 makefile，不同平台的写法不同，下边是 Linux 的写法。 1 2 3 4 5 6 liblocallib.so : LocalLib.c g++ -o $@ $+ -fPIC -shared -I/usr/lib/jvm/java-11-openjdk-amd64/include -I/usr/lib/jvm/java-11-openjdk-amd64/include/linux .PHONY : clean clean : -rm liblocallib.so 生成 so 动态链接库（Windows 下是 dll），生成动态链接库需要相应的工具链：make 和 g++。Ubuntu 通过命令：sudo apt install build-essential 进行安装。 1 $ make make 之后会在目录下生成一个 liblocallib.so 的文件，这个就是包含了 sayHi 方法的动态链接库。 2.3 运行 在 idea 里运行的话，把 so 的路径加到 vm 参数 -Djava.library.path 就可以了，譬如：-Djava.library.path=/home/enchyaa/Coding/jni/src。 1 2 3 4 5 6 7 8 9 /usr/lib/jvm/java-11-openjdk-amd64/bin/java -Djava.library.path=/home/cy/Coding/jni/src -javaagent:/opt/idea-IC-212.4746.92/lib/idea_rt.jar=45911:/opt/idea-IC-212.4746.92/bin -Dfile.encoding=UTF-8 -classpath /home/cy/Coding/jni/out/production/jni com.cy.JniMain Hi World! Process finished with exit code 0","url":"/posts/jni/","@type":"BlogPosting","headline":"JNI","dateModified":"2021-08-03T00:00:00+08:00","datePublished":"2021-08-03T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/jni/"},"@context":"https://schema.org"}</script><title>JNI | Chai Yan</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Chai Yan"><meta name="application-name" content="Chai Yan"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Chai Yan</a></div><div class="site-subtitle font-italic">Personal technical blog, recording interesting things.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/chaidouzi" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>JNI</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>JNI</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> your_full_name </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Aug 3, 2021, 12:00 AM +0800" >Aug 3<i class="unloaded">2021-08-03T00:00:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1631 words">9 min read</span></div></div><div class="post-content"><p>看代码的时候碰到个 System.identityHashCode(obj)，没见过，更没用过。</p><p>直接看了下 doc，描述如下：</p><blockquote><p>Returns the same hash code for the given object as would be returned by the default method hashCode(), whether or not the given object’s class overrides hashCode(). The hash code for the null reference is zero. Params: x – object for which the hashCode is to be calculated Returns: the hashCode Since: 1.1</p></blockquote><p>意思是说，不管传进去的参数类有没有重写过 hashcode 方法，identityHashCode 都会返回其默认的 Object.hashcode() 返回值。</p><p>那么它有什么用呢？这里给了答案：<a href="https://stackoverflow.com/a/31580144/16584052">When to use System.identityhashcode() and hashcode() method?</a></p><p>简单来说，当一个类重写了 equal 和 hashcode 方法，它多个实例的 hashcode 是可能返回相同值的，当我需要区分不同的实例时，就可以用 identityHashCode 方法。</p><p>在搜索用法的时候发现了另一篇文章，对 identityHashCode 的底层实现也给了说明，是有关 JNI 的。所以我又看了下 JNI 相关的两篇文章，做个备忘。</p><p><a href="https://www.jianshu.com/p/24fa4bdb9b9d">System.identityHashCode(obj) 与 obj.hashcode() - 简书 (jianshu.com)</a></p><p><a href="https://www.jianshu.com/p/fe42aa3150a0">使用JNI（Java Native Interface）的总结 - 简书 (jianshu.com)</a></p><p><a href="https://www.jianshu.com/p/e175d5417e05">Jni教程（一）—Linux下jni调用 - 简书 (jianshu.com)</a></p><h3 id="1-自顶向下-jni">1. 自顶向下 JNI</h3><p>看 Java 工程源码时，遇到各种 API 都可以在 IDE 里通过鼠标点击进行跳转，但有的时候跳转到 native 方法就没法再往下看了。譬如上边的 identityHashCode 方法，它只有下边这么一个声明，并没有具体的实现。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span text-data=" Java "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nd">@HotSpotIntrinsicCandidate</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">identityHashCode</span><span class="o">(</span><span class="nc">Object</span> <span class="n">x</span><span class="o">);</span>
</pre></table></code></div></div><p>其实，它并不是没有具体实现，而是 native 方法都是通过 c 或者 c++ 来实现的。native 方法大体可以这么理解：在 jdk 的 java 代码中定义接口（头文件），然后在 c、c++ 中实现接口（实现头文件中定义的方法）。</p><p>要查看 native 方法的实现，就需要下载 jdk 的源码。在 jdk 源码里有各个平台的 c、c++ 实现。源码可以从这里下载：<a href="http://jdk.java.net/">JDK Builds from Oracle (java.net)</a>，选择不同的 jdk 版本之后，在 RI Source Code 有源码下载链接。</p><p>我下载的 jdk 11，跟 identityHashCode 实现相关的文件路径如下：</p><p>1) openjdk/src/java.base/share/native/libjava/System.c，是 Java_java_lang_System_identityHashCode 的实现。（可以看出来 c 中的方法名和 java 中的方法名不一样，转换规则可以参考这里：<a href="https://www.cnblogs.com/CCBB/p/3978847.html">【转】对于JNI方法名，数据类型和方法签名的一些认识 - InfantSorrow - 博客园 (cnblogs.com)</a>）</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>   <span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span>
   <span class="nf">Java_java_lang_System_identityHashCode</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">this</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">x</span><span class="p">)</span>
   <span class="p">{</span>
       <span class="k">return</span> <span class="n">JVM_IHashCode</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
   <span class="p">}</span>
</pre></table></code></div></div><p>上边的方法里调用了 jvm 的 JVM_IHashCode 方法。</p><p>2) openjdk/src/hotspot/share/prims/jvm.cpp，给出了 JVM_IHashCode 的实现，它又调用了 ObjectSynchronizer::FastHashCode。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>   <span class="n">JVM_ENTRY</span><span class="p">(</span><span class="n">jint</span><span class="p">,</span> <span class="n">JVM_IHashCode</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">handle</span><span class="p">))</span>
     <span class="n">JVMWrapper</span><span class="p">(</span><span class="s">"JVM_IHashCode"</span><span class="p">);</span>
     <span class="c1">// as implemented in the classic virtual machine; return 0 if object is NULL</span>
     <span class="k">return</span> <span class="n">handle</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ObjectSynchronizer</span><span class="o">::</span><span class="n">FastHashCode</span> <span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="n">JNIHandles</span><span class="o">::</span><span class="n">resolve_non_null</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">;</span>
   <span class="n">JVM_END</span>
</pre></table></code></div></div><p>3) openjdk/src/hotspot/share/runtime/synchronizer.cpp，最终的 hashcode 实现。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre>   <span class="kt">intptr_t</span> <span class="n">ObjectSynchronizer</span><span class="o">::</span><span class="n">FastHashCode</span><span class="p">(</span><span class="n">Thread</span> <span class="o">*</span> <span class="n">Self</span><span class="p">,</span> <span class="n">oop</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
       <span class="p">...</span>
           <span class="n">hash</span> <span class="o">=</span> <span class="n">get_next_hash</span><span class="p">(</span><span class="n">Self</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>  <span class="c1">// allocate a new hash code</span>
       <span class="p">...</span>
   <span class="p">}</span>
   
   <span class="k">static</span> <span class="kr">inline</span> <span class="kt">intptr_t</span> <span class="nf">get_next_hash</span><span class="p">(</span><span class="n">Thread</span> <span class="o">*</span> <span class="n">Self</span><span class="p">,</span> <span class="n">oop</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
     <span class="kt">intptr_t</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
       <span class="c1">// This form uses global Park-Miller RNG.</span>
       <span class="c1">// On MP system we'll have lots of RW access to a global, so the</span>
       <span class="c1">// mechanism induces lots of coherency traffic.</span>
       <span class="n">value</span> <span class="o">=</span> <span class="n">os</span><span class="o">::</span><span class="n">random</span><span class="p">();</span>
     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
       <span class="c1">// This variation has the property of being stable (idempotent)</span>
       <span class="c1">// between STW operations.  This can be useful in some of the 1-0</span>
       <span class="c1">// synchronization schemes.</span>
       <span class="kt">intptr_t</span> <span class="n">addrBits</span> <span class="o">=</span> <span class="n">cast_from_oop</span><span class="o">&lt;</span><span class="kt">intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
       <span class="n">value</span> <span class="o">=</span> <span class="n">addrBits</span> <span class="o">^</span> <span class="p">(</span><span class="n">addrBits</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">^</span> <span class="n">GVars</span><span class="p">.</span><span class="n">stwRandom</span><span class="p">;</span>
     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>            <span class="c1">// for sensitivity testing</span>
     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">value</span> <span class="o">=</span> <span class="o">++</span><span class="n">GVars</span><span class="p">.</span><span class="n">hcSequence</span><span class="p">;</span>
     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">value</span> <span class="o">=</span> <span class="n">cast_from_oop</span><span class="o">&lt;</span><span class="kt">intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="c1">// Marsaglia's xor-shift scheme with thread-specific state</span>
       <span class="c1">// This is probably the best overall implementation -- we'll</span>
       <span class="c1">// likely make this the default in future releases.</span>
       <span class="kt">unsigned</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateX</span><span class="p">;</span>
       <span class="n">t</span> <span class="o">^=</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">);</span>
       <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateX</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateY</span><span class="p">;</span>
       <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateY</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateZ</span><span class="p">;</span>
       <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateZ</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateW</span><span class="p">;</span>
       <span class="kt">unsigned</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateW</span><span class="p">;</span>
       <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">^</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">19</span><span class="p">))</span> <span class="o">^</span> <span class="p">(</span><span class="n">t</span> <span class="o">^</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">));</span>
       <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateW</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
       <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
     <span class="p">}</span>
   
     <span class="n">value</span> <span class="o">&amp;=</span> <span class="n">markOopDesc</span><span class="o">::</span><span class="n">hash_mask</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">value</span> <span class="o">=</span> <span class="mh">0xBAD</span><span class="p">;</span>
     <span class="n">assert</span><span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="n">markOopDesc</span><span class="o">::</span><span class="n">no_hash</span><span class="p">,</span> <span class="s">"invariant"</span><span class="p">);</span>
     <span class="n">TEVENT</span><span class="p">(</span><span class="n">hashCode</span><span class="o">:</span> <span class="n">GENERATE</span><span class="p">);</span>
     <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
   <span class="p">}</span>
</pre></table></code></div></div><p>以上就是怎么去看 native 方法的实现。</p><h3 id="2-自底向上-jni">2. 自底向上 JNI</h3><p>当我想要自己实现一个 native 方法时，应该怎么做呢？在这部分给出一个最简单的例子。</p><p>总共分为两个大步骤：声明接口（生成头文件）、实现接口（编译 so/dll）。</p><h4 id="21-声明接口">2.1 声明接口</h4><ol><li><p>先创建一个最简单的 Java 项目，结构和代码如下，这一步只关注 java 代码，先不用关心 .h .so .c 和 makefile。</p><p><img data-proofer-ignore data-src="/images/jni.png" alt="jni" align="left" /></p><p>LocalLib 中声明了 sayHi 方法，加载了 locallib 这个我们将在后边生成的动态链接库。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span text-data=" Java "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.cy</span><span class="o">;</span>
   
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocalLib</span> <span class="o">{</span>
    <span class="kd">static</span><span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">"locallib"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">sayHi</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>JniMain 调用了 LocalLib 的 sayHi 方法。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span text-data=" Java "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.cy</span><span class="o">;</span>
   
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JniMain</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">LocalLib</span><span class="o">.</span><span class="na">sayHi</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><li><p>在 src 目录下，也就是 com 同级的目录下使用 javah 命令生成头文件。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>javah com.cy.LocalLib
</pre></table></code></div></div><p>执行完以上命令，会在同一目录下生成 com_cy_LocalLib.h 头文件，其内容声明了 sayHi 方法。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cm">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
<span class="cp">#include &lt;jni.h&gt;
</span><span class="cm">/* Header for class com_cy_LocalLib */</span>
   
<span class="cp">#ifndef _Included_com_cy_LocalLib
#define _Included_com_cy_LocalLib
#ifdef __cplusplus
</span><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
<span class="cp">#endif
</span><span class="cm">/*
 * Class:     com_cy_LocalLib
 * Method:    sayHi
 * Signature: ()V
 */</span>
<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="n">Java_com_cy_LocalLib_sayHi</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jclass</span><span class="p">);</span>
   
<span class="cp">#ifdef __cplusplus
</span><span class="p">}</span>
<span class="cp">#endif
#endif
</span></pre></table></code></div></div></ol><p>这样程序主体搭建和 native 接口声明就完成了。</p><h4 id="22-实现接口">2.2 实现接口</h4><p>实现接口就是实现 com_cy_LocalLib.h 头文件里声明的方法。</p><ol><li><p>创建 LocalLib.c 文件，在其中包含 com_cy_LocalLib.h 头文件，并实现 sayHi 方法。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include "com_cy_LocalLib.h"
</span>   
<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="nf">Java_com_cy_LocalLib_sayHi</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jclass</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hi World!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>创建 makefile，不同平台的写法不同，下边是 Linux 的写法。</p><div class="language-makefile highlighter-rouge"><div class="code-header"> <span text-data=" Makefile "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">liblocallib.so </span><span class="o">:</span> <span class="nf">LocalLib.c</span>
	g++ <span class="nt">-o</span> <span class="nv">$@</span> <span class="nv">$+</span> <span class="nt">-fPIC</span> <span class="nt">-shared</span> <span class="nt">-I</span>/usr/lib/jvm/java-11-openjdk-amd64/include <span class="nt">-I</span>/usr/lib/jvm/java-11-openjdk-amd64/include/linux
   
<span class="nl">.PHONY </span><span class="o">:</span> <span class="nf">clean</span>
<span class="nl">clean </span><span class="o">:</span>
	<span class="p">-</span><span class="nb">rm </span>liblocallib.so
</pre></table></code></div></div><li><p>生成 so 动态链接库（Windows 下是 dll），生成动态链接库需要相应的工具链：make 和 g++。Ubuntu 通过命令：<code class="language-plaintext highlighter-rouge">sudo apt install build-essential</code> 进行安装。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>make
</pre></table></code></div></div><p>make 之后会在目录下生成一个 liblocallib.so 的文件，这个就是包含了 sayHi 方法的动态链接库。</p></ol><h4 id="23-运行">2.3 运行</h4><p>在 idea 里运行的话，把 so 的路径加到 vm 参数 -Djava.library.path 就可以了，譬如：<code class="language-plaintext highlighter-rouge">-Djava.library.path=/home/enchyaa/Coding/jni/src</code>。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>/usr/lib/jvm/java-11-openjdk-amd64/bin/java 
<span class="nt">-Djava</span>.library.path<span class="o">=</span>/home/cy/Coding/jni/src 
<span class="nt">-javaagent</span>:/opt/idea-IC-212.4746.92/lib/idea_rt.jar<span class="o">=</span>45911:/opt/idea-IC-212.4746.92/bin 
<span class="nt">-Dfile</span>.encoding<span class="o">=</span>UTF-8 
<span class="nt">-classpath</span> /home/cy/Coding/jni/out/production/jni com.cy.JniMain

Hi World!

Process finished with <span class="nb">exit </span>code 0
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/language/'>language</a>, <a href='/categories/java/'>java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/jni/" class="post-tag no-text-decoration" >jni</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=JNI - Chai Yan&url=/posts/jni/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=JNI - Chai Yan&u=/posts/jni/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=JNI - Chai Yan&url=/posts/jni/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/latex/">latex</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/java8/">java8</a> <a class="post-tag" href="/tags/mac/">mac</a> <a class="post-tag" href="/tags/vim/">vim</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/json/">json</a> <a class="post-tag" href="/tags/lambda/">lambda</a> <a class="post-tag" href="/tags/manjaro/">manjaro</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/guava_string/"><div class="card-body"> <span class="timeago small" >Apr 16, 2019<i class="unloaded">2019-04-16T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Guava 字符串处理</h3><div class="text-muted small"><p> Guava，包含了若干被Google的Java项目广泛依赖的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。所有这些工具每天都...</p></div></div></a></div><div class="card"> <a href="/posts/log_framework/"><div class="card-body"> <span class="timeago small" >Apr 21, 2019<i class="unloaded">2019-04-21T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>日志框架</h3><div class="text-muted small"><p> 一、日志框架 Slf4j，简单日志门面（Simple Logging Facade for Java）为各种日志框架提供了统一的接口封装，包括java.util.logging、logback、Log4j等，使用户在部署时可以灵活配置自己想要的Logging APIs实现。 应用开发时，需要统一按照slf4j的API进行开发；部署时，选择不同的日志系统Jar包加入Java ClassPa...</p></div></div></a></div><div class="card"> <a href="/posts/mybatis_generator_lombok_plugin/"><div class="card-body"> <span class="timeago small" >Jun 7, 2019<i class="unloaded">2019-06-07T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>mybatis-generator-lombok-plugin</h3><div class="text-muted small"><p> mybatis-generator-lombok-plugin 功能 整合lombok插件实现@Data自动注解，取消getter、setter方法的自动生成。 自定义注释生成器，抓取数据库表的列注释作为实体类注释。 用法 git clone到IDEA，根据自己需要进行更改，再添加到本地maven仓库。 git clone到本地，通过maven clean in...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/gist/" class="btn btn-outline-primary" prompt="Older"><p>gist</p></a> <a href="/posts/latex_install/" class="btn btn-outline-primary" prompt="Newer"><p>LaTex 介绍及安装</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/chaidouzi">your_full_name</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/latex/">latex</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/java8/">java8</a> <a class="post-tag" href="/tags/mac/">mac</a> <a class="post-tag" href="/tags/vim/">vim</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/json/">json</a> <a class="post-tag" href="/tags/lambda/">lambda</a> <a class="post-tag" href="/tags/manjaro/">manjaro</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
