<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="消息队列" /><meta property="og:locale" content="en" /><meta name="description" content="[toc] 消息队列是一种进程间通信或同一进程的不同线程间的通信方式，直观一点的理解可以直接从字面进行理解，消息队列就是一个容纳消息的队列，producer 有新的消息就丢给队列，consumer 轮询队列进行消息的获取。 高级消息队列协议（Advanced Message Queuing Protocol AMQP）是面向消息中间件提供的开放的应用层协议。 消息队列有很多基于不同协议的开源实现：RabbitMQ（AMQP）、RocketMQ（自定协议）、Kafka（自定的基于TCP的二进制协议）。 RabbitMQ：性能好、延时低、管理界面友好、社区活跃。但吞吐量较低，erlang 语言实现，较难扩展。 RocketMQ：阿里出品，接口简单易用。 Kafka：提供较少的核心功能、具备超高的吞吐量、极高的可用性和拓展性。但存在消息重复消费的缺点，适合于大数据实时计算和日志收集。 消息队列常见的应用场景：异步处理、应用解耦、流量削峰、消息通讯等。 一个模拟 RabbitMQ 的网站：RabbitMQ Simulator AMQP 核心概念 Broker：接收和分发 message 的应用，即 RabbitMQ 的 server。 Virtual Host：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于 namespace 概念。当多个不同的用户使用同一个RabbitMQ server 提供服务时，可以划分出多个 virtual host，每个用户在自己的 virtual host 创建 exchange/queue 等。 Connection： publisher/consumer 和 broker 之间的 TCP 连接。断开连接的操作只会在 client 端进行，broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。 Channel：如果每一次访问 RabbitMQ server 都建立一个 connection，在消息量大的时候建立 TCP connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，channel 作为轻量级的 connection 极大减少了操作系统建立 TCP connection 的开销。 Message：服务器和应用程序之间传送的数据，由 properties 和 body 组成。Properties 可以对 message 进行修饰，比如 message 的优先级、延迟等高级特性，body 就是 message 内容。 Queue：消息最终被送到这里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。 Exchange： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。 Binding： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。 Routing Key：单个路由规则，虚拟机可用它来确定如何路由一个 message。 协议模型 消息流转 Exchange 类型 主要有 3 种类型的 exchange。 Direct Exchange（直连交换机） Topic Exchange（主题交换机） Fanout Exchange（扇型交换机） Direct Exchange 消息传递时，Routing Key 必须完全匹配才会被队列接收，否则该消息会被抛弃。 Topic Exchange 模糊匹配的机制。 * 匹配一个单词 # 匹配零个或多个单词 发送到 topic exchange 的消息会被转发到所有关心 routing key 中指定 topic 的 queue 上 当特殊字符“*”（星号）和“＃”（哈希）未在绑定中使用时，主题交换机的行为就像直接交换机一样。 例如 上图示例创建了三个绑定：Q1 绑定了绑定键 *.orange.*，Q2 绑定了*.*.rabbit 和 lazy.#。 Q1 对所有 orange 感兴趣 Q2 希望听到关于 rabbit 的一切，以及关于 lazy 的一切 那么消息经过 topic exchange 的路由结果将会是如下情况。 quick.orange.rabbit 的消息会同时传递到两个队列 lazy.orange.elephant 的消息也会同事传递到两个队列 quick.orange.fox 只会传递到 Q1 lazy.brown.fox 只会转到 Q2 lazy.pink.rabbit 只会递到 Q2 一次，即使它匹配两个绑定 quick.brown.fox 与任何绑定都不匹配，因此它将被丢弃 lazy.orange.male.rabbit 虽然有四个单词，也会匹配最后一个绑定，并将被传递到 Q2 Fanout Exchange 名字比较形象了，像 fan 一样甩出消息到所有绑定的队列。 不处理 routing key，只需要简单的将队列绑定到交换机上 发送到 fanout exchange 的消息都会被转发到与该交换机绑定的所有队列上 Fanout Exchange 转发消息是最快的 RabbitMQ RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。 RabbitMQ 服务器是用 Erlang 语言编写的。 RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman. The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ messages. 安装 官网给了安装指引，MacOS 下用 HomeBrew 比较简单方便，但 Linux 下的步骤稍显凌乱，这里整理下 Ubuntu 的安装步骤。 添加 apt 仓库签名密钥 1 2 3 4 5 6 ## Team RabbitMQ&#39;s main signing key sudo apt-key adv --keyserver &quot;hkps://keys.openpgp.org&quot; --recv-keys &quot;0x0A9AF2115F4687BD29803A206B73A36E6026DFCA&quot; ## Launchpad PPA that provides modern Erlang releases sudo apt-key adv --keyserver &quot;keyserver.ubuntu.com&quot; --recv-keys &quot;F77F1EDA57EBB1CC&quot; ## PackageCloud RabbitMQ repository curl -1sLf &#39;https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey&#39; | apt-key add - 安装 apt-transport-https，以便能够从 PackageCloud、Cloudsmith.io、Launchpad 下载 RabbitMQ 和 Erlang 的包文件 1 sudo apt-get install apt-transport-https 添加第三方软件源，将以下内容添加至 /etc/apt/sources.list.d/rabbitmq.list，需要注意不同的 Ubuntu 版本的 distribution name 有差别。 focal for Ubuntu 20.04 bionic for Ubuntu 18.04 xenial for Ubuntu 16.04 buster for Debian Buster 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Source repository definition example. ## Provides modern Erlang/OTP releases ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main deb-src http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main ## Provides RabbitMQ ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main deb-src https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main 安装 RabbitMQ 及其相关依赖的包 1 2 3 4 5 6 7 8 9 10 11 12 ## Update package indices sudo apt-get update -y ## Install Erlang packages sudo apt-get install -y erlang-base \ erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \ erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \ erlang-runtime-tools erlang-snmp erlang-ssl \ erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl ## Install rabbitmq-server and its dependencies sudo apt-get install rabbitmq-server -y --fix-missing 启停和界面 1 2 3 4 5 6 7 8 9 10 11 # 启动 sudo service rabbitmq-server start # 停止 sudo service rabbitmq-server stop # 重启 sudo service rabbitmq-server restart # 查看当前状态 sudo service rabbitmq-server status RabbitMQ 提供了一个管理插件（rabbitmq_management），方便在 web 端管理 RabbitMQ，默认未开启需要在命令行开启该插件。开启插件并重启 RabbitMQ server 后，就可以通过浏览器进行管理，默认端口是 15672。 1 2 # 开启管理工具，然后重启服务即可通过 web 进行管理 sudo rabbitmq-plugins enable rabbitmq_management 默认有一个 guest/guest 的用户可以用来登录管理工具，同时也可以通过命令新建用户和赋予权限。 1 2 3 4 5 # 添加 admin/admin 用户 sudo rabbitmqctl add_user admin admin # 赋予其管理员权限 sudo rabbitmqctl set_user_tags admin administrator 示例 官网的一些开发示例：RabbitMQ Tutorials" /><meta property="og:description" content="[toc] 消息队列是一种进程间通信或同一进程的不同线程间的通信方式，直观一点的理解可以直接从字面进行理解，消息队列就是一个容纳消息的队列，producer 有新的消息就丢给队列，consumer 轮询队列进行消息的获取。 高级消息队列协议（Advanced Message Queuing Protocol AMQP）是面向消息中间件提供的开放的应用层协议。 消息队列有很多基于不同协议的开源实现：RabbitMQ（AMQP）、RocketMQ（自定协议）、Kafka（自定的基于TCP的二进制协议）。 RabbitMQ：性能好、延时低、管理界面友好、社区活跃。但吞吐量较低，erlang 语言实现，较难扩展。 RocketMQ：阿里出品，接口简单易用。 Kafka：提供较少的核心功能、具备超高的吞吐量、极高的可用性和拓展性。但存在消息重复消费的缺点，适合于大数据实时计算和日志收集。 消息队列常见的应用场景：异步处理、应用解耦、流量削峰、消息通讯等。 一个模拟 RabbitMQ 的网站：RabbitMQ Simulator AMQP 核心概念 Broker：接收和分发 message 的应用，即 RabbitMQ 的 server。 Virtual Host：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于 namespace 概念。当多个不同的用户使用同一个RabbitMQ server 提供服务时，可以划分出多个 virtual host，每个用户在自己的 virtual host 创建 exchange/queue 等。 Connection： publisher/consumer 和 broker 之间的 TCP 连接。断开连接的操作只会在 client 端进行，broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。 Channel：如果每一次访问 RabbitMQ server 都建立一个 connection，在消息量大的时候建立 TCP connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，channel 作为轻量级的 connection 极大减少了操作系统建立 TCP connection 的开销。 Message：服务器和应用程序之间传送的数据，由 properties 和 body 组成。Properties 可以对 message 进行修饰，比如 message 的优先级、延迟等高级特性，body 就是 message 内容。 Queue：消息最终被送到这里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。 Exchange： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。 Binding： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。 Routing Key：单个路由规则，虚拟机可用它来确定如何路由一个 message。 协议模型 消息流转 Exchange 类型 主要有 3 种类型的 exchange。 Direct Exchange（直连交换机） Topic Exchange（主题交换机） Fanout Exchange（扇型交换机） Direct Exchange 消息传递时，Routing Key 必须完全匹配才会被队列接收，否则该消息会被抛弃。 Topic Exchange 模糊匹配的机制。 * 匹配一个单词 # 匹配零个或多个单词 发送到 topic exchange 的消息会被转发到所有关心 routing key 中指定 topic 的 queue 上 当特殊字符“*”（星号）和“＃”（哈希）未在绑定中使用时，主题交换机的行为就像直接交换机一样。 例如 上图示例创建了三个绑定：Q1 绑定了绑定键 *.orange.*，Q2 绑定了*.*.rabbit 和 lazy.#。 Q1 对所有 orange 感兴趣 Q2 希望听到关于 rabbit 的一切，以及关于 lazy 的一切 那么消息经过 topic exchange 的路由结果将会是如下情况。 quick.orange.rabbit 的消息会同时传递到两个队列 lazy.orange.elephant 的消息也会同事传递到两个队列 quick.orange.fox 只会传递到 Q1 lazy.brown.fox 只会转到 Q2 lazy.pink.rabbit 只会递到 Q2 一次，即使它匹配两个绑定 quick.brown.fox 与任何绑定都不匹配，因此它将被丢弃 lazy.orange.male.rabbit 虽然有四个单词，也会匹配最后一个绑定，并将被传递到 Q2 Fanout Exchange 名字比较形象了，像 fan 一样甩出消息到所有绑定的队列。 不处理 routing key，只需要简单的将队列绑定到交换机上 发送到 fanout exchange 的消息都会被转发到与该交换机绑定的所有队列上 Fanout Exchange 转发消息是最快的 RabbitMQ RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。 RabbitMQ 服务器是用 Erlang 语言编写的。 RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman. The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ messages. 安装 官网给了安装指引，MacOS 下用 HomeBrew 比较简单方便，但 Linux 下的步骤稍显凌乱，这里整理下 Ubuntu 的安装步骤。 添加 apt 仓库签名密钥 1 2 3 4 5 6 ## Team RabbitMQ&#39;s main signing key sudo apt-key adv --keyserver &quot;hkps://keys.openpgp.org&quot; --recv-keys &quot;0x0A9AF2115F4687BD29803A206B73A36E6026DFCA&quot; ## Launchpad PPA that provides modern Erlang releases sudo apt-key adv --keyserver &quot;keyserver.ubuntu.com&quot; --recv-keys &quot;F77F1EDA57EBB1CC&quot; ## PackageCloud RabbitMQ repository curl -1sLf &#39;https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey&#39; | apt-key add - 安装 apt-transport-https，以便能够从 PackageCloud、Cloudsmith.io、Launchpad 下载 RabbitMQ 和 Erlang 的包文件 1 sudo apt-get install apt-transport-https 添加第三方软件源，将以下内容添加至 /etc/apt/sources.list.d/rabbitmq.list，需要注意不同的 Ubuntu 版本的 distribution name 有差别。 focal for Ubuntu 20.04 bionic for Ubuntu 18.04 xenial for Ubuntu 16.04 buster for Debian Buster 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Source repository definition example. ## Provides modern Erlang/OTP releases ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main deb-src http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main ## Provides RabbitMQ ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main deb-src https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main 安装 RabbitMQ 及其相关依赖的包 1 2 3 4 5 6 7 8 9 10 11 12 ## Update package indices sudo apt-get update -y ## Install Erlang packages sudo apt-get install -y erlang-base \ erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \ erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \ erlang-runtime-tools erlang-snmp erlang-ssl \ erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl ## Install rabbitmq-server and its dependencies sudo apt-get install rabbitmq-server -y --fix-missing 启停和界面 1 2 3 4 5 6 7 8 9 10 11 # 启动 sudo service rabbitmq-server start # 停止 sudo service rabbitmq-server stop # 重启 sudo service rabbitmq-server restart # 查看当前状态 sudo service rabbitmq-server status RabbitMQ 提供了一个管理插件（rabbitmq_management），方便在 web 端管理 RabbitMQ，默认未开启需要在命令行开启该插件。开启插件并重启 RabbitMQ server 后，就可以通过浏览器进行管理，默认端口是 15672。 1 2 # 开启管理工具，然后重启服务即可通过 web 进行管理 sudo rabbitmq-plugins enable rabbitmq_management 默认有一个 guest/guest 的用户可以用来登录管理工具，同时也可以通过命令新建用户和赋予权限。 1 2 3 4 5 # 添加 admin/admin 用户 sudo rabbitmqctl add_user admin admin # 赋予其管理员权限 sudo rabbitmqctl set_user_tags admin administrator 示例 官网的一些开发示例：RabbitMQ Tutorials" /><link rel="canonical" href="/posts/message_queue/" /><meta property="og:url" content="/posts/message_queue/" /><meta property="og:site_name" content="Chai Yan" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-05-06T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="消息队列" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"[toc] 消息队列是一种进程间通信或同一进程的不同线程间的通信方式，直观一点的理解可以直接从字面进行理解，消息队列就是一个容纳消息的队列，producer 有新的消息就丢给队列，consumer 轮询队列进行消息的获取。 高级消息队列协议（Advanced Message Queuing Protocol AMQP）是面向消息中间件提供的开放的应用层协议。 消息队列有很多基于不同协议的开源实现：RabbitMQ（AMQP）、RocketMQ（自定协议）、Kafka（自定的基于TCP的二进制协议）。 RabbitMQ：性能好、延时低、管理界面友好、社区活跃。但吞吐量较低，erlang 语言实现，较难扩展。 RocketMQ：阿里出品，接口简单易用。 Kafka：提供较少的核心功能、具备超高的吞吐量、极高的可用性和拓展性。但存在消息重复消费的缺点，适合于大数据实时计算和日志收集。 消息队列常见的应用场景：异步处理、应用解耦、流量削峰、消息通讯等。 一个模拟 RabbitMQ 的网站：RabbitMQ Simulator AMQP 核心概念 Broker：接收和分发 message 的应用，即 RabbitMQ 的 server。 Virtual Host：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于 namespace 概念。当多个不同的用户使用同一个RabbitMQ server 提供服务时，可以划分出多个 virtual host，每个用户在自己的 virtual host 创建 exchange/queue 等。 Connection： publisher/consumer 和 broker 之间的 TCP 连接。断开连接的操作只会在 client 端进行，broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。 Channel：如果每一次访问 RabbitMQ server 都建立一个 connection，在消息量大的时候建立 TCP connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，channel 作为轻量级的 connection 极大减少了操作系统建立 TCP connection 的开销。 Message：服务器和应用程序之间传送的数据，由 properties 和 body 组成。Properties 可以对 message 进行修饰，比如 message 的优先级、延迟等高级特性，body 就是 message 内容。 Queue：消息最终被送到这里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。 Exchange： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。 Binding： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。 Routing Key：单个路由规则，虚拟机可用它来确定如何路由一个 message。 协议模型 消息流转 Exchange 类型 主要有 3 种类型的 exchange。 Direct Exchange（直连交换机） Topic Exchange（主题交换机） Fanout Exchange（扇型交换机） Direct Exchange 消息传递时，Routing Key 必须完全匹配才会被队列接收，否则该消息会被抛弃。 Topic Exchange 模糊匹配的机制。 * 匹配一个单词 # 匹配零个或多个单词 发送到 topic exchange 的消息会被转发到所有关心 routing key 中指定 topic 的 queue 上 当特殊字符“*”（星号）和“＃”（哈希）未在绑定中使用时，主题交换机的行为就像直接交换机一样。 例如 上图示例创建了三个绑定：Q1 绑定了绑定键 *.orange.*，Q2 绑定了*.*.rabbit 和 lazy.#。 Q1 对所有 orange 感兴趣 Q2 希望听到关于 rabbit 的一切，以及关于 lazy 的一切 那么消息经过 topic exchange 的路由结果将会是如下情况。 quick.orange.rabbit 的消息会同时传递到两个队列 lazy.orange.elephant 的消息也会同事传递到两个队列 quick.orange.fox 只会传递到 Q1 lazy.brown.fox 只会转到 Q2 lazy.pink.rabbit 只会递到 Q2 一次，即使它匹配两个绑定 quick.brown.fox 与任何绑定都不匹配，因此它将被丢弃 lazy.orange.male.rabbit 虽然有四个单词，也会匹配最后一个绑定，并将被传递到 Q2 Fanout Exchange 名字比较形象了，像 fan 一样甩出消息到所有绑定的队列。 不处理 routing key，只需要简单的将队列绑定到交换机上 发送到 fanout exchange 的消息都会被转发到与该交换机绑定的所有队列上 Fanout Exchange 转发消息是最快的 RabbitMQ RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。 RabbitMQ 服务器是用 Erlang 语言编写的。 RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman. The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ messages. 安装 官网给了安装指引，MacOS 下用 HomeBrew 比较简单方便，但 Linux 下的步骤稍显凌乱，这里整理下 Ubuntu 的安装步骤。 添加 apt 仓库签名密钥 1 2 3 4 5 6 ## Team RabbitMQ&#39;s main signing key sudo apt-key adv --keyserver &quot;hkps://keys.openpgp.org&quot; --recv-keys &quot;0x0A9AF2115F4687BD29803A206B73A36E6026DFCA&quot; ## Launchpad PPA that provides modern Erlang releases sudo apt-key adv --keyserver &quot;keyserver.ubuntu.com&quot; --recv-keys &quot;F77F1EDA57EBB1CC&quot; ## PackageCloud RabbitMQ repository curl -1sLf &#39;https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey&#39; | apt-key add - 安装 apt-transport-https，以便能够从 PackageCloud、Cloudsmith.io、Launchpad 下载 RabbitMQ 和 Erlang 的包文件 1 sudo apt-get install apt-transport-https 添加第三方软件源，将以下内容添加至 /etc/apt/sources.list.d/rabbitmq.list，需要注意不同的 Ubuntu 版本的 distribution name 有差别。 focal for Ubuntu 20.04 bionic for Ubuntu 18.04 xenial for Ubuntu 16.04 buster for Debian Buster 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Source repository definition example. ## Provides modern Erlang/OTP releases ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main deb-src http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main ## Provides RabbitMQ ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main deb-src https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main 安装 RabbitMQ 及其相关依赖的包 1 2 3 4 5 6 7 8 9 10 11 12 ## Update package indices sudo apt-get update -y ## Install Erlang packages sudo apt-get install -y erlang-base \\ erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \\ erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \\ erlang-runtime-tools erlang-snmp erlang-ssl \\ erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl ## Install rabbitmq-server and its dependencies sudo apt-get install rabbitmq-server -y --fix-missing 启停和界面 1 2 3 4 5 6 7 8 9 10 11 # 启动 sudo service rabbitmq-server start # 停止 sudo service rabbitmq-server stop # 重启 sudo service rabbitmq-server restart # 查看当前状态 sudo service rabbitmq-server status RabbitMQ 提供了一个管理插件（rabbitmq_management），方便在 web 端管理 RabbitMQ，默认未开启需要在命令行开启该插件。开启插件并重启 RabbitMQ server 后，就可以通过浏览器进行管理，默认端口是 15672。 1 2 # 开启管理工具，然后重启服务即可通过 web 进行管理 sudo rabbitmq-plugins enable rabbitmq_management 默认有一个 guest/guest 的用户可以用来登录管理工具，同时也可以通过命令新建用户和赋予权限。 1 2 3 4 5 # 添加 admin/admin 用户 sudo rabbitmqctl add_user admin admin # 赋予其管理员权限 sudo rabbitmqctl set_user_tags admin administrator 示例 官网的一些开发示例：RabbitMQ Tutorials","url":"/posts/message_queue/","@type":"BlogPosting","headline":"消息队列","dateModified":"2021-05-06T00:00:00+08:00","datePublished":"2021-05-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/message_queue/"},"@context":"https://schema.org"}</script><title>消息队列 | Chai Yan</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Chai Yan"><meta name="application-name" content="Chai Yan"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Chai Yan</a></div><div class="site-subtitle font-italic">Personal technical blog, recording interesting things.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/chaidouzi" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>消息队列</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>消息队列</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> your_full_name </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, May 6, 2021, 12:00 AM +0800" >May 6<i class="unloaded">2021-05-06T00:00:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1903 words">10 min read</span></div></div><div class="post-content"><p>[toc]</p><p><a href="https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a>是一种进程间通信或同一进程的不同线程间的通信方式，直观一点的理解可以直接从字面进行理解，消息队列就是一个容纳消息的队列，producer 有新的消息就丢给队列，consumer 轮询队列进行消息的获取。</p><p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8D%8F%E8%AE%AE">高级消息队列协议</a>（Advanced Message Queuing Protocol AMQP）是面向消息中间件提供的开放的应用层协议。</p><p>消息队列有很多基于不同协议的开源实现：RabbitMQ（AMQP）、RocketMQ（自定协议）、Kafka（自定的基于TCP的二进制协议）。</p><ul><li>RabbitMQ：性能好、延时低、管理界面友好、社区活跃。但吞吐量较低，erlang 语言实现，较难扩展。<li>RocketMQ：阿里出品，接口简单易用。<li>Kafka：提供较少的核心功能、具备超高的吞吐量、极高的可用性和拓展性。但存在消息重复消费的缺点，适合于大数据实时计算和日志收集。</ul><p>消息队列常见的应用场景：异步处理、应用解耦、流量削峰、消息通讯等。</p><p>一个模拟 RabbitMQ 的网站：<a href="http://tryrabbitmq.com/">RabbitMQ Simulator</a></p><h4 id="amqp-核心概念">AMQP 核心概念</h4><ul><li><p><strong>Broker</strong>：接收和分发 message 的应用，即 RabbitMQ 的 server。</p><li><p><strong>Virtual Host</strong>：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于 namespace 概念。当多个不同的用户使用同一个RabbitMQ server 提供服务时，可以划分出多个 virtual host，每个用户在自己的 virtual host 创建 exchange/queue 等。</p><li><p><strong>Connection</strong>： publisher/consumer 和 broker 之间的 TCP 连接。断开连接的操作只会在 client 端进行，broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。</p><li><p><strong>Channel</strong>：如果每一次访问 RabbitMQ server 都建立一个 connection，在消息量大的时候建立 TCP connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，channel 作为轻量级的 connection 极大减少了操作系统建立 TCP connection 的开销。</p><li><p><strong>Message</strong>：服务器和应用程序之间传送的数据，由 properties 和 body 组成。Properties 可以对 message 进行修饰，比如 message 的优先级、延迟等高级特性，body 就是 message 内容。</p><li><p><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。</p><li><p><strong>Exchange</strong>： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。</p><li><p><strong>Binding</strong>： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</p><li><p><strong>Routing Key</strong>：单个路由规则，虚拟机可用它来确定如何路由一个 message。</p></ul><p><strong>协议模型</strong></p><p><img data-proofer-ignore data-src="/images/amqp-arch1.png" style="zoom: 67%;" /></p><p><img data-proofer-ignore data-src="/images/amqp-arch2.png" alt="" /></p><p><strong>消息流转</strong></p><p><img data-proofer-ignore data-src="/images/amqp-message-flow.jpg" style="zoom:67%;" /></p><h4 id="exchange-类型">Exchange 类型</h4><p>主要有 3 种类型的 exchange。</p><ul><li>Direct Exchange（直连交换机）<li>Topic Exchange（主题交换机）<li>Fanout Exchange（扇型交换机）</ul><h5 id="direct-exchange">Direct Exchange</h5><p>消息传递时，Routing Key 必须完全匹配才会被队列接收，否则该消息会被抛弃。</p><p><img data-proofer-ignore data-src="/images/direct-exchange.png" style="zoom:40%;" /></p><h5 id="topic-exchange">Topic Exchange</h5><p>模糊匹配的机制。</p><ul><li>* 匹配一个单词<li># 匹配零个或多个单词<li>发送到 topic exchange 的消息会被转发到所有关心 routing key 中指定 topic 的 queue 上<li>当特殊字符“*”（星号）和“＃”（哈希）未在绑定中使用时，主题交换机的行为就像直接交换机一样。</ul><p><img data-proofer-ignore data-src="/images/topic-exchange.png" style="zoom:40%;" /></p><p><strong>例如</strong></p><p><img data-proofer-ignore data-src="/images/topic-exchange-example.png" alt="" /></p><p>上图示例创建了三个绑定：Q1 绑定了绑定键 <code class="language-plaintext highlighter-rouge">*.orange.*</code>，Q2 绑定了<code class="language-plaintext highlighter-rouge">*.*.rabbit</code> 和 <code class="language-plaintext highlighter-rouge">lazy.#</code>。</p><ul><li>Q1 对所有 <strong>orange</strong> 感兴趣<li>Q2 希望听到关于 <strong>rabbit</strong> 的一切，以及关于 <strong>lazy</strong> 的一切</ul><p>那么消息经过 topic exchange 的路由结果将会是如下情况。</p><ul><li>quick.orange.rabbit 的消息会同时传递到两个队列<li><p>lazy.orange.elephant 的消息也会同事传递到两个队列</p><li>quick.orange.fox 只会传递到 Q1<li>lazy.brown.fox 只会转到 Q2<li>lazy.pink.rabbit 只会递到 Q2 一次，即使它匹配两个绑定<li>quick.brown.fox 与任何绑定都不匹配，因此它将被丢弃<li>lazy.orange.male.rabbit 虽然有四个单词，也会匹配最后一个绑定，并将被传递到 Q2</ul><h5 id="fanout-exchange">Fanout Exchange</h5><p>名字比较形象了，像 fan 一样甩出消息到所有绑定的队列。</p><ul><li>不处理 routing key，只需要简单的将队列绑定到交换机上<li>发送到 fanout exchange 的消息都会被转发到与该交换机绑定的所有队列上<li>Fanout Exchange 转发消息是最快的</ul><p><img data-proofer-ignore data-src="/images/fanout-exchange.png" style="zoom:40%;" /></p><h4 id="rabbitmq">RabbitMQ</h4><p><a href="https://www.rabbitmq.com/">RabbitMQ</a> 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。</p><p>RabbitMQ 服务器是用 <a href="https://www.erlang.org/">Erlang</a> 语言编写的。</p><blockquote><p>RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman.</p><p>The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ <em>messages</em>.</p></blockquote><h5 id="安装">安装</h5><p>官网给了<a href="https://www.rabbitmq.com/download.html">安装指引</a>，MacOS 下用 HomeBrew 比较简单方便，但 Linux 下的步骤稍显凌乱，这里整理下 Ubuntu 的安装步骤。</p><ol><li><p>添加 apt 仓库签名密钥</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c">## Team RabbitMQ's main signing key</span>
<span class="nb">sudo </span>apt-key adv <span class="nt">--keyserver</span> <span class="s2">"hkps://keys.openpgp.org"</span> <span class="nt">--recv-keys</span> <span class="s2">"0x0A9AF2115F4687BD29803A206B73A36E6026DFCA"</span>
<span class="c">## Launchpad PPA that provides modern Erlang releases</span>
<span class="nb">sudo </span>apt-key adv <span class="nt">--keyserver</span> <span class="s2">"keyserver.ubuntu.com"</span> <span class="nt">--recv-keys</span> <span class="s2">"F77F1EDA57EBB1CC"</span>
<span class="c">## PackageCloud RabbitMQ repository</span>
curl <span class="nt">-1sLf</span> <span class="s1">'https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey'</span> | apt-key add -
</pre></table></code></div></div><li><p>安装 <code class="language-plaintext highlighter-rouge">apt-transport-https</code>，以便能够从 PackageCloud、Cloudsmith.io、Launchpad 下载 RabbitMQ 和 Erlang 的包文件</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>apt-get <span class="nb">install </span>apt-transport-https
</pre></table></code></div></div><li><p>添加第三方软件源，将以下内容添加至 <code class="language-plaintext highlighter-rouge">/etc/apt/sources.list.d/rabbitmq.list</code>，需要注意不同的 Ubuntu 版本的 distribution name 有差别。</p><ul><li><code class="language-plaintext highlighter-rouge">focal</code> for Ubuntu 20.04<li><code class="language-plaintext highlighter-rouge">bionic</code> for Ubuntu 18.04<li><code class="language-plaintext highlighter-rouge">xenial</code> for Ubuntu 16.04<li><code class="language-plaintext highlighter-rouge">buster</code> for Debian Buster</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c"># Source repository definition example.</span>
   
<span class="c">## Provides modern Erlang/OTP releases</span>
<span class="c">##</span>
<span class="c">## "bionic" as distribution name should work for any reasonably recent Ubuntu or Debian release.</span>
<span class="c">## See the release to distribution mapping table in RabbitMQ doc guides to learn more.</span>
deb http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main
deb-src http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main
   
<span class="c">## Provides RabbitMQ</span>
<span class="c">##</span>
<span class="c">## "bionic" as distribution name should work for any reasonably recent Ubuntu or Debian release.</span>
<span class="c">## See the release to distribution mapping table in RabbitMQ doc guides to learn more.</span>
deb https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main
deb-src https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main
</pre></table></code></div></div><li><p>安装 RabbitMQ 及其相关依赖的包</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c">## Update package indices</span>
<span class="nb">sudo </span>apt-get update <span class="nt">-y</span>
   
<span class="c">## Install Erlang packages</span>
<span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> erlang-base <span class="se">\</span>
                        erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets <span class="se">\</span>
                        erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key <span class="se">\</span>
                        erlang-runtime-tools erlang-snmp erlang-ssl <span class="se">\</span>
                        erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl
   
<span class="c">## Install rabbitmq-server and its dependencies</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>rabbitmq-server <span class="nt">-y</span> <span class="nt">--fix-missing</span>
</pre></table></code></div></div></ol><h5 id="启停和界面">启停和界面</h5><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c"># 启动</span>
<span class="nb">sudo </span>service rabbitmq-server start

<span class="c"># 停止</span>
<span class="nb">sudo </span>service rabbitmq-server stop 

<span class="c"># 重启</span>
<span class="nb">sudo </span>service rabbitmq-server restart 

<span class="c"># 查看当前状态</span>
<span class="nb">sudo </span>service rabbitmq-server status 
</pre></table></code></div></div><p>RabbitMQ 提供了一个管理插件（rabbitmq_management），方便在 web 端管理 RabbitMQ，默认未开启需要在命令行开启该插件。开启插件并重启 RabbitMQ server 后，就可以通过浏览器进行管理，默认端口是 15672。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 开启管理工具，然后重启服务即可通过 web 进行管理</span>
<span class="nb">sudo </span>rabbitmq-plugins <span class="nb">enable </span>rabbitmq_management
</pre></table></code></div></div><p>默认有一个 guest/guest 的用户可以用来登录管理工具，同时也可以通过命令新建用户和赋予权限。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># 添加 admin/admin 用户</span>
<span class="nb">sudo </span>rabbitmqctl add_user admin admin

<span class="c"># 赋予其管理员权限</span>
<span class="nb">sudo </span>rabbitmqctl set_user_tags admin administrator 
</pre></table></code></div></div><h5 id="示例">示例</h5><p>官网的一些开发示例：<a href="https://www.rabbitmq.com/getstarted.html">RabbitMQ Tutorials</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/tool/'>tool</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/rabbitmq/" class="post-tag no-text-decoration" >rabbitmq</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=消息队列 - Chai Yan&url=/posts/message_queue/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=消息队列 - Chai Yan&u=/posts/message_queue/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=消息队列 - Chai Yan&url=/posts/message_queue/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/latex/">latex</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/java8/">java8</a> <a class="post-tag" href="/tags/mac/">mac</a> <a class="post-tag" href="/tags/vim/">vim</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/json/">json</a> <a class="post-tag" href="/tags/lambda/">lambda</a> <a class="post-tag" href="/tags/manjaro/">manjaro</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/jekyll_github_blog/"><div class="card-body"> <span class="timeago small" >Jan 3, 2019<i class="unloaded">2019-01-03T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>使用 Jekyll 和 GitHub 搭建个人博客</h3><div class="text-muted small"><p> 一、Jekyll 环境搭建 Jekyll 官网、Jekyll 中文网 Jekyll 介绍 Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 Markdown）和 Liquid 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub P...</p></div></div></a></div><div class="card"> <a href="/posts/mac_tool/"><div class="card-body"> <span class="timeago small" >Jan 12, 2019<i class="unloaded">2019-01-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Mac 工具配置</h3><div class="text-muted small"><p> 一、Sublime Sublime Text 是一套跨平台的文本编辑器，支持基于 Python 的插件。Sublime Text是专有软件，可透过包（Package）扩展。大多数的包使用自由软件授权发布，并由社群建置维护。 配置在命令行可使用 Sublime 打开文本文件。官方配置 配置方法 $ ln -s "/Applications/Sublime Text.app/Conten...</p></div></div></a></div><div class="card"> <a href="/posts/git/"><div class="card-body"> <span class="timeago small" >Jan 13, 2019<i class="unloaded">2019-01-13T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Git</h3><div class="text-muted small"><p> Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 A Visual Git Reference 以图形化方式加深对 git 命令的理解。 一、Git库建立 git 库可以通过本地新建和克隆远程仓库两种方式实现。 #本地新建 git ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/git_inner/" class="btn btn-outline-primary" prompt="Older"><p>Git 对象</p></a> <a href="/posts/chip_on_board/" class="btn btn-outline-primary" prompt="Newer"><p>Chip-On-Board</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/chaidouzi">your_full_name</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/latex/">latex</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/java8/">java8</a> <a class="post-tag" href="/tags/mac/">mac</a> <a class="post-tag" href="/tags/vim/">vim</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/json/">json</a> <a class="post-tag" href="/tags/lambda/">lambda</a> <a class="post-tag" href="/tags/manjaro/">manjaro</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
