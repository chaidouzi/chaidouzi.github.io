[ { "title": "快捷指令", "url": "/posts/mac_shortcuts/", "categories": "tool", "tags": "mac", "date": "2021-11-02 00:00:00 +0800", "snippet": "装了 OpenWrt 做旁路网关后，会遇到要在两套或者三套网络配置之间切换的情况，Mac 下有个自带的 networksetup 可以在命令行进行配置，但频繁切换的时候打那么一串命令也挺烦人。最后发现 Shortcuts（快捷指令）的 Run Shell Script 可以干这个事，以下是具体配置：配置1：旁路网关networksetup -setmanual Wi-Fi 192.168.31.3 255.255.255.0 192.168.31.2networksetup -setdnsservers Wi-Fi 192.168.31.2配置2：主路由networksetup -setmanual Wi-Fi 192.168.31.3 255.255.255.0 192.168.31.1networksetup -setdnsservers Wi-Fi 192.168.31.1配置3：dhcpnetworksetup -setdhcp Wi-Finetworksetup -setdnsservers Wi-Fi &quot;Empty&quot;配置添加好后可以让它们出现在 menu bar 上，这样直接在 menu bar 上用鼠标点点就能切换网络配置了，更懒的话还能在 spotlight 里找到并触发。最后附上一些 url scheme，用法不写了，网上一搜一大把。bhagyas/app-urls：A long list of App URLs for iOS, macOS and Android常用 URL Schemes 收集" }, { "title": "Manjaro i3", "url": "/posts/manjaro_i3/", "categories": "linux", "tags": "manjaro", "date": "2021-11-02 00:00:00 +0800", "snippet": "不经意间入了 i3 的坑，感觉很好用，尤其是在虚拟机里专门写代码的场景下。1. i3i3 是一款平铺式桌面管理器，跟我们常用的桌面管理器最大的区别就是窗口不会重叠（浮窗除外），并且其非常轻量。平铺式简单的描述就是：当用户只开一个窗口时，该窗口会占据整个桌面，当开了两个窗口时，这两个窗口会平分桌面，依次类推。如下，一图胜千言。同时，i3 主要的用法是通过快捷键用键盘来控制窗口和工作区，堪称键盘党和强迫症的福音。附上官网提供的默认快捷键图：具体的使用方法和窗口树的概念花15分钟看下官方文档前三章就足够了：i3 User’s Guide。2. VMware Fusion 配置 Manjaro i3下载地址：Manjaro i3VMware 配置： 按需添加共享目录 按需调整 CPU 和 内存，并 enable hypervisor 和 IOMMU 按需调整硬盘大小 USB 兼容性调成 USB 3.1 Disable Side Channle Mitigations安装过程不用太多说明，一路鼠标点点点，之后重启就好了。只有一处需要注意，在进度到 93% 时安装程序应该会从默认的官方源安装一些东西，如果不能访问国外的网络，可能会在 93% 处等比较久。配置的重头主要在安装完成后的 Manjaro 系统上，具体步骤如下。2.1 更新安装完成并重启登录后： 参考桌面左下角，先了解下 i3 的快捷键：mod + Enter 打开 terminal。mod 在 mac 下一般为 command 或 option，在 windows 下为 alt 或 win。 sudo pacman-mirrors -i -c China -m rank 挑个自己中意的镜像源。 sudo pacman -Syyu 更新系统。 sudo mhwd-kernel -i linux510 rmc 换个 LTS 版本的内核。2.2 open-vm-toolsopen-vm-tools 就是 VMware 的一些工具： vmtoolsd - 负责汇报虚拟机状态的服务。 vmware-checkvm - 用于检测虚拟机中是否在运行着某程序的工具。 vmware-toolbox-cmd - 用于收集宿主系统信息的工具。 vmware-user - Tool to enable clipboard sharing (copy/paste) between host and guest. vmware-vmblock-fuse - 文件系统。基于 FUSE (Filesystem in Userspace) 实现了宿主 / 客机之间拖拽文件。 vmware-xferlogs - 向虚拟机的日志文件输出日志与调试信息。 vmhgfs-fuse - 挂载 HGFS 共享目录的工具。以上工具已经默认安装了，但还是有些问题需要解决，参考：VMware/Install Arch Linux as a guest。 分辩率无法调整 sudo vi /etc/systemd/system/multi-user.target.wants/vmtoolsd.service 在 “ExecStart” 之前添加一行 ExecStartPre=/usr/bin/sleep 3s 给 vmtoolsd 增加 3s 启动延迟。 主宿机之间无法 copy/paste vi .i3/config 添加一行 exec_always --no-startup-id vmware-user-suid-wrapper &amp;amp; 主宿机之间文件无法共享 去掉 /etc/fuse.conf 文件中 user_allow_other 前的注释符。 vi .i3/config 添加一行 exec_always --no-startup-id vmhgfs-fuse -o allow_other -o auto_unmount .host:/ /home/cy/Shares 语法：vmhgfs-fuse -o allow_other -o auto_unmount .host:/&amp;lt;shared_folder&amp;gt; &amp;lt;shared folders root directory&amp;gt; 烦人的主板 beep echo &quot;blacklist pcspkr&quot; &amp;gt; /etc/modprobe.d/nobeep.conf 重启下确定配置生效。2.3 个性化到这里就是看个人喜好配置了，先装好 fish、vim。 开启 sshd systemctl enable sshd 状态栏置顶，改时间格式 .i3/config 是 i3 的主配置文件，里边有各种快捷键、启动项、桌面绑定等配置。 更改 .i3/config 的 bar 位置为 top： bar { i3bar_command i3bar status_command i3status position top ...} 参考 configuration file path，把 /etc/i3status.conf 拷贝到 .config/i3status/config，删掉没啥用的信息： # order += &quot;ipv6&quot;order += &quot;cpu_usage&quot;order += &quot;disk /&quot;# order += &quot;disk /home&quot;# order += &quot;wireless _first_&quot;# order += &quot;ethernet _first_&quot;# order += &quot;battery all&quot;# order += &quot;load&quot;order += &quot;memory&quot;order += &quot;tztime local&quot;...tztime local { format = &quot;%Y-%m-%d %H:%M:%S&quot; # format = &quot; %d.%m. %H:%M &quot;} 窗口间移动改成 vim 的 hjkl 在 .i3/config 中搜索 semicolon，替换为 l ，相应的 jkl 也改为 hjk 并保存，mod + shift + r 刷新后会提示冲突，把冲突的改掉即可。 安装 firefox，把 mod + f2 改为启动 firefox bindsym $mod+F2 exec firefox 绑定 app 到不同工作区 assign [class=&quot;(?i)urxvt&quot;] $ws1assign [class=&quot;(?i)firefox&quot;] $ws2assign [class=&quot;Pcmanfm&quot;] $ws3 关闭 conky，# exec --no-startup-id start_conky_maia 选张壁纸，nitrogen 终端透明 Opacity，在 .config/picom.conf 中添加： opacity-rule = [ &quot;90:class_g = &#39;URxvt&#39; &amp;amp;&amp;amp; focused&quot;, &quot;60:class_g = &#39;URxvt&#39; &amp;amp;&amp;amp; !focused&quot;]; 90、60 分别表示焦点和失焦的透明度。别外，可以通过快捷键：mod + t 和 mod + crtl + t 快速关闭和打开 picom（透明特效）。 中文输入法，Fcitx5 Fcitx5 是继 Fcitx 后的新一代输入法框架。 fcitx5-im 包组提供了 fcitx5 本体、配置工具、和必要的输入法模块。 fcitx5 仅提供基本框架，仅提供英文支持，如果要输入其他语言（例如中文），则需要输入法引擎。 fcitx5-chinese-addons、fcitx5-rime 为不同的中文输入法引擎。 安装 sudo pacman -S fcitx5-imsudo pacman -S fcitx5-chinese-addons 配置，在 ~/.pam_environment 中设置以下环境变量。 GTK_IM_MODULE DEFAULT=fcitxQT_IM_MODULE DEFAULT=fcitxXMODIFIERS DEFAULT=@im=fcitxINPUT_METHOD DEFAULT=fcitxSDL_IM_MODULE DEFAULT=fcitx 开机启动 exec --no-startup-id fcitx5 -d 2.4 遗留问题虚拟机启动的时候经常黑屏，没找到解决办法，遇到启动黑屏时只能多启动几次。" }, { "title": "树莓派安装 OpenWrt", "url": "/posts/openwrt/", "categories": "pi", "tags": "openwrt", "date": "2021-11-01 00:00:00 +0800", "snippet": "最近家里网络不给力，加上树莓派吃了很久的灰，就给它刷了个 OpenWrt 当旁路网关用。 OpenWrt (from open wireless router) is an open-source project for embedded operating systems based on Linux, primarily used on embedded devices to route network traffic. OpenWrt 是基于 Linux 的开源的嵌入式操作系统，主要用在嵌入式设备上用于路由网络流量。文档如何给树莓派安装 OpenWrt，网上已经有大佬做好了（向大佬致敬），教程和文档都清晰明了，以下是链接： coolsnowwolf/lede，Lean 大的 OpenWrt 源码，喜欢折腾的朋友可以按照 README 编译自己的固件，没实力也不想折腾的话可以直接第二步找 SuLingGG。 SuLingGG/OpenWrt-Rpi，成品 OpenWrt 固件，树莓派 1B-4B 全部有对应固件，按下边 3 篇贴子操作即可： 固件下载，讲怎么下载固件，这是下载地址 旁路由设置指南，讲怎么进行初始化配置 SD 卡分区扩容指南，如果 SD 卡比较大，可以在安装完成后进行括容，以利用剩余空间 个人安装记录 从 SuLingGG 提供的固件列表中选择 Lean 的版本下载，并使用 ecther 烧录到 SD 卡（使用 Raspberry Pi Imager 会报错）。 上电启动树莓派，等待 2-3 分钟系统安装完成后，通过无线方式连接到热点 OpenWrt，在浏览器中输入：192.168.1.1，用户名：root，密码：password。（如果访问有问题，可以检查下 wifi 的配置，调成 dhcp 应该就可以访问了） 登录成功后，更改 LAN （网络 -&amp;gt; 接口 -&amp;gt; LAN）的 IPv4地址为主路由同一网段地址。譬如，主路由地址为 192.168.0.1，则 LAN 的地址应为 192.168.0.x，又或者主路由的地址为 192.168.31.1，则 LAN 的地址应为 192.168.31.x。配置好后点击“保存&amp;amp;应用”，这时主机跟 OpenWrt 的连接会断开，需要在浏览器中重新访问更改后的 ip（即 192.168.0.x）。 重新连接好之后，需要再进行其它配置，网关：主路由的 ip；广播：主路由同网段，最后一段改为 255；DNS：主路由的 ip；页面底部：忽略此接口/不在此接口提供 DHCP 服务。配置好后点击“保存&amp;amp;应用”。 如果不需要括容，就可以直接进行下一步了。对不同的 img，括容方式不同。ext4 需要 Linux 的 Gparted 工具。我安装的是 Squashfs，要做的操作如下： 在“系统 - 磁盘管理”中找到 SD 卡设备（/dev/mmcblk0），点击“修改” 在分区信息中可以看出 SD 卡中有 xxG 的空闲空间，点击右侧“新建”按钮新建分区 分区新建完成，点击“格式化” 选择 ext4 分区作为新分区的文件系统 分区已成功格式化为 ext4 格式 进入 OpenWrt 的 TTYD 或 SSH，进行迁移文件操作 # 将刚刚新建的 /dev/mmcblk0p3 分区挂载至 /mntroot@OpenWrt:/# mount /dev/mmcblk0p3 /mnt # 查看分区挂载情况root@OpenWrt:/# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTloop0 7:0 0 760.8M 0 loop /overlaymmcblk0 179:0 0 14.9G 0 disk ├─mmcblk0p1 179:1 0 64M 0 part /boot├─mmcblk0p2 179:2 0 960M 0 part /rom└─mmcblk0p3 179:3 0 13.8G 0 part /mnt # 将 /overlay 分区下的所有文件拷贝至刚刚建立好的分区内root@OpenWrt:/# cp -f -a /overlay/. /mnt # 查看是否拷贝成功root@OpenWrt:/# ls -a /mnt. .. .fs_state lost+found upper workroot@OpenWrt:/# ls -a /overlay. .. .fs_state upper work # 同步文件root@OpenWrt:/# sync # 卸载 /dev/mmcblk0p3 分区root@OpenWrt:/# umount /mnt 前往“系统 - 挂载点”，点击“生成配置” 在“挂载点”中我们可以看到刚刚创建好的 ext4 分区 /dev/mmcblk0p3，点击右方“修改” 在接下来的界面中，“启用此挂载点”并选择“作为外部 overlay 使用”，点击“保存&amp;amp;应用” 在“系统 - 挂载点”页面下，确认挂载点已启用 (打钩)，并确认挂载点为 /overlay，点击下方“保存&amp;amp;应用”，之后重启 OpenWrt 验证分区扩容成功 root@OpenWrt:/# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTloop0 7:0 0 760.8M 0 loop /mnt/loop0mmcblk0 179:0 0 14.9G 0 disk ├─mmcblk0p1 179:1 0 64M 0 part /boot├─mmcblk0p2 179:2 0 960M 0 part /rom└─mmcblk0p3 179:3 0 13.8G 0 part /overlay root@OpenWrt:/# mount | grep overlay/dev/mmcblk0p3 on /overlay type ext4 (rw,relatime)overlayfs:/overlay on / type overlay (rw,noatime,lowerdir=/,upperdir=/overlay/upper,workdir=/overlay/work)overlayfs:/overlay on /opt/docker type overlay (rw,noatime,lowerdir=/,upperdir=/overlay/upper,workdir=/overlay/work) root@OpenWrt:/# df -h | grep overlay/dev/mmcblk0p3 13.5G 42.2M 12.8G 0% /overlayoverlayfs:/overlay 13.5G 42.2M 12.8G 0% /overlayfs:/overlay 13.5G 42.2M 12.8G 0% /opt/docker 树莓派关闭 wifi 后通过网线接入主路由的 LAN。 客户端的配置：IP 获取方式改为 “静态（或手动）”，DNS：填写为树莓派 Lan 口 IP，网关/路由器：填写为树莓派 Lan 口 IP。 以上就是树莓派安装 OpenWrt 的过程，致此旁路网关已经可以工作了。如果不想直接在树莓派中装 OpenWrt，SuLingGG 还提供了在 Docker 中运行 OpenWrt 的方式：在Docker 中运行 OpenWrt 旁路网关。下边我的安装中还有额外的两步用来配置网络共享： SD 卡比较大又括容了的话，其实可以利用括容后的空间提供 Samba 服务。首先，在“网络存储 -&amp;gt; 网络共享 -&amp;gt; 编辑模版”中用 # 号注释掉 invalid users = root 使 root 用户可以用于 Samba 服务访问。其次，在命令行中输入 smbpasswd -a root 设定密码并把 root 用户添加到 Samba 中，之后就可以在不同设备上访问 Samba 服务了。Openwrt 下 Samba 服务涉及如下配置文件： /etc/samba/smb.conf.template：存放公共配置（模版） /etc/config/samba：UCI 配置 /etc/samba/smb.conf：Samba 服务运行时加载的文件，由前两个文件组合而成 阿里云盘 WebDAV 服务，主要使用场景为配合支持 WebDAV 协议的客户端 App 如 Infuse、nPlayer 等实现在电视上直接观看云盘视频内容， 支持上传文件，但受限于 WebDAV 协议不支持文件秒传。使用方式推荐 docker： docker run -d --name=aliyundrive-webdav --restart=unless-stopped -p 8080:8080 \\ -v /etc/aliyundrive-webdav/:/etc/aliyundrive-webdav/ \\ -e REFRESH_TOKEN=&#39;your refresh token&#39; \\ -e WEBDAV_AUTH_USER=admin \\ -e WEBDAV_AUTH_PASSWORD=admin \\ messense/aliyundrive-webdav refresh token 在登录阿里云盘后，打开开发者工具：storage -&amp;gt; local storage -&amp;gt; token 中找出 refresh_token。 " }, { "title": "Manjaro", "url": "/posts/manjaro/", "categories": "linux", "tags": "manjaro", "date": "2021-10-10 00:00:00 +0800", "snippet": "闲来无事折腾了下 Manjaro。Manjaro Linux（或简称 Manjaro）是基于 Arch Linux 的 Linux 发行版，使用 Xfce 、GNOME和 KDE Plasma 作为默认桌面环境，和 Arch 一样，采用滚动更新。其目标是为 PC 提供易于使用的自由的操作系统。 官方支持的桌面环境包括 Xfce、GNOME 和 KDE Plasma 社区支持的桌面环境包括：MATE、LXDE、Cinnamon、Awesome、Bspwm、 Budgie、i3、LXQt 和 Openbox 等1. 安装环境： macOS Big Sur VMware Fusion Player 12.1：REGISTER FOR A PERSONAL USE LICENSE 非商业用途情况下，免费注册一个个人 license 就可以使用正版软件，虽然相对 Fusion Pro 裁剪了一些功能，但不影响个人使用。 Manjaro KDE除了最后遇到分辨率的问题，其余安装部分都很简单，以下是虚拟机的配置： CPU：2核心 内存：8GB 硬盘：30GB 开启虚拟化 Intel VT-x 和 IOMMU 开启 3D 图形加速 勾选 Disable Side Channel Mitigations：vmware 提示说 Side Channel Mitigation 这个功能安全但是影响性能，就关了VMware 加载镜像后到了安装界面，勾选和填写一些基本信息进行安装，完成后重启进入系统就出现了分辨率的问题。桌面环境一直是 800 * 600 的分辨率无法调整，查半天原因应该是 vmtoolsd 这个服务没启来，大概有 3 种解决方式： 每次系统启动后，手动输入 sudo systemctl restart vmtoolsd 来启动该服务。虽然感觉有点蠢，但 Linux 一般也不关机，所以这方法也能用。 自己再写个服务，保证每次系统启动都会执行 sudo systemctl restart vmtoolsd。 Step 1：写个脚本 FixResolution.sh 来存放命令 #!/bin/bashsudo systemctl restart vmtoolsd Step 2：给脚本加执行权限，并放到个 bin 目录下（不放也行，只要自己记着路径就行） sudo chmod +x FixResolution.shsudo cp FixResolution.sh /usr/local/bin/FixResolution.sh Step 3：再写个 FixResolution.service 文件作为服务（注意 ExecStartPre 是关键，它表示服务执行前的延迟） [Unit]Description=Fix Resolution Service. [Service]Type=simpleExecStartPre=/bin/sleep 5sExecStart=/bin/bash /usr/local/bin/FixResolution.sh [Install]WantedBy=multi-user.target Step 4：把服务文件丢到 /etc/systemd/system 目录下 sudo mv FixResolution.service /etc/systemd/system/FixResolution.servicesudo chmod 644 /etc/systemd/system/FixResolution.service Step 5：启动服务并配置开机就启动 sudo systemctl start FixResolutionsudo systemctl enable FixResolution 最简单的方法，直接在 vmtoolsd 服务的配置里加执行前延迟（ExecStartPre=/bin/sleep 3s）也可行… [Unit]Description=Open Virtual Machine Tools (VMware Tools)ConditionVirtualization=vmwareAfter=display-manager.service [Service]ExecStartPre=/bin/sleep 3sExecStart=/usr/bin/vmtoolsd [Install]WantedBy=multi-user.target 总归用了以上办法，分辨率的问题是解决了，之后就要做一些使用前的配置了。2. 安装后配置## 换源，命令执行后会弹个交互框，挑个自己喜欢的...sudo pacman-mirrors -i -c China -m rank## 升级系统和所有软件sudo pacman -Syyu## 安装 yay 并换源sudo pacman -S yayyay --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot; --save## 安装元包，配置vimsudo pacman -S base-devel vim## 安装代理（可选）sudo ln -s /usr/lib/libpcap.so /usr/lib/libpcap.so.0.8yay -S xxx-bin## 备份 .zshrc（自带的配置也挺好看的），安装 oh-my-zsh 及插件mv .zshrc .zshrc.baksh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10kSet ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;## 安装各种应用及工具等typora libreoffice IntelliJ ...下边是一些 pacman常用命令：## 安装软件pacman -S 软件名: 安装软件。也可以同时安装多个包，只需以空格分隔包名即可pacman -S --needed 软件名1 软件名2: 安装软件，但不重新安装已经是最新的软件pacman -Sy 软件名：安装软件前，先从远程仓库下载软件包数据库(数据库即所有软件列表)pacman -Sv 软件名：在显示一些操作信息后执行安装pacman -Sw 软件名: 只下载软件包，不安装pacman -U 软件名.pkg.tar.gz：安装本地软件包pacman -U http://www.example.com/repo/example.pkg.tar.xz : 安装一个远程包（不在 pacman 配置的源里面）## 更新系统pacman -Sy: 从服务器下载新的软件包数据库（实际上就是下载远程仓库最新软件列表到本地）pacman -Su: 升级所有已安装的软件包pacman -Syu: 升级整个系统## 卸载软件pacman -R 软件名: 该命令将只删除包，保留其全部已经安装的依赖关系pacman -Rv 软件名: 删除软件，并显示详细的信息pacman -Rs 软件名: 删除软件，同时删除本机上只有该软件依赖的软件pacman -Rsc 软件名: 删除软件，并删除所有依赖这个软件的程序，慎用pacman -Ru 软件名: 删除软件,同时删除不再被任何软件所需要的依赖## 搜索软件pacman -Ss 关键字: 在仓库中搜索含关键字的软件包（本地已安装的会标记）pacman -Sl &amp;lt;repo&amp;gt;: 显示软件仓库中所有软件的列表 可以省略，通常这样用:`pacman -Sl | 关键字`pacman -Qs 关键字: 搜索已安装的软件包pacman -Qu: 列出所有可升级的软件包pacman -Qt: 列出不被任何软件要求的软件包pacman -Q 软件名: 查看软件包是否已安装，已安装则显示软件包名称和版本pacman -Qi 软件名: 查看某个软件包信息，显示较为详细的信息，包括描述、构架、依赖、大小等等pacman -Ql 软件名: 列出软件包内所有文件，包括软件安装的每个文件、文件夹的名称和路径## 软件包组pacman -Sg: 列出软件仓库上所有的软件包组pacman -Qg: 列出本地已经安装的软件包组和子包pacman -Sg 软件包组: 查看某软件包组所包含的所有软件包pacman -Qg 软件包组: 和pacman -Sg 软件包组完全一样## 清理缓存pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录pacman -Scc：清理所有的缓存文件## 最常用的 pacman 命令小结pacman -Syu: 升级系统及所有已经安装的软件pacman -S 软件名: 安装软件。也可以同时安装多个包，只需以空格分隔包名即可pacman -Rs 软件名: 删除软件，同时删除本机上只有该软件依赖的软件pacman -Ru 软件名: 删除软件，同时删除不再被任何软件所需要的依赖pacman -Ssq 关键字: 在仓库中搜索含关键字的软件包，并用简洁方式显示pacman -Qs 关键字: 搜索已安装的软件包pacman -Qi 软件名: 查看某个软件包信息，显示软件简介,构架,依赖,大小等详细信息pacman -Sg: 列出软件仓库上所有的软件包组pacman -Sg 软件包组: 查看某软件包组所包含的所有软件包。pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录pacman -Scc：清理所有的缓存文件" }, { "title": "Spring Boot 配置 Https", "url": "/posts/spring_boot_https/", "categories": "language, java", "tags": "https", "date": "2021-10-09 00:00:00 +0800", "snippet": "开发 Spring Boot 应用时，如果没做特别的配置，默认会启动在 Http 端口上，这里记下如何配置启动在 Https 端口上。1. 自签证书及 Spring Boot Https 配置 在 Spring Initializr 上生成新项目，依赖只选 Spring Web 就够了。 导入项目到 Idea 中，并添加一个 Controller 用于直观的访问验证。 package com.cy.tlsDemo; import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController; @RestControllerpublic class HelloController { @GetMapping(&quot;/&quot;) public String index() { return &quot;Greetings from Spring Boot!&quot;; }} 启动应用，访问：http://localhost:8080/ 确保可以返回正确信息。（注意这里是 http） 生成自签证书，如果已经有了认证过的数字证书可以跳到最后生成 p12 文件那一小步。 生成私钥：openssl genrsa -out private.key 2048，当前目录下会生成一个名为 private.key 的文件 生成请求：openssl req -new -key private.key -out request.csr，当前目录下会生成一个名为 request.csr 的文件，这个文件一般是用来发给 CA 机构进行认证并生成数字证书用的，当然也可以用来生成自签证书 自签名：openssl x509 -req -days 365 -in request.csr -signkey private.key -out root.crt，当前目录下会生成一个名为 root.crt 的数字证书 生成 p12：openssl pkcs12 -export -out cert.p12 -inkey private.key -in root.crt，这里会要求输入密码，如果不想手动输入也可以用 -password pass:xxx 打在命令中 生成自签证书，另一种单命令方式，步骤 4、5 任选一步执行就可以。 生成私钥和自签证书：openssl req -x509 -newkey rsa:4096 -keyout private.key -out root.crt -days 365 -nodes -subj &#39;/CN=localhost&#39;，-nodes 表示不用密码保护私钥，-subj ‘/CN=localhost’ 跳过生成证书的一些问题 生成 p12：同上 添加 Spring Boot 配置。 # p12 文件的路径server.ssl.key-store=cert.p12# pass 是之前生成 p12 时输入的密码server.ssl.key-store-password=passserver.ssl.key-store-type=PKCS12 启动应用，再次访问：http://localhost:8080/ ，发现已经无法正常访问，并提示：This combination of host and port requires TLS，说明配置已经生效。改为访问：https://localhost:8080/ （注意这里是 https）可以返回正常信息。 Spring Boot Https 的配置相当简单，让应用启在 Https 的核心还是在数字证书的生成上。2. 数字证书数字证书是在非对称加密的基础上发展而来，在回顾数字证书前，再澄清公私钥的两个概念： 加密：公钥加密，私钥解密的行为称为加密 签名：私钥加密，公钥解密的行为称为签名数字证书简而言之就是经证书认证机构（CA）认证过的公钥。由证书认证机构（CA）对证书申请者真实身份验证之后，用 CA 的根证书对申请人的一些基本信息以及申请人的公钥进行签名（相当于加盖发证书机构的公章）后形成的一个数字文件。CA 完成签发证书后，会将证书发布在 CA 的证书库（目录服务器）中，任何人都可以查询和下载。数字征书在 Https 中如何发挥作用可以参考这篇文章（https协议说明和自签证书使用）的第一部分，图片和解释都很清楚。 1、客户端请求 Https 地址，隐藏了 TCP 三次握手逻辑 2、3、服务端下发 CA 证书（公钥） 4、客户端通过 CA 认证机构的公钥对服务器传过来的证书验签 最初在 CA 机构对证书进行签名时，其会根据证书里的签名算法字段来决定算法。如算法字段为 SHA256RSA，则 CA 机构就会使用 SHA256 对证书进行摘要，再使用 RSA 算法对摘要使用私钥签名。 对于传来的证书，如果是经 CA 机构认证的证书（非自签），则颁发这个证书的 CA 机构的公钥一般已经预置在操作系统中，浏览器会使用该公钥进行验签（解密）。验签之后得到 CA 机构使用 SHA256 算法生成的证书摘要，然后客户端再使用 SHA256 对证书内容进行一次摘要，如果得到的值和验签之后得到的摘要值相同，则表示证书没有被修改过。 如果验证通过，则显示安全图标；如果不通过，则显示警告和不安全图标。 5、客户端验签成功之后，生成随机的对称秘钥，使用服务器公钥加密对称秘钥发送给服务端 6、7、服务器通过自己的私钥解密密文，得到对称秘钥，加密相关信息传递给客户端 8、客户端拿到服务器传递的信息，解析验证 MAC (Message Authentication Code) 等信息，最终建立加密连接最后是一篇说明各种证书关系及操作的文章：各种安全证书间的关系及相关操作 以文件形式存在的证书一般有这几种格式： 带有私钥的证书（P12）：包含了公钥和私钥的二进制格式的证书形式 二进制编码的证书（DER）：证书中没有私钥，DER 编码二进制格式的证书文件 Base64 编码的证书（PEM）：证书中没有私钥，Base64 编码格式的证书文件 PEM 格式 PEM（Privacy Enhanced Mail），是 OpenSSL 默认采用的信息存放方式，是 CA 颁发证书最常用的格式。包含 -----BEGIN CERTIFICATE----- 和 -----END CERTIFICATE----- 声明。具备诸如 .pem, .crt, .cer, .key 的扩展名。 证书： -----BEGIN CERTIFICATE-----Base64EncodedContent-----END CERTIFICATE----- 私钥： -----BEGIN RSA PRIVATE KEY-----Base64EncodedContent-----END RSA PRIVATE KEY----- 请求： -----BEGIN CERTIFICATE REQUEST-----Base64EncodedContent-----END CERTIFICATE REQUEST----- PFX/PKCS#12 PKCS12（个人数字证书标准）用于存放用户证书、crl、用户私钥以及证书链。PKCS12 中的私钥是加密存放的。扩展名为 .pfx, .p12 的二进制文件。" }, { "title": "可执行 Jar", "url": "/posts/executable_jar/", "categories": "language, java", "tags": "maven, jar", "date": "2021-10-08 00:00:00 +0800", "snippet": "有时候一个 Java 项目最终的成品需要是一个可执行 jar 而不是一个 lib，这就需要借助一些 maven 插件来完成。下面列举一些常用的插件。1. maven-jar-plugin &amp;amp; maven-dependency-plugin&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;archive&amp;gt; &amp;lt;manifest&amp;gt; &amp;lt;addClasspath&amp;gt;true&amp;lt;/addClasspath&amp;gt; &amp;lt;classpathPrefix&amp;gt;libs/&amp;lt;/classpathPrefix&amp;gt; &amp;lt;mainClass&amp;gt;com.cy.App&amp;lt;/mainClass&amp;gt; &amp;lt;/manifest&amp;gt; &amp;lt;/archive&amp;gt; &amp;lt;/configuration&amp;gt;&amp;lt;/plugin&amp;gt;&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;copy-dependencies&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;prepare-package&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;copy-dependencies&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;outputDirectory&amp;gt; ${project.build.directory}/libs &amp;lt;/outputDirectory&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt;&amp;lt;/plugin&amp;gt;maven-jar-plugin 用来指定 jar 的 mainclass 和依赖的 classpath。 addClasspath：是否在 mainfest 文件中添加 classpath classpathPrefix：依赖路径的前缀 mainClass：入口类maven-dependency-plugin 用来将全部或特定依赖复制到对应路径。 outputDirectory：复制的目的路径通过以上配置，执行 mvn package 即可打包好一个可执行 jar，同时也把它依赖的 jar 复制到了指定目录。2. maven-assembly-plugin&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;archive&amp;gt; &amp;lt;manifest&amp;gt; &amp;lt;mainClass&amp;gt;com.cy.App&amp;lt;/mainClass&amp;gt; &amp;lt;/manifest&amp;gt; &amp;lt;/archive&amp;gt; &amp;lt;descriptorRefs&amp;gt; &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt; &amp;lt;/descriptorRefs&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt;&amp;lt;/plugin&amp;gt;maven-assembly-plugin 可以将其依赖的 jar 也一起打包到最终的可执行 jar 中，其最终会在 target 目录下生成两个 jar：xxx.jar 和 xxx-with-dependencies.jar。其中，xxx-with-dependencies.jar 是带有所有依赖的可执行 jar。3. maven-shade-plugin&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;shadedArtifactAttached&amp;gt;true&amp;lt;/shadedArtifactAttached&amp;gt; &amp;lt;transformers&amp;gt; &amp;lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&amp;gt; &amp;lt;mainClass&amp;gt;com.cy.App&amp;lt;/mainClass&amp;gt; &amp;lt;/transformer&amp;gt; &amp;lt;/transformers&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt;&amp;lt;/plugin&amp;gt;maven-shade-plugin 类似 assembly，也是在 target 下生成两个 jar：xxx.jar 和 xxx-shaded.jar，其中 xxx-shaded.jar 是包含所有依赖的可执行 jar。4. spring-boot-maven-plugin&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;classifier&amp;gt;executable&amp;lt;/classifier&amp;gt; &amp;lt;mainClass&amp;gt;com.cy.App&amp;lt;/mainClass&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt;&amp;lt;/plugin&amp;gt;spring-boot-maven-plugin 同样是生成两个 jar：xxx.jar 和 xxx-classifier.jar，classifier 即是 pom 中定义的 executable 或着也能改成其它自定义后缀。spring-boot-maven 由于增加了 spring boot 的一些依赖，相对上边的 assemble 和 shade 插件，最终生成的可执行 jar 会大一点，这个插件一般在 spring boot 项目中使用。5. 区别Difference between maven plugins maven-jar-plugin: This plugin provides the capability to build and sign JARs. But it just compiles the java files under src/main/java and src/main/resources/. It doesn’t include the dependencies JAR files. maven-assembly-plugin: This plugin extracts all dependency JARs into raw classes and groups them together. It can also be used to build an executable JAR by specifying the main class. It works in project with less dependencies only; for large project with many dependencies, it will cause Java class names to conflict. maven-shade-plugin: It packages all dependencies into one uber-JAR. It can also be used to build an executable JAR by specifying the main class. This plugin is particularly useful as it merges content of specific files instead of overwriting them by relocating classes. This is needed when there are resource files that have the same name across the JARs and the plugin tries to package all the resource files together. maven-jar-plugin：只编译 src/main/java 和 src/main/resources 下的文件，不包含依赖。 maven-assembly-plugin：把依赖的 jar 包提取为原始的 class 文件，但对于大项目会有类名冲突的问题。 maven-shade-plugin：解决了类名和资源文件冲突的问题，适用于大型工程。" }, { "title": "H2 Database", "url": "/posts/h2/", "categories": "language, java", "tags": "h2", "date": "2021-09-30 00:00:00 +0800", "snippet": "H2 Database 是一款轻量数据库，当开发中需要进行数据存储，但是又没有必要部署专门的数据存储服务时，h2 就是个很好的选择。H2 具有以下特点： 速度快，开源，JDBC API 嵌入式和服务器模式；内存型数据库 基于浏览器的控制台应用程序 占用空间小：约 2 MB JAR文件大小H2 可以工作在 3 种不同模式下：内存模式、嵌入模式、服务器模式，在使用 Spring Boot 进行开发时，其实只需要修改配置文件就能实现不同模式的切换。0. 生成 Spring Boot 项目首先在 Spring Initializr 上生成一个新的项目，依赖部分添加：Spring Web、Spring Data JPA、H2 Database 即可。然后将下载的 zip 包解压，并在 Idea 中以 maven 工程的方式导入该项目。1. 内存模式内存模式，顾名思义就是数据是存在内存里的，应用重启后数据就没了。这种模式感觉挺废的，本来是想持久化数据的，结果应用关掉后数据也没了。但也有一个好处，可以在启动应用时开启 h2 的控制台，这样就能一边跑一边在控制台里查看数据情况。## Spring Boot 配置文件 application.propertiesspring.datasource.platform=h2spring.datasource.driver-class-name=org.h2.Driver# 开启 h2 控制台spring.h2.console.enabled=true# JDBC Url: 内存模式，h2test 是数据库的名字，可以更改spring.datasource.url=jdbc:h2:mem:h2test# 可选: 用户名/密码spring.datasource.username=xxxspring.datasource.password=xxx在之前生成的项目中添加以上内容后启动应用，浏览器中输入：http://localhost:8080/h2-console，就可以看到 h2 控制台的登陆界面。如果没有配置用户名和密码，可以使用默认的用户名 sa（system admin）和空密码登陆，否则使用配置的用户名/密码。配合 jpa 即可实现数据访问、存储等。添加以下代码启动应用，登陆 h2 控制台可以看到已经创建好的 Car 表单。import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import java.io.Serializable;@Entitypublic class Car implements Serializable { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String brand; private int value; public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } @Override public String toString() { return &quot;Car{&quot; + &quot;id=&quot; + id + &quot;, brand=&#39;&quot; + brand + &#39;\\&#39;&#39; + &quot;, value=&quot; + value + &#39;}&#39;; }}2. 嵌入模式嵌入模式是将数据存储到文件的模式，它跟内存模式配置上的差异只是 JDBC Url。另外，嵌入模式下表单未用到时不会主动创建，可以对 ddl-auto 配置实现更改。# JDBC Url: 嵌入模式，your_path 是数据文件的存放路径spring.datasource.url=jdbc:h2:file:your_pathspring.jpa.hibernate.ddl-auto = create通过以上配置，数据文件会在应用启动时自动创建，若数据文件已经创建过了，则应用会直接使用。3. 服务器模式服务器模式类似使用 MySQL 等数据库的方式，h2 服务提前在本地或远端启动，应用启动时去连接 h2 服务。# JDBC Url: 服务器模式，your_path 是数据文件的存放路径spring.datasource.url=jdbc:h2:tcp://localhost/your_pathspring.jpa.hibernate.ddl-auto = create启动 h2 服务官网提供了命令：Using the Server# 默认启动java -cp h2*.jar org.h2.tools.Server# 查看帮助java -cp h2*.jar org.h2.tools.Server -?# 实际使用：-webAllowOthers 允许其它计算机通过网页连接；-tcpAllowOthers 允许其它计算机通过 tcp 连接；-ifNotExists 如果表单不存在允许创建java -cp h2*.jar org.h2.tools.Server -webAllowOthers -tcpAllowOthers -ifNotExists以上就是 h2 数据库的一个简单配置记录，方便快捷，做个人的微开发足够了。" }, { "title": "Mac 重装", "url": "/posts/mac_setup/", "categories": "tool", "tags": "mac", "date": "2021-09-09 00:00:00 +0800", "snippet": "最近 Mac 格掉重装了，记录下装机后个人习惯的配置步骤。1. 触控板调整 三指查询 轻拍单击 滑动方向 更多手式全选 三指拖动（Accessibility -&amp;gt; Pointer Control -&amp;gt; Mouse &amp;amp; Trackpad -&amp;gt; Trackpad Options）2. 键盘 使用键盘切换焦点：Keyboard -&amp;gt; ShortCuts -&amp;gt; Use keyboard navigat …3. 输入法配置 Menubar 不显示输入法 使用 中/英 切换输入法 自动切换为文档输入源4. 头像、壁纸、LaunchPad、Widgets调整5. Menubar 电池显示百分比 时钟显示秒 不显示 Spotlight6. Dock 自动隐藏 增加显示 Desktop、Documents 移除不需要的 App7. Finder 新窗口显示 home 边栏不显示最近项目，显示 home 高级：显示后缀 显示选项：show item info, icon size 100x100, use as default 显示：path bar，status bar8. Touch Bar Siri 换为输入法9. Safari 搜索引擎更改 固定常用 tab9. 安装软件 lemon command line tools（xcode-select –install） homebrew（清华镜像站：https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/） fish vimrc（vim 配置） rectangle、the-unarchiver、typora raspberry-pi-imager、virtualbox（或者 vmware-fusion）、virtualbox-extension-pack、iina、thunder、libreoffice 虚拟机系统11. ssh 本地公私钥生成 远端服务器配置" }, { "title": "LaTeX 用 Vim 记笔记", "url": "/posts/latex_vim/", "categories": "language, latex", "tags": "latex", "date": "2021-09-03 00:00:00 +0800", "snippet": "之前摘录了一系列 LaTeX 的笔记，主要目的是想重温微积分并好好记录下笔记，不想把多年前的知识丢了。这里有两篇比利时鲁汶大学学生写的文章，讲述如何用 vim 快速记录数学笔记以及绘图：How I’m able to take notes in mathematics lectures using LaTeX and Vim、How I draw figures for my mathematical lecture notes using Inkscape，其中第二篇综合利用了 python 脚本、开源软件、vim 配置，是典型的利用计算机技术解决问题和提高效率的案例，这种处理问题的思路非常值得学习。上边第一篇文章的中文版：在数学课上用 LaTeX + Vim 运笔如飞地做笔记。速记数学笔记速记主要是采用了两个插件：vimtex、ultisnips，vimtex 用来将 latex 语法高亮，ultisnips 用来提供代码片断。vimtexvimtex 不仅可以高亮代码，同时还可以对一些符号进行隐藏和替换，譬如，隐藏公式符号 \\[ \\] $、替换 \\bigcup 为 ∩ 等，以给予用户较好的编写体验。下边是简单的配置项：Plugin &#39;lervag/vimtex&#39;let g:tex_flavor=&#39;latex&#39;let g:vimtex_view_method=&#39;zathura&#39;let g:vimtex_quickfix_mode=0# 设置隐藏内容set conceallevel=1let g:tex_conceal=&#39;abdmg&#39;它还支持一些简单命令：\\ll 编译文件，\\lc 清理辅助文件等。在写中文时，要注意调整引擎为 xelatex，否则不能完成编译：%! TEX program = pdflatex%! TEX program = xelatex更多的帮助文档参考：the documentation，或者在 vim 中使用帮助：:h vimtex。ultisnipsultisnips 号称是 vim 下的终级片断解决方案，其安装需要 vim 支持 python3，是否支持可以用：vim --version 查看。ultisnips 本身不提供代码片断，因此需要结合其它提供片断的插件（honza/vim-snippets）一起使用，快速的配置如下：Plugin &#39;SirVer/ultisnips&#39;Plugin &#39;honza/vim-snippets&#39;let g:UltiSnipsExpandTrigger=&quot;&amp;lt;tab&amp;gt;&quot;let g:UltiSnipsJumpForwardTrigger=&quot;&amp;lt;tab&amp;gt;&quot;let g:UltiSnipsJumpBackwardTrigger=&quot;&amp;lt;s-tab&amp;gt;&quot;如果是出于通用目的使用 ultisnips，以上配置就够了，但有时候想自定义片断，那就需要遵循一定的语法，其基本形式如下：snippet KEYWORD &quot;some description&quot; &amp;lt;options&amp;gt;[snippet body...]endsnippet三个条件 KEYWORD + options + UltiSnipsExpandTrigger，一起决定了片断的展开。UltiSnipsExpandTrigger 不用多说，是触发片断展开的按键，按个人喜好设定就可以。KEYWORD 则表示片断的名字，键入片断名，插件将其替换为片断体。options 是片断的触发选项： b，行首触发 i，词中展开 w，单词边界 A，自动展开 …snippet body 中也有很多功能点： 普通文本替换 snippet sign &quot;Signature&quot;Yours sincerely, Gilles Castelendsnippet 执行命令，`` snippet today &quot;Date&quot;`date +%F`endsnippet 使用 python 语法，`!p…` snippet box &quot;Box&quot;`!p snip.rv = &#39;┌&#39; + &#39;─&#39; * (len(t[1]) + 2) + &#39;┐&#39;`│ $1 │`!p snip.rv = &#39;└&#39; + &#39;─&#39; * (len(t[1]) + 2) + &#39;┘&#39;`$0endsnippet 占位符，$1、$2 … $0 snippet beg &quot;begin{} / end{}&quot; bA\\begin{$1} $0\\end{$1}endsnippet 关于片断文件存放的位置默认在：~/.vim/UltiSnips/，通过配置全局变量进行调整：## 默认位置let g:UltiSnipsSnippetDirectories=[&quot;UltiSnips&quot;]## 增加自定义位置let g:UltiSnipsSnippetDirectories=[&quot;UltiSnips&quot;, &quot;mycoolsnippets&quot;]最后附上一这位学生的 latex 片断：tex.snippets。快速绘图绘图这篇文章主要是想提下文中用到的一款开源矢量图绘制软件：Inkscape，三大平台都有，它能够生成 latex 文件，方便在 vim + latex 场景下使用。" }, { "title": "LaTeX 自定义命令", "url": "/posts/latex_self_define/", "categories": "language, latex", "tags": "latex", "date": "2021-09-02 00:00:00 +0800", "snippet": "[toc]本章介绍如何制作一个简单但像样的毕业论文/书籍/简历模板，每次可以直接套用，而不是再在导言区写一堆代码。一、自定义命令和环境定义新命令自定义命令：\\newcommand{\\⟨name⟩}[⟨num⟩]{⟨definition⟩}。⟨name⟩ 是要定义的命令名称（带反斜线），⟨definition⟩ 是命令的具体定义。参数 ⟨num⟩ 是可选的，用于指定新命令所需的参数数目（最多 9 个，默认为 0）。不带参数的示例：\\newcommand{\\tnss}{The not so Short Introduction to \\LaTeXe}% in document:This is ``\\tnss&#39;&#39; \\ldots{} ``\\tnss&#39;&#39;带参数的示例：\\newcommand{\\txsit}[1]{This is the \\emph{#1} Short Introduction to \\LaTeXe}% in document:\\begin{itemize}\\item \\txsit{not so}\\item \\txsit{very}\\end{itemize}LaTeX 不允许使用 \\newcommand 定义一个与现有命令重名的命令，如有需要可以使用以下方式： \\renewcommand，修改已有命令定义 \\providecommand，命令末定义时相当于 newcommand，命令已定义时沿用已有的定义定义新环境自定义环境：\\newenvironment{⟨name⟩}[⟨num⟩]{⟨before⟩}{⟨after⟩}。⟨name⟩ 是要定义的环境名称，⟨before⟩ 中的内容将在此环境包含的文本之前处理，⟨after⟩ 中的内容将在遇到 \\end{⟨name⟩} 命令时处理。参数 ⟨num⟩ 是可选的，用法与 \\newcommand 一样。\\newenvironment{king}{\\rule{1ex}{1ex} \\hspace{\\stretch{1}}}{\\hspace{\\stretch{1}} \\rule{1ex}{1ex}}\\begin{king}My humble subjects \\ldots\\end{king}如果需要改变一个现有环境，可以使用 \\renewenvironment，语法与 \\newenvironment 一致。二、自定义宏包和文档类简单宏包当有很多自定义命令和环境时，文档的导言区将变得很长，这时可以建立一个新的 LaTeX 宏包来存放所有自定义的命令和环境，然后在文档中使用\\usepackage 命令来调用自定义的宏包。% Demo Package\\ProvidesPackage{demopack}\\newcommand{\\tnss}{The not so Short Introduction to \\LaTeXe}\\newcommand{\\txsit}[1]{The \\emph{#1} Short Introduction to \\LaTeXe}\\newenvironment{king}{\\begin{quote}}{\\end{quote}}宏包可以理解为：以 .sty 为后缀的文本文件，其内容包含了宏包专用命令 \\ProvidesPackage{⟨package name⟩} 和 自定义命令、环境。需要注意的是：⟨package name⟩ 要和宏包的文件名一致。如果想进一步把各种宏包的功能汇总到一个文件里，而不是在文档的导言区罗列一大堆宏包，可以使用命令 \\RequirePackage，用法与\\usepackage 一致：\\RequirePackage[⟨options⟩]{⟨package name⟩}。文档类编写自定义文档类，如论文模板等会稍麻烦一些。 首先，文档类应以 .cls 作扩展名，开头使用 \\ProvidesClass 命令：\\ProvidesClass{⟨class name⟩}，{⟨class name⟩} 需要和文档类的文件名一致 其次，需要通过 \\LoadClass 命令调用一个基本文当类：\\LoadClass[⟨options⟩]{⟨package name⟩} 或者，不调用基本文档类，而是自己实现诸如 \\chapter、\\section 等命令三、计数器LaTeX 对文档元素自动计数的能力：章节符号、列表、图表，都是依靠计数器功能完成的。定义和修改计数器定义一个计数器的方法：\\newcounter{⟨counter name⟩}[⟨parent counter name⟩]。⟨counter name⟩ 为计数器的名称。计数器可以有上下级的关系，可选参数 ⟨parent countername⟩ 定义为 ⟨counter name⟩ 的上级计数器。以下命令修改计数器的数值： \\setcounter 将数值设为 ⟨number⟩ \\addtocounter 将数值加上 ⟨number⟩ \\stepcounter 将数值加 1，并将所有下级计数器归零\\setcounter{⟨counter name⟩}{⟨number⟩}\\addtocounter{⟨counter name⟩}{⟨number⟩}\\stepcounter{⟨counter name⟩}输出格式计数器 ⟨counter⟩ 的输出格式由 \\the⟨counter⟩ 表示，如 \\thechapter。计数器值默认以阿拉伯数字形式输出，如果想改成其它形式，需要重定义 \\the⟨counter⟩，如将 equation 计数器的格式定义为大写字母：\\renewcommand\\theequation{\\Alph{equation}}命令 \\Alph 控制计数器 ⟨counter⟩ 的值以大写字母形式显示。下表列出所有可用于修改计数器格式的命令。注意：这些命令只能用于计数器，不能直接用于数字，如 \\roman{1} 这样的命令会出错。 命令 样式 范围 \\arabic 阿拉伯数字（默认）   \\alph 小写字母 限 0–26 \\Alph 大写字母 限 0–26 \\roman 小写罗马数字 限非负整数 \\Roman 大写罗马数字 限非负整数 \\fnsymbol 一系列符号，用于 \\thanks 命令生成的脚注 限 0–9 注：\\fnsymbol 使用的符号顺次为：∗ † ‡ § ¶ ‖ ∗∗ †† ‡‡计数器可以组合，如标准文档类里对 \\subsection 相关的计数器的输出格式的定义相当于：\\renewcommand\\thesubsection{\\thesection.\\arabic{subsection}}已有计数器 所有章节命令 \\chapter、\\section 等分别对应计数器 chapter、section 等等，且有上下级的关系。part 为独立计数器。 有序列表 enumerate 的各级计数器为 enumi, enumii, enumiii, enumiv，也有上下级的关系。 图表浮动体的计数器就是 table 和 figure；公式的计数器为 equation。这些计数器在 article 文档类中是独立的，而在 book 和 report 中以 chapter 为上级计数器。 页码、脚注的计数器分别是 page 和 footnote。示例，把页码修改成大写罗马字母，左右加横线，或是给脚注加上方括号：\\renewcommand\\thepage{--~\\Roman{page}~--}\\renewcommand\\thefootnote{[\\arabic{footnote}]}两个跟章节编号有关的计数器： secnumdepth 标准文档类对章节划分了层级： 在 article 文档类里 part 为 0，section 为 1，依此类推； 在 report/book 文档类里 part 为 -1，chapter 为 0，section 为 1，等等。 secnumdepth 计数器控制章节编号的深度，如果章节的层级大于secnumdepth，那么章节的标题在目录和页眉页脚的标题都不编号（照常生成目录和页眉页脚），章节计数器也不计数。 可以用 \\setcounter 命令设置 secnumdepth 为较大的数使得层级比较深的章节也编号，如设置为 4 令 \\paragraph 也编号；或者设置一个较小的数以取消编号，如设置为 -1 令 \\chapter 不编号，免去了手动使用 \\addcontentsline 和 \\mark-both 的麻烦。 secnumdepth 计数器在 article 文档类里默认为 3（subsubsection 一级）；在 report 和 book 文档类里默认为 2（subsection 一级）。 tocdepth tocdepth 计数器控制目录的深度，如果章节的层级大于 tocdepth，那么章节将不会自动写入目录项。默认值同 secnumdepth。 四、可定制项LaTeX 有一些比较容易定制的内容：标题名称、前后辍，长度。 标题名称/前后缀等，可以用 \\renewcommand 来修改 命令 默认值 含义 \\partname Part \\part 命令生成的标题前缀 \\chaptername Chapter \\chapter 命令生成的标题前缀 \\appendixname Appendix 使用 \\appendix 命令生成的附录部分的章标题前缀 \\abstractname Abstract 摘要环境 abstract 的标题名称 \\contentsname Contents \\tableofcontents 命令生成的目录标题 \\listfigurename List of Figures \\listoffigures 命令生成的插图目录标题 \\listtablename List of Tables \\listoftables 命令生成的表格目录标题 \\tablename Table table 浮动体中 \\caption 命令生成的标题前缀 \\figurename Figure figure 浮动体中 \\caption 命令生成的标题前缀 \\refname References thebibliography 环境或 \\bibliography 命令生成的参考文献标题（article 文档类） \\bibname Bibliography thebibliography 环境或 \\bibliography 命令生成的参考文献标题（book / report 文档类） \\indexname Index \\printindex 命令生成的索引标题 长度，可用 \\setlength 来修改 命令 默认值 含义 \\fboxrule 0.4pt \\fbox 或 \\framebox 等带框盒子的线宽 \\fboxsep 3pt \\fbox 或 \\framebox 等带框盒子的内边距 \\arraycolsep 5pt array 环境的表格项前后的间距 \\tabcolsep 6pt tabular 环境的表格项前后的间距 \\arrayrulewidth 0.4pt 表格线宽 \\doublerulesep 2pt 连续两根表格线之间的间距 \\abovecaptionskip 10pt \\caption 命令位于图表下方时，与上方图表的间距 \\belowcaptionskip 0pt \\caption 命令位于图表上方时，与下方图表的间距 \\columnsep 10pt 双栏排版下两栏的间距 \\columnseprule 0pt 双栏排版下两栏之间竖线的宽度 " }, { "title": "五笔要点记录", "url": "/posts/wubi/", "categories": "other", "tags": "", "date": "2021-08-31 00:00:00 +0800", "snippet": "最近感觉越来越不会提笔写字了，就决定重新学习五笔，准备后续都用五笔来写汉字，一来是想回归用笔写字的模式；二来也想体验下五笔的速度。这里是两篇速成攻略：五笔7天速成（86版），7天学会新世纪五笔（新世纪版）。86 与新世纪两个版本的区别在于：字根、拆字，新世纪的字根更简单，拆字也更合理，下边分别是两个版本的字根表图。五笔单字的书写逻辑很简单，从程序员的角度来看就是几个 if…else。新世纪五笔字根实例，通过参考字根实例可以快速了解字根在一个字里代表的部分。新世纪五笔的安装 Mac ​ Big Sur 自带了，直接在输入源增加五笔输入法，并配置版本为新世纪。 Linux ​ 中州韵，非常优秀的输入法，官网地址：Rime。 ​ 中州韵本身并不带五笔输入方案，还需要自已手动安装方案集后才能使用，新世纪五笔输入方案集。 Windows ​ Win10 带了 86 版的五笔，如果需要使用新世纪版本，也是推荐安装 Rime。 " }, { "title": "LaTeX 绘图", "url": "/posts/latex_tikz/", "categories": "language, latex", "tags": "latex", "date": "2021-08-31 00:00:00 +0800", "snippet": "[toc]除了排版文字，LaTeX 也支持用代码表示图形。不同的扩展已经极大地丰富了 LaTeX 的图形功能，TikZ 就是其中之一。本章将了解一些基本的绘图功能。一些特殊的绘图，如交换图、树状图甚至分子式和电路图也能够通过代码绘制，但较为复杂。一、绘图语言简介LaTeX 提供了原始的 picture 环境，能够绘制一些基本的图形如点、线、矩形、圆、Bézier 曲线等等，不过受制于 LaTeX 本身，它的绘图功能极为有限，效果也不够美观。当前较为流行的、用于 LaTeX 的绘图宏包 / 程序主要有： PSTricks 以 PostSciprt 语法为基础的绘图宏包，具有优秀的绘图能力。它对老式的 latex + dvips 编译命令支持最好，而现在的几种编译命令下使用起来都不够方便。 TikZ &amp;amp; pgf 德国的 Till Tantau 教授在开发著名的 LaTeX 幻灯片文档类 beamer 时一并开发了绘图宏包 pgf，目的是令其能够在 pdflatex 或 xelatex 等不同的编译命令下都能使用。TikZ 是在 pgf 基础上封装的一个宏包，采用了类似 METAPOST 的语法，提供了方便的绘图命令，绘图能力不输 PSTricks。 METAPOST&amp;amp; Asymptote METAPOST 脱胎于高德纳为 TEX 配套开发的字体生成程序 METAFONT，具有优秀的绘图能力，并能够调用 TEX 引擎向图片中插入文字和公式。Asymptote 在 METAPOST的基础上更进一步，具有一定的类似 C 语言的编程能力，支持三维图形的绘制。 二、TikZ 绘图在导言区调用 tikz 宏包，就可以用以下命令和环境使用 TikZ 的绘图功能：\\tikz[...] ⟨tikz code⟩;\\tikz[...] {⟨tikz code 1⟩; ⟨tikz code 2⟩; ...}\\begin{tikzpicture}[...]⟨tikz code 1⟩;⟨tikz code 2⟩;...\\end{tikzpicture}前一种用法为 \\tikz 带单条绘图命令，以分号结束，一般用于在文字之间插入简单的图形；后两种用法较为常见，使用多条绘图命令，可以在 figure 等浮动体中使用。TikZ 坐标和路径TikZ 用直角坐标系或者极坐标系描述点的位置。 直角坐标下，点的位置写作 (⟨x⟩,⟨y⟩)，坐标 ⟨x⟩ 和 ⟨y⟩ 可以用 LaTeX 支持的任意单位表示，缺省为 cm； 极坐标下，点的位置写作 (⟨θ⟩:⟨r⟩)，θ 为极角，单位是度。还可以为某个点命名：\\coordinate (A) at (⟨coordinate⟩) 然后就可以使用 (A) 作为点的位置了。\\begin{tikzpicture}\\draw (0,0) -- (30:1);\\draw (1,0) -- (2,1);\\coordinate (S) at (0,1);\\draw (S) -- (1,1);\\end{tikzpicture}垂足形式：\\begin{tikzpicture}\\coordinate (S) at (2,2);\\draw[gray] (-1,2) -- (S);\\draw[gray] (2,-1) -- (S);\\draw[red] (0,0) -- (0,0 -| S);\\draw[blue] (0,0) -- (0,0 |- S);\\end{tikzpicture}最基本的路径为两点之间连线，如 (⟨x1⟩,⟨y1⟩) – (⟨x2⟩,⟨y2⟩)，可以连用表示多个连线（折线）。连续使用连线时，可以使用 cycle 令路径回到起点，生成闭合的路径：\\begin{tikzpicture}\\draw (0,0) -- (1,1) -- (2,0) -- cycle;\\end{tikzpicture}多条路径可用于同一条画图命令中，以空格分隔：\\begin{tikzpicture}\\draw (0,0) -- (0,1) (1,0) -- (1,1) -- (2,0) -- cycle;\\end{tikzpicture}其它常用图形如下： 矩形、圆和椭圆 \\begin{tikzpicture}\\draw (0,0) rectangle (1.5,1);\\draw (2.5,0.5) circle [radius=0.5];\\draw (4.5,0.5) ellipse [x radius=1,y radius=0.5];\\end{tikzpicture} 直角、圆弧、椭圆弧 \\begin{tikzpicture}\\draw (0,0) |- (1,1);\\draw (1,0) -| (2,1);\\draw (4,0) arc (0:135:1);\\draw (6,0) arc (0:135:1 and 0.5);\\end{tikzpicture} 正弦、余弦曲线（1/4 周期） \\begin{tikzpicture}\\draw (0,0) sin (1,1);\\draw (0,1) sin (1,0);\\draw (2,1) cos (3,0);\\draw (2,0) cos (3,1);\\end{tikzpicture} 抛物线，用 bend 控制顶点 \\begin{tikzpicture}\\draw (0,0) parabola (1,2);\\draw (2,0) parabola bend (2.25,-0.25) (3,2);\\draw (4,0) parabola bend (4.75,2.25) (5,2);\\end{tikzpicture} 二次和三次 Bézier 曲线，分别使用一个和两个控制点 \\begin{tikzpicture}\\draw (0,0) .. controls (2,1) and (3,1) .. (3,0);\\draw (4,0) .. controls (5,1) .. (5,0);\\draw[help lines] (0,0) -- (2,1) -- (3,1) -- (3,0) (4,0) -- (5,1) -- (5,0);\\end{tikzpicture} 网格、函数图像，网格可用 step 参数控制网格大小，函数图像用 domain 参数控制定义域 \\begin{tikzpicture}\\draw[help lines,step=0.5] (-1,-1) grid (1,1);\\draw[-&amp;gt;] (-1.5,0) -- (1.5,0);\\draw[-&amp;gt;] (0,-1.5) -- (0,1.5);\\draw[domain=-1:1] plot(\\x,{\\x*\\x*2 -1});\\end{tikzpicture} TikZ 绘图命令和参数TikZ 提供了 \\fill 命令用来填充图形，\\filldraw 命令则同时填充和描边。除了矩形、圆等现成的闭合图形外，\\fill 和 \\filldraw 命令也能够填充人为构造的闭合路径。\\draw[...] ⟨path⟩;\\fill[...] ⟨path⟩;\\filldraw[...] ⟨path⟩;绘图参数可作为可选参数用在 tikzpiture 环境或 \\tikz 命令时，参数会影响到所有具体的绘图命令；用在单个绘图命令 \\draw、\\filldraw 等时，只对这个命令起效。TikZ 有数不清的绘图参数，这些参数令 TikZ 能够绘制丰富多彩的图像，同时也令 TikZ 难以精通。以下示例常用的一些绘图参数。 color/draw/fill=⟨color⟩ 为 \\draw 或 \\fill 等命令指定颜色。draw 和 fill 分别指定描边和填充的颜色，而 color 同时指定，可以省略 color= 直接写颜色名称 \\begin{tikzpicture}[thick]\\draw[blue] (0,0) rectangle (1,1);\\fill[green] (2,0) rectangle (3,1);\\filldraw[fill=yellow,draw=red] (4,0.5) circle [radius=0.5];\\end{tikzpicture} thick=⟨length⟩/thin/semithick/… 指定线条的粗细 \\begin{tikzpicture}\\draw[ultra thin] (0,0)--(0,2);\\draw[very thin] (0.5,0)--(0.5,2);\\draw[thin] (1,0)--(1,2);\\draw[semithick] (1.5,0)--(1.5,2);\\draw[thick] (2,0)--(2,2);\\draw[very thick] (2.5,0)--(2.5,2);\\draw[ultra thick] (3,0)--(3,2);\\end{tikzpicture} solid/dashed/dotted/dash dot/dash dot dot 指定线条类型（实线、虚线、点划线等）。与 dashed 对应地有 densely dashed 和 loosely dashed，后三种类型同理。 \\begin{tikzpicture}\\draw[dashed] (0,0) -- (0,2);\\draw[dotted] (0.5,0) -- (0.5,2);\\draw[dash dot] (1,0) -- (1,2);\\draw[dash dot dot] (1.5,0) -- (1.5,2);\\draw[densely dotted] (2,0) -- (3,2) -- (4,0) -- cycle;\\end{tikzpicture} ⟨arrow⟩-⟨arrow⟩ 指定线条首尾的箭头形式。复杂的箭头形式需要在导言区使用 \\usetikz-library {arrows.meta} \\begin{tikzpicture}[thick]\\draw[-&amp;gt;] (0,4) -- (3,4);\\draw[-&amp;gt;&amp;gt;] (0,3.5) -- (3,3.5);\\draw[-&amp;gt;|] (0,3) -- (3,3);\\draw[&amp;lt;-] (0,2.5) -- (3,2.5);\\draw[&amp;lt;-&amp;gt;] (0,2) -- (3,2);\\draw[&amp;gt;-&amp;gt;|] (0,1.5) -- (3,1.5);\\draw[-stealth] (0,1) -- (3,1);\\draw[-latex] (0,0.5) -- (3,0.5);\\draw[-to] (0,0) -- (3,0);\\end{tikzpicture} rounded corners[=⟨radius⟩]/sharp corners 将路径转向处绘制成圆角/直角。可选参数 ⟨radius⟩ 控制圆角的半径，可以对某一段路径直接使用 \\begin{tikzpicture}\\draw[rounded corners] (0,0) rectangle (1,1);\\draw (2,0) -- (2,1) [rounded corners=.3cm] -- (3,1) -- (3.5,0) [sharp corners] -- cycle;\\end{tikzpicture} scale/xshift/yshift/xslant/yslant/rotate 设定图形的缩放、位移和旋转 \\begin{tikzpicture}\\draw[help lines](0,0) rectangle (1,1);\\draw[scale=1.5] (0,0) rectangle (1,1);\\draw[rotate=30] (0,0) rectangle (1,1);\\draw[help lines](2,0) rectangle (3,1);\\draw[yshift=4pt](2,0) rectangle (3,1);\\draw[help lines](4,0) rectangle (5,1);\\draw[xslant=0.4](4,0) rectangle (5,1);\\end{tikzpicture} 为了重复利用绘图参数，减少代码冗余，TikZ 引入了“样式”的概念，可以定义一个样式包含绘图参数，然后将样式作为一个参数用于绘图：\\begin{tikzpicture}[myarrow/.style={blue,thick,-&amp;gt;}]\\draw (0,0)--(0,1)--(2,1);\\draw[myarrow] (0,0)--(2,1);\\draw[myarrow,dotted] (0,0)--(2,0)--(2,1);\\end{tikzpicture}以及提供了 scope 环境，令绘图参数或样式在局部生效：\\begin{tikzpicture}\\draw (0,0) rectangle (2.5, 2.5);\\begin{scope}[thick,scale=0.5]\\draw (0,0) rectangle (2.5, 2.5);\\end{scope}\\end{tikzpicture}TikZ 文字结点TikZ 用 \\node 命令绘制文字结点：\\node[⟨options⟩] (⟨name⟩) at (⟨coordinate⟩) {⟨text⟩};。(⟨name⟩) 为结点命名，类似 \\coordinate；at (⟨coordinate⟩) 指定结点的位置。这两者和前面的 ⟨options⟩ 都可以省略，只有 ⟨text⟩ 是必填的。\\begin{tikzpicture}\\node (A) at (0,0) {A};\\node (B) at (1,0) {B};\\node (C) at (60:1) {C};\\draw (A) -- (B) -- (C) -- (A);\\end{tikzpicture}”TikZ 绘图命令和参数“中的参数可用于 \\node 命令。除此之外，\\node 还有一些特定的参数： anchor=⟨position⟩ 令结点的某个角落 ⟨position⟩ 与 ⟨coordinate⟩ 对应 centered / above / below / left / right / above left / … [=⟨length⟩] 与 anchor 等效的选项，可选的 ⟨length⟩ 为节点相对于 ⟨coordinate⟩ 的距离 \\begin{tikzpicture}\\coordinate (A) at (1,1);\\fill (A) circle[radius=2pt];\\node[draw,anchor=south] at (A) {a};\\node[draw,below right=4pt] at (A) {b};\\end{tikzpicture} shape=⟨shape⟩ 结点的形状，默认可用 rectangle 和 circle，可省略 shape= 直接写。在导言区使用命令 \\usetikzlibrary{shapes.geometric} 可用更多的形状 text=⟨color⟩ 结点文字的颜色 node font=⟨font command⟩ 结点文字的字体，形如 \\bfseries 或 \\itshape 等 \\begin{tikzpicture}\\node[circle,fill=blue,text=white,node font={\\bfseries}] (A) at (0,0) {A node};\\node[rectangle,rounded corners,draw=gray,node font={\\sffamily\\slshape}] (B) at (2,0) {B node};\\end{tikzpicture} inner sep=⟨length⟩ / outer sep=⟨length⟩ 结点边界向外和向内的额外距离 minimum size=⟨length⟩ / minimum height=⟨length⟩ / minimum width=⟨length⟩ 结点的最小大小或最小高度/宽度 \\node 命令不仅为文字结点的位置命名，在 \\draw 等命令中还可以使用某个结点的相对位置，以“东南西北”（east/south/west/north）的方式命名：\\begin{tikzpicture}\\draw (0,0) circle[radius=1];\\fill (0,0) circle[radius=2pt];\\node[draw] (P) at (15:2) {center};\\draw[dotted] (0,0) -- (P.west);\\end{tikzpicture}\\node 命令的一种等效用法是在 \\draw 等命令的路径中使用 node，不仅可以对某个位置标记节点，还能够对线标记： \\begin{tikzpicture} \\draw (2,1.5) node[above] {$A$} -- node[above left] {$c$} (0,0) node[left] {$B$} -- node[below] {$a$} (2.5,0) node[right] {$C$} -- node[above right] {$b$} cycle; \\end{tikzpicture}下面是一个较为复杂的例子，综合前面介绍过的各种路径、形状、文字结点和参数设置，结果挺漂亮的：\\begin{tikzpicture}\\draw[-stealth,line width=0.2pt] (-0.5,0) -- (4.5,0);\\draw[-stealth,line width=0.2pt] (0,-0.5) -- (0,2.5);\\coordinate (a) at (0.5,1.9);\\coordinate (b) at (4,1.2);\\node[below] (a0) at (a |- 0,0) {$a$};\\node[below] (b0) at (b |- 0,0) {$b$};\\filldraw[fill=gray!20,draw,thick] (a0) -- (a) .. controls (1,2.8) and (2.7,0.4) .. (b) -- (b0) -- cycle;\\node[above right,outer sep=0.2cm,rounded corners,fill=green!20,draw=gray,text=blue!60!black,scale=0.6]at (b) {$\\displaystyle \\int_a^b {f(x)\\,\\mathrm{d}x} = F(b) - F(a)$};\\end{tikzpicture}在 TikZ 中使用循环TikZ 通过 pgffor 功能宏包实现了简单的循环功能，语法为：\\foreach \\a in {⟨list⟩} {⟨commands⟩}。\\a 为变量，在 {⟨commands⟩} 中使用 \\a 完成循环。⟨list⟩ 可以直接将所有值写出来，如 1,2,3,4；也可以写成省略形式，如 1,2,…,10。\\begin{tikzpicture}\\draw (0,0)--(5,0);\\foreach \\i in {0.0,0.1,...,5.0}{\\draw[very thin] (\\i,0)--(\\i,0.15);}\\foreach \\I in {0,1,2,3,4,5}{\\draw (\\I,0)--(\\I,0.25) node[above] {\\I};}\\end{tikzpicture}变量 pair 循环：\\begin{tikzpicture}\\foreach \\n/\\t in {0/\\alpha,1/\\beta,2/\\gamma}{\\node[circle,fill=lightgray,draw] at (\\n,0) {$\\t$};}\\end{tikzpicture}" }, { "title": "LaTex 特色工具和功能", "url": "/posts/latex_tool/", "categories": "language, latex", "tags": "latex", "date": "2021-08-30 00:00:00 +0800", "snippet": "[toc]BIBTEX 和 makeindex 依靠一些辅助程序自动生成参考文献、索引等；颜色、超链接等则可以生成美观易用的电子文档。一、参考文献基本的参考文献和使用LaTeX 提供的参考文献和引用方式比较原始，需要用户自行书写参考文献列表（包括格式），较难直接使用。\\cite 命令用于在正文中引用参考文献：\\cite[additional content]{⟨citation⟩}。⟨citation⟩ 为引用的参考文献的标签，类似 \\ref 里的参数；\\cite 带一个可选参数，为引用的编号后加上额外的内容，如 \\cite[page 22]{Paper2013}。参考文献由 thebibliography 环境包裹。每条参考文献由 \\bibitem 开头，其后是参考文献本身的内容：\\begin{thebibliography}{⟨widest label⟩} \\bibitem[⟨item number⟩]{⟨citation⟩} ...\\end{thebibliography}⟨citation⟩ 是 \\cite 使用的文献标签，⟨item number⟩ 自定义参考文献的序号，如果省略则按自然排序给定序号。⟨widest label⟩ 用以限制参考文献序号的宽度，如 99 意味着不超过两位数字，通常设定为与参考文献的数目一致。thebibliography 环境自动生成不带编号的一节（article 文档类）或一章（report / book 文档类）。在 article 文档类的节标题默认为 “Reference”，而在 report / book 文档类的章标题默认为 “Bibliography”。\\documentclass{article}\\begin{document}\\section{Introduction}Partl~\\cite{germenTeX} has proposed that \\ldots\\begin{thebibliography}{99}\\bibitem{germenTeX} H.~Partl: \\emph{German \\TeX},TUGboat Volume~9, Issue~1 (1988)\\end{thebibliography}\\end{document}BibTeX 数据库和样式BibTeX 是最流行的参考文献数据组织格式之一，使用 BibTeX 数据库可以让我们摆脱手写参考文献条目的麻烦。同时，通过参考文献样式的支持，还可以让同一份 BibTeX 数据库生成不同样式的参考文献列表。BibTeX 数据库以 .bib 作为扩展名，其内容是若干个文献条目，每个条目的格式为：@⟨type⟩{⟨citation⟩, ⟨key1⟩ = {⟨value1⟩}, ⟨key2⟩ = {⟨value2⟩}, ...}⟨type⟩ 为文献的类别，如 article 为学术论文，book 为书籍，incollection 为论文集中的某一篇，等等。⟨citation⟩ 为 \\cite 命令使用的文献标签。在 ⟨citation⟩ 之后为条目里的各个字段，以 ⟨key⟩ = {⟨value⟩} 的形式组织。简单列举学术论文里使用较多的 BibTeX 文献条目类别如下： article 学术论文，必需字段有 author, title, journal, year；可选字段包括 volume, number, pages, doi 等 book 书籍，必需字段有 author/editor, title, publisher, year；可选字段包括 volume/number, series, address 等 incollection 论文集中的一篇，必需字段有 author, title, booktitle, publisher, year；可选字段包括 editor, volume/number, chapter, pages, address 等 inbook 书中的一章，必需字段有 author/editor, title, chapter/pages, publisher, year；可选字段包括 volume/number, series, address 等例如 article 类别的参考文献数据条目写法如下：@article{Alice13, title = {Demostration of bibliography items}, author = {Alice Axford and Bob Birkin and Charlie Copper and Danny Dannford}, year = {2013}, month = {Mar}, journal = {Journal of \\TeX perts}, volume = {36}, number = {7}, pages = {114-120}}多数时候，我们无需自己手写 BibTeX 文献条目。从 Google Scholar 或者期刊/数据库的网站上都能够导出 BibTeX 文献条目。参考文献的写法在不同文献里千差万别，包括作者、标题、年份等各项的顺序和字体样式、文献在列表中的排序规则等。BibTeX 用样式（style）来管理参考文献的写法。BibTeX 提供了几个预定义的样式，如 plain, unsrt, alpha 等。如果使用期刊模板的话，可能会提供自用的样式。样式文件以 .bst 为扩展名。使用样式文件的方法是在源代码内（导言区）使用 \\bibliographystyle 命令：\\bibliographystyle{⟨bst-name⟩}。⟨bst-name⟩ 为 .bst 样式文件的名称，不要带 .bst 扩展名。使用 BibTeX 排版参考文献 准备一份 BibTex 数据库，假设数据库文件名为 books.bib，和 LaTeX 源代码一般位于同一个目录下。 在源代码中添加必要的命令，假设源代码名为 demo.tex。 a. 首先，需要使用命令 \\bibliographystyle 设定参考文献的格式 b. 其次，使用命令 \\cite 在正文中引用参考文献 c. 再次，在需要列出参考文献的位置，使用 \\bibliography 命令代替 thebibliography 环境 % demo.tex\\documentclass{article}\\bibliographystyle{plain}\\begin{document}\\section{Some words}Some excellent books, for example, \\cite{citation1}and \\cite{citation2} \\ldots\\bibliography{books}\\end{document}% 注意：\\bibliographystyle 和\\bibliography 命令缺一不可，否则生成参考文献列表的时候会报错。 进行编译。 a. 首先使用 pdflatex 或 xelatex 等命令编译 LaTeX 源代码 demo.tex b. 接下来用 bibtex 命令处理 demo.aux 辅助文件记录的参考文献格式、引用条目等信息。bibtex 命令处理完毕后会生成 demo.bbl 文件，内容就是一个 thebibliography 环境 c. 再使用 pdflatex 或 xelatex 等命令把源代码 demo.tex 编译两遍，读入参考文献并正确生成引用 整个过程使用的命令如下（可以略去扩展名）：xelatex demobibtex demoxelatex demoxelatex demo natbib 宏包natbib 宏包在正文中支持以下两种人名——年份的引用方式：\\citep{⟨citation⟩}\\citet{⟨citation⟩}分别生成形如 (Axford et al., 2013) 和 Axford et al. (2013) 的人名——年份引用。正确排版人名——年份引用还依赖于特定的 BibTeX 样式。natbib 提供了与 LaTeX 预定义样式相对应的几个样式，包括 plainnat、abbrvnat 和 unsrtnat。学术论文模板是否支持 natbib，需要参考其帮助文档。biblatex 宏包biblatex 宏包是一套基于 LaTeX 宏命令的参考文献解决方案，提供了便捷的格式控制和强大的排序、分类、筛选、多文献表等功能。biblatex 宏包也因其对 UTF-8 和中文参考文献的良好支持，被国内较多 LaTeX 模板采用。基于 biblatex 宏包的方式与基于 BibTeX 的传统方式有一定区别： 文档结构和 biblatex 相关命令 a. 在导言区调用 biblatex 宏包。宏包支持以 ⟨key⟩=⟨value⟩ 形式指定选项，包括参考文献样式 style、参考文献著录排序的规则 sorting 等 b. 在导言区使用 \\addbibresource 命令为 biblatex 引入参考文献数据库。与基于 BibTeX 的传统方式不同的是，biblatex 需要写完整的文件名 c. 在正文中使用 \\cite 命令引用参考文献。除此之外还可以使用丰富的命令达到不同的引用效果，如 \\citeauthor 和 \\citeyear 分别单独引用作者和年份，\\textcite 和 \\parencite 分别类似 natbib 宏包提供的 \\citet 和 \\citep 命令，以及脚注式引用 \\footcite 等 d. 在需要排版参考文献的位置使用命令 \\printbibliography 编译方式 与基于 BibTeX 的传统方式不同的是，biblatex 宏包使用 biber 程序处理参考文献。因此之前文档的编译步骤变为：xelatex demobiber demoxelatex demoxelatex demo % File: egbibdata.bib@book{caimin2006,title = {UML 基础和 Rose 建模教程},address = {北京},author = {蔡敏 and 徐慧慧 and 黄柄强},publisher = {人民邮电出版社},year = {2006},month = {1}} % File: demo.tex\\documentclass{ctexart}% 使用符合 GB/T 7714-2015 规范的参考文献样式\\usepackage[style=gb7714-2015]{biblatex}% 注意加 .bib 扩展名\\addbibresource{egbibdata.bib}\\begin{document}见文献\\cite{caimin2006}。\\printbibliography\\end{document} 样式 biblatex 使用的参考文献样式分为著录样式（bibliography style）和引用样式（citation style），分别以 .bbx 和 .cbx 为扩展名。参考文献的样式在调用宏包时使用 style 选项指定，或者使用 bibstyle 或 citestyle 分别指定： % 同时调用 gb7714-2015.bbx 和 gb7714-2015.cbx\\usepackage[style=gb7714-2015]{biblatex}% 著录样式调用 gb7714-2015.bbx，引用样式调用 biblatex 宏包自带的 authoryear\\usepackage[bibstyle=gb7714-2015,citestyle=authoryear]{biblatex} 二、索引和 makeindex 工具书籍和大文档通常用索引来归纳关键词，方便用户查阅。LaTeX 借助配套的 makeindex 程序完成对索引的排版。使用 makeindex 在导言区调用 makeidx 宏包，并使用 \\makeindex 命令开启索引的收集： \\usepackage{makeidx}\\makeindex 在正文中需要索引的地方使用 \\index 命令，并在需要输出索引的地方（如所有章节之后）使用 \\printindex 命令 编译 a. 首先用 xelatex 等命令编译源代码，编译过程中产生索引记录文件 *.idx b. 用 makeindex 程序处理 *.idx，生成用于排版的索引列表文件 *.ind c. 再次编译源代码，正确生成索引列表 索引项写法添加索引项的命令为：\\index{⟨index entry⟩}。 ⟨index entry⟩ 为索引项，写法由下表汇总。另外，!、@、 为特殊符号，如果要向索引项直接输出这些符号，需要加前缀 “；而 “ 需要输入两个引号 “” 才能输出到索引项。 举例 索引项 备注 普通索引     hello hello, 1 普通索引       分级索引，以 ! 分隔，最多支持三级     hello hello, 1 一级索引 hello!Peter Peter, 2 二级索引 hello!Peter!Jack Jack, 3 三级索引       格式化索引，形式为 ⟨alpha⟩@⟨format⟩     ⟨alpha⟩ 为纯字母，用来排序     ⟨format⟩ 为索引的格式，可以包括 LATEX 代码和简单的公式     Mobius@M\\&quot;”obius Möbius, 2 输出重音 alpha@$\\alpha$ α, 7 输出公式 bold@\\textbf{bold} bold, 12 输出粗体       页码范围     morning|( morning, 6–7 范围索引的开头 morning|)   范围索引的结尾       格式化索引页码     Jenny|textbf Jenny, 3 调用 \\textbf 加粗页码 Joe|see{Jenny} Joe, see Jenny 调用 \\see 生成特殊形式 Joe|seealso{Jenny} Joe, see also Jenny 调用 \\seealso 生成特殊形式 三、颜色原始的 LaTeX 不支持使用各种颜色。color 宏包或者 xcolor 宏包提供了对颜色的支持，给 PDF 输出生成颜色的特殊指令。颜色表达式调用 color 或 xcolor 宏包后，通过以下两种方式切换颜色：\\color[⟨color-mode⟩]{⟨code⟩}\\color{⟨color-name⟩} 使用色彩模型和色彩代码，代码用 0 ∼1 的数字代表成分的比例。color 宏包支持 rgb、cmyk 和 gray 模型，xcolor 支持更多的模型如 hsb 等。 \\large\\sffamily{\\color[gray]{0.6}60\\% 灰色} \\\\{\\color[rgb]{0,1,1}青色} 直接使用名称代表颜色，前提是已经定义了颜色名称（没定义会报错）。 \\large\\sffamily{\\color{red} 红色} \\\\{\\color{blue} 蓝色} color 宏包仅定义了 8 种颜色名称，xcolor 补充了一些，总共有 19 种。如果调用 color 或 xcolor 宏包时指定 dvipsnames 选项，就有额外的 68 种颜色名称可用。 xcolor 还支持将颜色通过表达式混合或互补：\\large\\sffamily{\\color{red!40} 40\\% 红色}\\\\{\\color{blue}蓝色\\color{blue!50!black}蓝黑\\color{black}黑色}\\\\{\\color{-red}红色的互补色}或者通过命令自定义颜色名称：\\definecolor{⟨color-name⟩}{⟨color-mode⟩}{⟨code⟩}。带颜色的文本和盒子输入带颜色的文本可以用类似 \\textbf 的命令：\\textcolor[⟨color-mode⟩]{⟨code⟩}{⟨text⟩}\\textcolor{⟨color-name⟩}{⟨text⟩}以下命令构造一个带背景色的盒子，⟨material⟩ 为盒子中的内容：\\colorbox[⟨color-mode⟩]{⟨code⟩}{⟨material⟩}\\colorbox{⟨color-name⟩}{⟨material⟩}以下命令构造一个带背景色和有色边框的盒子，⟨fcode⟩ 或 ⟨fcolor-name⟩ 用于设置边框颜色：\\fcolorbox[⟨color-mode⟩]{⟨fcode⟩}{⟨code⟩}{⟨material⟩}\\fcolorbox{⟨fcolor-name⟩}{⟨color-name⟩}{⟨material⟩}示例如下：\\sffamily文字用\\textcolor{red}{红色}强调\\\\\\colorbox[gray]{0.95}{浅灰色背景} \\\\\\fcolorbox{blue}{yellow}{\\textcolor{blue}{蓝色边框+文字，黄色背景}}四、超链接LaTeX 通过 hyperref 宏包实现超链接。hyperref 宏包hyperref 宏包涉及到的链接遍布 LaTeX 的每一个角落——目录、引用、脚注、索引、参考文献等等都被封装成超链接。这使得它与其它宏包发生冲突的可能性大大增加，虽然宏包已经尽力解决各方面的兼容性，但仍不能面面俱到。为减少可能的冲突，习惯上将 hyperref 宏包放在其它宏包之后调用。hyperref 宏包提供了命令 \\hypersetup 配置各种参数。参数也可以作为宏包选项，在调用宏包时指定：\\hypersetup{⟨option1⟩,⟨option2⟩={value},...}\\usepackage[⟨option1⟩,⟨option2⟩={value},...]{hyperref}可选参数如下： 参数 默认值 含义 colorlinks=⟨true|false⟩ false 设置为 true 为链接文字带颜色，反之加上带颜色的边框 hidelinks   取消链接的颜色和边框 pdfborder={⟨n⟩ ⟨n⟩ ⟨n⟩} 0 0 1 超链接边框设置，设为 0 0 0 可取消边框       bookmarks=⟨true|false⟩ true 是否生成书签 bookmarksopen=⟨true|false⟩ false 是否展开书签 bookmarksnumbered=⟨true|false⟩ false 书签是否带章节编号       pdftitle=⟨string⟩ 空 标题 pdfauthor=⟨string⟩ 空 作者 pdfsubject=⟨string⟩ 空 主题 pdfkeywords=⟨string⟩ 空 关键词 pdfstartview=⟨Fit|FitH|FitV⟩ Fit 设置 PDF 页面以适合页面/适合宽度/适合高度等方式显示，默认为适合页面 超链接hyperref 宏包提供了直接书写超链接的命令：\\url{⟨url⟩}\\nolinkurl{⟨url⟩}\\href{⟨url⟩}{⟨text⟩}\\url 和 \\nolinkurl 都生成可以点击的 URL，区别是前者有彩色，后者没有。在 \\url 命令中作为参数的 URL 里，可直接输入如 %、&amp;amp; 这样的特殊符号。\\url{http://wikipedia.org} \\\\\\nolinkurl{http://wikipedia.org} \\\\\\href{http://wikipedia.org}{Wiki}用户也可对某个 \\label 命令定义的标签 ⟨label⟩ 作超链接（注意这里的 ⟨label⟩ 虽然是可选参数的形式，但通常是必填的）：\\hyperref[⟨label⟩]{⟨text⟩}。默认的超链接在文字外边加上一个带颜色的边框（在打印 PDF 时边框不会打印），可指定 colorlinks 参数修改为将文字本身加上颜色，或修改 pdfborder 参数调整边框宽度以“去掉”边框；hidelinks 参数则令超链接既不变色也不加边框。\\hypersetup{colorlinks=true}% or:\\hypersetup{pdfborder={0 0 0}}% or:\\hypersetup{hidelinks}PDF 书签hyperref 宏包另一个强大的功能是为 PDF 生成书签。对于章节命令 \\chapter、\\section 等，默认情况下会为 PDF 自动生成书签。和交叉引用、索引等类似，生成书签也需要多次编译源代码，第一次编译将书签记录写入 .out 文件，第二次编译才正确生成书签。" }, { "title": "LaTex 排版样式", "url": "/posts/latex_style/", "categories": "language, latex", "tags": "latex", "date": "2021-08-29 00:00:00 +0800", "snippet": "[toc]本章关注如何修改 LATEX 的排版样式。一、字体和字号LaTex 提供了两组修改字体的命令，如下图。其中诸如 \\bfseries 形式的命令将会影响之后所有的字符，如果想要让它在局部生效，需要用花括号分组，也就是写成 {\\bfseries ⟨some text⟩} 的形式；对应的 \\textbf 形式带一个参数，只改变参数内部的字体，更为常用。下图列出了字号命令在标准文档类中的绝对大小，单位为 pt。使用字号命令的时候，通常也需要用花括号进行分组，如同 \\rmfamily 那样。另外还有一个基础命令 \\fontsize 用于设定任意大小的字号：\\fontsize{⟨size⟩}{⟨base line-skip⟩}，⟨size⟩ 为字号，⟨base line-skip⟩ 为基础行距，上图中的基础行距为 1.2。如果不是在导言区，\\fontsize 的设定需要 \\selectfont 命令才能立即生效，而上图的字号设定都是立即生效的。文字装饰和强调\\underline 命令用来为文字添加下划线：An \\underline{underlined} text.\\underline 命令生成下划线的样式不够灵活，不同的单词可能生成高低各异的下划线，并且无法换行。ulem 宏包提供了更灵活的解决方案，它提供的 \\uline 命令能够轻松生成自动换行的下划线：An example of \\uline{somelong and underlined words.}二、段落格式和间距长度长度的数值 ⟨length⟩ 由数字和单位组成。常用的单位： pt 点阵宽度，1/72.27in bp 点阵宽度，1/72in in 英寸 cm 厘米 mm 毫米 em 当前字号下大写字母 M 的宽度，常用于水平距离的设定 ex 当前字号下小写字母 x 的高度，常用于垂直距离的设定一些情况下还会用到可伸缩的“弹性长度”，如 12pt plus 2pt minus 3pt 表示基础长度为 12pt，可以伸展到 14pt，也可以收缩到 9pt。也可只定义 plus 或者 minus 的部分，如 0pt plus 5pt。长度的数值还可以用长度变量本身或其倍数来表达，如 2.5\\parindent 等。LaTex 预定义了大量的长度变量用于控制版面格式。如页面宽度和高度、首行缩进、段落间距等。如果需要自定义长度变量，需使用命令：\\newlength{\\⟨length command⟩}。长度变量可以用 \\setlength 赋值，或用 \\addtolength 增加长度：\\setlength{\\⟨length command⟩}{⟨length⟩}\\addtolength{\\⟨length command⟩}{⟨length⟩}行距\\fontsize 命令可以为字号设定对应的行距，但很少那么用。更常用的办法是在导言区使用 \\linespread 命令：\\linespread{⟨factor⟩}。⟨factor⟩ 作用于基础行距而不是字号。缺省的基础行距是 1.2 倍字号大小，因此使用 \\linespread{1.5} 意味着最终行距为 1.8 倍的字号大小。如果不是在导言区全局修改，而想要局部地改变某个段落的行距，需要用 \\selectfont 命令使 \\linespread 命令的改动立即生效：{\\linespread{2.0}\\selectfontThe baseline skip is set to betwice the normal baseline skip.Pay attention to the \\verb|\\par|command at the end. \\par}In comparison, after thecurly brace has been closed,everything is back to normal.字号的改变是即时生效的，而行距的改变直到文字分段时才生效。如果需要改变某一部分文字的行距，那么不能简单地将文字包含在花括号内。注意下面两个例子中 \\par 命令的位置，以及上一个例子的写法（\\par 相当于分段)：{\\Large Don&#39;t read this! It is not true. You can believe me!\\par}{\\Large This is not true either.But remember I am a liar.}\\par缩进段落的左缩进、右缩进和首行缩进，与设置行距的命令一样，在分段时生效。 \\setlength{\\leftskip}{⟨length⟩} \\setlength{\\rightskip}{⟨length⟩} \\setlength{\\parindent}{⟨length⟩}控制段落缩进的命令为：\\indent\\noindent默认在段落开始时缩进，长度为用上述命令设置的 \\parindent。如果需要在某一段不缩进，可在段落开头使用 \\noindent 命令。相反地，\\indent 命令强制开启一段首行缩进的段落。在段落开头使用多个 \\indent 命令可以累加缩进量。水平间距LaTex 默认为将单词之间的“空格”转化为水平间距。如果需要在文中手动插入额外的水平间距，可使用 \\hspace 命令：This\\hspace{1.5cm}is a spaceof 1.5 cm.\\hspace 命令生成的水平间距如果位于一行的开头或末尾，则有可能因为断行而被舍弃。可使用 \\hspace* 命令代替 \\hspace 命令得到不会因断行而消失的水平间距。命令 \\stretch{⟨n⟩} 生成一个特殊弹性长度，参数 ⟨n⟩ 为权重。它的基础长度为 0pt，但可以无限延伸，直到占满可用的空间。如果同一行内出现多个 \\stretch{⟨n⟩}，这一行的所有可用空间将按每个 \\stretch 命令给定的权重 ⟨n⟩ 进行分配。命令 \\fill 相当于 \\stretch{1}。x\\hspace{\\stretch{1}}x\\hspace{\\stretch{3}}x\\hspace{\\fill}x数学公式中遇到的 \\quad 和 \\qquad 命令，也可以用于文本中，分别相当于 \\hspace{1em} 和 \\hspace{2em}。垂直间距使用 \\vspace 命令可以人为增加两个段落间的垂直距离：A paragraph.\\vspace{2ex}Another paragraph.\\vspace 命令生成的垂直间距在一页的顶端或底端可能被“吞掉”，类似 \\hspace 在一行 开头和末尾那样。对应地，\\vspace* 命令产生不会因断页而消失的垂直间距。\\vspace 也可用 \\stretch 设置无限延伸的垂直长度。三、页面控制页边距的参数由下图里给出的各种长度变量控制。可以用 \\setlength 命令修改这些长度变量，以达到调节页面尺寸和边距的作用；反之也可以利用这些长度变量来决定排版内容的尺寸。图中有些页边距的参数并不好设定，而 geometry 宏包提供了设置页边距等参数的简便方法。geometry 宏包可以通过两种方式进行设定： 调用 geometry 宏包然后用其提供的 \\geometry 命令设置页面参数 \\usepackage{geometry} \\geometry{⟨geometry-settings⟩} 将参数指定为宏包的选项 \\usepackage[⟨geometry-settings⟩]{geometry} 比如，符合 Microsoft Word 习惯的页面设定是 A4 纸张，上下边距 1 英寸，左右边距 1.25 英寸，可以通过如下两种等效的方式之一设定页边距：\\usepackage[left=1.25in,right=1.25in,top=1in,bottom=1in]{geometry}% or like this:\\usepackage[hmargin=1.25in,vmargin=1in]{geometry}又比如，需要设定周围的边距一致为 1.25 英寸，可以用更简单的语法： \\usepackage[margin=1.25in]{geometry}。对于书籍等双面文档，习惯上奇数页右边、偶数页左边留出较多的页边距，而书脊一侧的奇数页左边、偶数页右边页边距较少。可以这样设定:\\usepackage[inner=1in,outer=1.25in]{geometry}geometry 宏包本身也能够修改纸张大小、页眉页脚高度、边注宽度等等参数。更详细的用法可以查阅 geometry 宏包的帮助文档。四、页眉页脚命令 \\pagestyle 用来修改页眉页脚的样式：\\pagestyle{⟨page-style⟩}。命令 \\thispagestyle 只影响当页的页眉页脚样式：\\thispagestyle{⟨page-style⟩}。⟨page-style⟩ 参数为样式的名称，预定义的有四类样式： empty，页眉页脚为空 plain，页眉为空，页脚为页码。（article 和 report 文档类默认；book 文档类的每章第一页也为 plain 格式） headings，页眉为章节标题和页码，页脚为空。（book 文档类默认） myheadings，页眉为页码及 \\markboth 和 \\markright 命令手动指定的内容，页脚为空。headings 样式： article 文档类，twoside 选项偶数页为页码和节标题，奇数页为小节标题和页码 article 文档类，oneside 选项页眉为节标题和页码 book/report 文档类，twoside 选项偶数页为页码和章标题，奇数页为节标题和页码 book/report 文档类，oneside 选项页眉为章标题和页码命令 \\pagenumbering 用来改变页眉页脚中的页码样式：\\pagenumbering{⟨style⟩}。⟨style⟩ 为页码样式，默认为 arabic（阿拉伯数字），还可修改为 roman（小写罗马数字）、 Roman（大写罗马数字）等。注意使用 \\pagenumbering 命令后会将页码重置为 1。" }, { "title": "LaTex 数学公式", "url": "/posts/latex_math/", "categories": "language, latex", "tags": "latex", "date": "2021-08-25 00:00:00 +0800", "snippet": "[toc]一、AMS 宏集AMS 宏集是美国数学学会 (American Mathematical Society) 提供的对 LaTex 原生数学公式排版的扩展，其核心是 amsmath 宏包，对多行公式的排版提供了有力的支持。此外，amsfonts 宏包以及基于它的 amssymb 宏包提供了丰富的数学符号；amsthm 宏包扩展了 LaTex 定理证明格式。二、公式排版基础行内公式和行间公式数学公式有两种排版方式：其一是与文字混排，称为行内公式；其二是单独列为一行排版，称为行间公式。行内公式由一对 $ 符号包裹：The Pythagorean theorem is$a^2 + b^2 = c^2$.行间公式由 equation 环境包裹。equation 环境为公式自动生成一个编号，这个编号可以用 \\label 和 \\ref 生成交叉引用，amsmath 的 \\eqref 命令则为引用自动加上圆括号；还可以用 \\tag 命令手动修改公式的编号，或者用 \\notag 命令取消为公式编号。The Pythagorean theorem is:\\begin{equation}a^2 + b^2 = c^2 \\label{pythagorean}\\end{equation}Equation \\eqref{pythagorean} iscalled `Gougu theorem&#39; in Chinese.It&#39;s wrong to say\\begin{equation}1 + 1 = 3 \\tag{dumb}\\end{equation}or\\begin{equation}1 + 1 = 4 \\notag\\end{equation}如果需要直接使用不带编号的行间公式，则将公式用命令 \\[ 和 \\] 包裹，与之等效的是 displaymath 环境。有的人更喜欢 equation* 环境，体现了带星号和不带星号的环境之间的区别。\\begin{equation*}a^2 + b^2 = c^2\\end{equation*}For short:\\[ a^2 + b^2 = c^2 \\]Or if you like the long one:\\begin{displaymath}a^2 + b^2 = c^2\\end{displaymath}为了与文字相适应，行内公式在排版大的公式元素（分式、巨算符等）时显得很“局促”，以下是对比：In text:$\\lim_{n \\to \\infty}\\sum_{k=1}^n \\frac{1}{k^2}= \\frac{\\pi^2}{6}$.In display:\\[\\lim_{n \\to \\infty}\\sum_{k=1}^n \\frac{1}{k^2}= \\frac{\\pi^2}{6}\\]数学模式当用户使用 $ 开启行内公式输入，或是使用 \\[ 命令、equation 环境时，LaTex 就进入了数学模式。数学模式相比于文本模式有以下特点： 空格被忽略，数学符号的间距默认由符号的性质（关系符号、运算符等）决定。需要人为引入间距时，使用 \\quad 和 \\qquad 等命令。 不允许有空行（分段），行间公式中也无法用 \\\\ 命令手动换行。 所有的字母被当作数学公式中的变量处理，字母间距与文本模式不一致，也无法生成单词之间的空格。如果想在数学公式中输入正体的文本，简单情况下可用 \\mathrm 命令，或者用 amsmath 提供的 \\text 命令。$x^{2} \\geq 0 \\qquad \\text{for \\textbf{all} } x \\in \\mathbb{R}$三、数学符号LaTex 默认提供了常用的数学符号，amssymb 宏包提供了一些次常用的符号。一般符号希腊字母符号的名称就是其英文名称，如 α (\\alpha)、β (\\beta) 等等。大写的希腊字母为首字母大写的命令，如 Γ (\\Gamma)、∆ (\\Delta) 等等。无穷大符号为 ∞ (\\infty)，等等。省略号：. . . (\\dots) 和 · · · (\\cdots) ，以及竖排的 (\\vdots) 和斜排的 (\\ddots)。指数、上下标和导数用 ^ 和 _ 标明上下标，上下标的内容（子公式）一般需要用花括号包裹，否则上下标只对后面的一个符号起作用。$p^3_{ij} \\qquadm_\\mathrm{Knuth}\\qquad\\sum_{k=1}^3 k $\\\\[5pt]$a^x+y \\neq a^{x+y}\\qquade^{x^2} \\neq {e^x}^2$导数符号 ‘ 是一类特殊的上标，可以适当连用表示多阶导数，也可以在其后连用上标：$f(x) = x^2 \\quad f&#39;(x)= 2x \\quad f&#39;&#39;^{2}(x) = 4$分式和根式分式使用 \\frac{分子}{分母} 来书写。分式的大小在行间公式中是正常大小，而在行内 极度压缩。amsmath 提供了方便的命令 \\dfrac 和 \\tfrac，令用户能够在行内使用正常大小的分式，或是反过来。In display style:\\[3/8 \\qquad \\frac{3}{8}\\qquad \\tfrac{3}{8}\\]In text style:$1\\frac{1}{2}$~hours \\qquad$1\\dfrac{1}{2}$~hours根式使用 \\sqrt{...}，表示 n 次方根时写成 \\sqrt[n]{...}。$\\sqrt{x} \\Leftrightarrow x^{1/2}\\quad \\sqrt[3]{2}\\quad \\sqrt{x^{2} + \\sqrt{y}}$特殊的分式形式，如二项式结构，由 amsmath 宏包的 \\binom 命令生成：Pascal&#39;s rule is\\[\\binom{n}{k} =\\binom{n-1}{k}+ \\binom{n-1}{k-1}\\]关系符常见的关系符号除了可以直接输入的 =，&amp;gt;，&amp;lt;，其它符号用命令输入，常用的有不等号 \\ne、大于等于号 ≥ (\\ge) 和小于等于号 ≤ (\\le)、约等号 ≈ (\\approx)、等价 ≡ (\\equiv)、正比 ∝ (\\propto)、相似 ∼ (\\sim) 等等。LaTex 还提供了自定义二元关系符的命令 \\stackrel，用于将一个符号叠加在原有的二元关系符之上：\\[f_n(x) \\stackrel{*}{\\approx} 1 f_n(x) \\stackrel{\\ne}{\\approx} 1\\]算符算符大多数是二元算符，除了直接用键盘可以输入的 +、−、∗、/，其它符号用命令输入，常用的有乘号 × (\\times)、除号 ÷ (\\div)、点乘 · (\\cdot)、加减号 ± (\\pm) / ∓ (\\mp) 、∇ (\\nabla) 和 ∂ (\\partial) 等等。LaTex 也将数学函数的名称作为一个算符排版，字体为直立字体。巨算符积分号 \\int、求和号 \\sum 等符号称为巨算符。巨算符在行内公式和行间公式的大小和形状有区别。In text:$\\sum_{i=1}^n \\quad\\int_0^{\\frac{\\pi}{2}} \\quad\\oint_0^{\\frac{\\pi}{2}} \\quad\\prod_\\epsilon $ \\\\In display:\\[\\sum_{i=1}^n \\quad\\int_0^{\\frac{\\pi}{2}} \\quad\\oint_0^{\\frac{\\pi}{2}} \\quad\\prod_\\epsilon \\]巨算符的上下标位置可由 \\limits 和 \\nolimits 调整，前者令巨算符类似 lim 或求和算符上下标位于上下方；后者令巨算符类似积分号，上下标位于右上方和右下方。In text:$\\sum\\limits_{i=1}^n \\quad\\int\\limits_0^{\\frac{\\pi}{2}} \\quad\\prod\\limits_\\epsilon $ \\\\In display:\\[\\sum\\nolimits_{i=1}^n \\quad\\int\\limits_0^{\\frac{\\pi}{2}} \\quad\\prod\\nolimits_\\epsilon \\]amsmath 宏包还提供了 \\substack，能够在下限位置书写多行表达式；subarray 环境更进 一步，令多行表达式可选择居中 (c) 或左对齐 (l)：\\[\\sum_{\\substack{0\\le i\\le n \\\\ j\\in \\mathbb{R}}}P(i,j) = Q(n)\\]\\[\\sum_{\\begin{subarray}{l}0\\le i\\le n \\\\ j\\in \\mathbb{R}\\end{subarray}}P(i,j) = Q(n)\\]重音和箭头$\\bar{x_0} \\quad \\bar{x}_0$\\\\[5pt]$\\vec{x_0} \\quad \\vec{x}_0$\\\\[5pt]$\\hat{\\mathbf{e}_x} \\quad \\hat{\\mathbf{e}}_x$ $0.\\overline{3} =\\underline{\\underline{1/3}}$ \\\\[5pt]$\\hat{XY} \\qquad \\widehat{XY}$\\\\[5pt]$\\vec{AB} \\qquad\\overrightarrow{AB}$$\\underbrace{\\overbrace{(a+b+c)}^6\\cdot \\overbrace{(d+e+f)}^7}_\\text{meaning of life} = 42$amsmath 的 \\xleftarrow 和 \\xrightarrow 命令提供了长度可以伸展的箭头，并且可以为箭头增加上下标：\\[ a\\xleftarrow{x+y+z} b \\]\\[ c\\xrightarrow[x&amp;lt;y]{a*b*c}d \\]括号和定界符LaTex 提供了多种括号和定界符表示公式块的边界，如小括号 ()、中括号 []、大括号 {}({})、尖括号 ⟨⟩ (\\langle \\rangle)等。${a,b,c} \\neq \\{a,b,c\\}$使用 \\left 和 \\right 命令可令括号（定界符）的大小可变，在行间公式中常用。LaTex 会自动根据括号内的公式大小决定定界符大小。\\left 和 \\right 必须成对使用。需要使用单个定界符时，另一个定界符写成 \\left. 或 \\right.。\\[1 + \\left(\\frac{1}{1-x^{2}}\\right)^3 \\qquad\\left.\\frac{\\partial f}{\\partial t}\\right|_{t=0}\\]四、多行公式长公式折行通常来讲应当避免写出超过一行而需要折行的长公式。如果一定要折行的话，习惯上优先在等号之前折行，其次在加号、减号之前，再次在乘号、除号之前。其它位置应当避免折行。amsmath 宏包的 multline 环境提供了书写折行长公式的方便环境。它允许用 \\\\ 折行，将公式编号放在最后一行。多行公式的首行左对齐，末行右对齐，其余行居中。\\begin{multline}a+b+c+d+e+f + g + h + i \\\\= j + k + l + m + n \\\\= o + p + q + r + s \\\\=t+u+v+x+z\\end{multline}多行align 环境，它将公式用 &amp;amp; 隔为两部分并对齐。分隔符通常放在等号左边：\\begin{align}a &amp;amp; = b + c \\\\&amp;amp;=d+e\\end{align}align 环境会给每行公式都编号。但可以用 \\notag 去掉某行的编号：\\begin{align}a ={} &amp;amp; b + c \\\\ ={} &amp;amp; d + e + f + g + h + i + j + k + l \\notag \\\\ &amp;amp; + m + n + o \\\\ ={} &amp;amp; p + q + r + s\\end{align}align 还能够对齐多组公式，除等号前的 &amp;amp; 之外，公式之间也用 &amp;amp; 分隔：\\begin{align}a &amp;amp;=1 &amp;amp; b &amp;amp;=2 &amp;amp; c &amp;amp;=3 \\\\d &amp;amp;=-1 &amp;amp; e &amp;amp;=-2 &amp;amp; f &amp;amp;=-5\\end{align}如果不需要按等号对齐，只需罗列数个公式，gather 将是一个很好用的环境：\\begin{gather}a = b + c \\\\d = e + f + g \\\\h + i = j + k \\notag \\\\l+m=n\\end{gather}公用编号另一个常见的需求是将多个公式组在一起公用一个编号，编号位于公式的居中位置。为此，amsmath 宏包提供了诸如 aligned、gathered 等环境，与 equation 环境套用。以 -ed 结尾的环境用法与不以 -ed 结尾的环境用法一一对应。\\begin{equation}\\begin{aligned}a &amp;amp;= b + c \\\\d &amp;amp;= e + f + g \\\\h + i &amp;amp;= j + k \\\\l + m &amp;amp;= n\\end{aligned}\\end{equation}五、数组和矩阵array 环境用来排版数组和矩阵，用法与 tabular 环境极为类似，也需要定义列格式，并用 \\ 换行。数组可作为一个公式块，在外套用 \\left、\\right 等定界符：\\[ \\mathbf{X} = \\left(\\begin{array}{cccc}x_{11} &amp;amp; x_{12} &amp;amp; \\ldots &amp;amp; x_{1n}\\\\x_{21} &amp;amp; x_{22} &amp;amp; \\ldots &amp;amp; x_{2n}\\\\\\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots\\\\x_{n1} &amp;amp; x_{n2} &amp;amp; \\ldots &amp;amp; x_{nn}\\\\\\end{array} \\right) \\]\\[ |x| = \\left\\{\\begin{array}{rl}-x &amp;amp; \\text{if } x &amp;lt; 0,\\\\0 &amp;amp; \\text{if } x = 0,\\\\x &amp;amp; \\text{if } x &amp;gt; 0.\\end{array} \\right. \\]上述例子也可以用 amsmath 提供的 cases 环境更轻松地完成:：\\[ |x| =\\begin{cases}-x &amp;amp; \\text{if } x &amp;lt; 0,\\\\0 &amp;amp; \\text{if } x = 0,\\\\x &amp;amp; \\text{if } x &amp;gt; 0.\\end{cases} \\] amsmath 宏包还直接提供了多种排版矩阵的环境，包括不带定界符的 matrix，以及带各种定界符的矩阵 pmatrix( ( )、bmatrix( [ )、Bmatrix( { )、vmatrix( )、Vmatrix(   )。 \\[\\begin{matrix}1 &amp;amp; 2 \\\\ 3 &amp;amp; 4\\end{matrix} \\qquad\\begin{bmatrix}x_{11} &amp;amp; x_{12} &amp;amp; \\ldots &amp;amp; x_{1n}\\\\x_{21} &amp;amp; x_{22} &amp;amp; \\ldots &amp;amp; x_{2n}\\\\\\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots\\\\x_{n1} &amp;amp; x_{n2} &amp;amp; \\ldots &amp;amp; x_{nn}\\\\\\end{bmatrix}\\]六、公式间距绝大部分时候，数学公式中各元素的间距是根据符号类型自动生成的，需要我手动调整的情况极少。一个常见的用途是修正积分的被积函数 f(x) 和微元 dx 之间的距离。\\[\\int_a^b f(x)\\mathrm{d}x\\qquad\\int_a^b f(x)\\,\\mathrm{d}x\\]另一个用途是生成多重积分号。如果我们直接连写两个 \\int，之间的间距将会过宽，此时可以使用负间距 \\! 修正之。不过 amsmath 提供了更方便的多重积分号，如二重积分 \\iint、三 重积分 \\iiint 等。\\newcommand\\diff{\\,\\mathrm{d}}\\begin{gather*}\\int\\int f(x)g(y)\\diff x \\diff y \\\\\\int\\!\\!\\!\\intf(x)g(y) \\diff x \\diff y \\\\\\iint f(x)g(y) \\diff x \\diff y \\\\\\iint\\quad \\iiint\\quad \\idotsint\\end{gather*}七、定理环境LaTex 原始定理环境LaTex 提供了 一个基本的命令 \\newtheorem 提供定理环境的定义：\\newtheorem{⟨theorem environment⟩}{⟨title⟩}[⟨section-level⟩] \\newtheorem{⟨theorem environment⟩}[⟨counter⟩]{⟨title⟩}⟨theorem environment⟩ 为定理环境的名称。原始的 LaTex 里没有现成的定理环境，不加定义而直接使用很可能会出错。⟨title⟩ 是定理环境的标题（“定理”，“公理”等）。定理的序号由两个可选参数之一决定，它们不能同时使用： ⟨section level⟩ 为章节级别，如 chapter、section 等，定理序号成为章节的下一级序号 ⟨counter⟩ 为用 \\newcounter 自定义的计数器名称，定理序号由这个计数器管理 如果两个可选参数都不用的话，则使用默认的与定理环境同名的计数器。以下示例代码中，定义了一个 mythm 环境，其序号设为 section 的下一级序号。\\newtheorem{mythm}{My Theorem}[section]\\begin{mythm}\\label{thm:light}The light speed in vacuumis $299,792,458\\,\\mathrm{m/s}$.\\end{mythm}\\begin{mythm}[Energy-momentum relation]The relationship of energy,momentum and mass is\\[E^2 = m_0^2 c^4 + p^2 c^2\\]where $c$ is the light speeddescribed in theorem \\ref{thm:light}.\\end{mythm}amsthm 宏包amsthm 提供了 \\theoremstyle 命令支持定理格式的切换，在用 \\newtheorem 命令定义定理环境之前使用。amsthm 预定义了三种格式用于 \\theoremstyle:plain 和 LaTex 原始的格式 一致；definition 使用粗体标签、正体内容；remark 使用斜体标签、正体内容。另外 amsthm 还支持用带星号的 \\newtheorem* 定义不带序号的定理环境：\\theoremstyle{definition} \\newtheorem{law}{Law}\\theoremstyle{plain} \\newtheorem{jury}[law]{Jury}\\theoremstyle{remark} \\newtheorem*{mar}{Margaret}\\begin{law}\\label{law:box}Don&#39;t hide in the witness box.\\end{law}\\begin{jury}[The Twelve]It could be you! So beware andsee law~\\ref{law:box}.\\end{jury}\\begin{jury}You will disregard the laststatement.\\end{jury}\\begin{mar}No, No, No\\end{mar}\\begin{mar}Denis!\\end{mar}证明环境和证毕符号amsthm 还提供了一个 proof 环境用于排版定理的证明过程。proof 环境末尾自动加上一个证毕符号：\\begin{proof}For simplicity, we use\\[E=mc^2\\]That&#39;s it.\\end{proof}如果行末是一个不带编号的公式， 符号会另起一行，这时可使用 \\qedhere 命令将符号放在公式末尾：\\begin{proof}For simplicity, we use\\[E=mc^2 \\qedhere\\]\\end{proof}" }, { "title": "LaTex 文档元素", "url": "/posts/latex_element/", "categories": "language, latex", "tags": "latex", "date": "2021-08-23 00:00:00 +0800", "snippet": "[toc]本章介绍一个结构化的文档所依赖的各种元素：章节、目录、列表、图表、交叉引用、脚注等等。一、章节和目录章节标题三个标准文档类（article、book、report）的章节划分命令：\\chapter{⟨title⟩} % 只在 book 和 report 中有\\section{⟨title⟩}\\subsection{⟨title⟩}\\subsubsection{⟨title⟩}\\paragraph{⟨title⟩}\\subparagraph{⟨title⟩}以上命令除了生成带编号的标题之外，还会向目录中添加条目。同时，每条命令有两个变体： 带可选参数的变体：\\section[⟨short title⟩]{⟨title⟩} ​ 标题使用 ⟨title⟩ 参数，在目录和页眉页脚中使用 ⟨short title⟩ 参数 带星号的变体：\\section*{⟨title⟩} ​ 标题不带编号，也不生成目录项和页眉页脚 较低层次如 \\paragraph 和 \\subparagraph 即使不用带星号的变体，生成的标题默认也不带编号。因此，实际带编号的层级为： article：\\section，\\subsection，\\subsubsection report/book：\\chapter，\\section，\\subsection目录生成目录非常容易，只需在合适的地方使用命令：\\tableofcontents，但正确生成目录项，一般需要编译两次源代码。目录会被生成为单独的一章（book / report）或一节（article），标题默认为“Contents”。当使用了 \\chapter* 或 \\section* 这样不生成目录项的章节标题命令，而又想手动生成该章节的目录项时，可以在标题命令后面使用：\\addcontentsline{toc}{⟨level⟩}{⟨title⟩}，其中 ⟨level⟩ 为章节层次 chapter 或 section 等，⟨title⟩ 为出现于目录项的章节标题。（这个操作怎么感觉多此一举呢，为什么不自动生成目录项）文档结构划分标准文档类提供了一个 \\appendix 命令将正文和附录分开，使用该命令后，最高一级章节改为使用拉丁字母编号，从 A 开始。book 文档类还提供了前言、正文、后记结构的划分命令： \\frontmatter 前言部分：页码为小写罗马字母格式；其后的 \\chapter 不编号。 \\mainmatter 正文部分：页码为阿拉伯数字格式，从 1 开始计数；其后的章节编号正常。 \\backmatter 后记部分：页码格式不变，继续正常计数；其后的 \\chapter 不编号。 以上三个命令还可和 \\appendix 命令结合，生成有前言、正文、附录、后记四部分的文档，下面是个示例。\\documentclass{book}% 导言区，加载宏包和各项设置，包括参考文献、索引等\\usepackage{makeidx} % 调用 makeidx 宏包，用来处理索引\\makeindex % 开启索引的收集\\bibliographystyle{plain} % 指定参考文献样式为 plain\\begin{document}\\frontmatter % 前言部分\\maketitle % 标题页\\include{preface} % 前言章节 preface.tex\\tableofcontents\\mainmatter % 正文部分\\include{chapter1} % 第一章 chapter1.tex\\include{chapter2} % 第二章 chapter2.tex...\\appendix % 附录\\include{appendixA} % 附录A appendixA.tex...\\backmatter % 后记部分\\include{prologue} % 后记 prologue.tex\\bibliography{books} % 利用 BibTeX 工具从数据库文件 books.bib 生成参考文献\\printindex % 利用 makeindex 工具生成索引\\end{document}二、标题页LaTex 支持生成简单的标题页，在导言区增加命令：\\title{⟨title⟩} \\author{⟨author⟩} \\date{⟨date⟩}，之后就可以使用 \\maketitle 命令生成一个简单的标题页了。LaTex 提供了一个 \\today 命令自动生成当前日期，\\date 默认使用 \\today。\\title{Test title}\\author{ Mary\\thanks{E-mail:*****@***.com}\\and Ted\\thanks{Corresponding author}\\and Louis}\\date{\\today}\\begin{document}\\maketitle % 标题页\\end{document}article 文档类的标题默认不单独成页，而 report 和 book 默认单独成页。可在 \\documentclass 命令调用文档类时指定 titlepage / notitlepage 选项以修改默认的行为。三、交叉引用交叉引用是 LaTex 强大的自动排版功能的体现之一。在能够被交叉引用的地方，如章节、公式、图表、定理等位置使用命令：\\label{⟨label-name⟩}，之后可以在需要引用处使用 \\ref 或 \\pageref 命令，分别生成交叉引用的编号和页码：\\ref{⟨label-name⟩} \\pageref{⟨label-name⟩}。A reference to this subsection\\label{sec:this} looks like:``see section~\\ref{sec:this} onpage~\\pageref{sec:this}.&#39;&#39;为了生成正确的交叉引用，一般也需要多次编译源代码。\\label 命令可用于记录各种类型的交叉引用，使用位置分别为： 章节标题：在章节标题命令 \\section 等之后紧接着使用。 行间公式：单行公式在公式内任意位置使用；多行公式在每一行公式的任意位置使用。 有序列表：在 enumerate 环境的每个 \\item 命令之后、下一个 \\item 命令之前任意位置使用。 图表标题：在图表标题命令 \\caption 之后紧接着使用。 定理环境：在定理环境内部任意位置使用。在使用不记编号的命令形式（\\section\\*、\\caption\\*、带可选参数的 \\item 命令等）时不要使用 \\label 命令，否则生成的引用编号不正确。四、脚注和边注使用 \\footnote 命令可以在页面底部生成一个脚注：\\footnote{⟨footnote⟩}。“天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。”\\footnote{出自《千字文》。}表格内使用 \\footnote 并不能正确生成脚注。需要分两步进行，先使用 \\footnotemark 为脚注计数，再在合适的位置用 \\footnotetext 生成脚注。\\begin{tabular}{l}\\hline“天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。”\\footnotemark \\\\\\hline\\end{tabular}\\footnotetext{表格里的名句出自《千字文》。}使用 \\marginpar 命令可在边栏位置生成边注：\\marginpar[⟨left-margin⟩]{⟨right-margin⟩}。如果只给定了 ⟨right-margin⟩，那么边注在奇偶数页文字相同；如果同时给定了 ⟨left-margin⟩，则偶数页使用 ⟨left-margin⟩ 的文字。\\marginpar{\\footnotesize 边注较窄，不要写过多文字，最好设置较小的字号。}五、特殊环境列表有序和无序列表环境 enumerate 和 itemize，两者的用法很类似，都用 \\item 标明每个列表项。% 有序列表\\begin{enumerate}\\item ...\\end{enumerate}\\begin{enumerate} \\item An item. \\begin{enumerate} \\item A nested item.\\label{itref} \\item[*] A starred item. \\end{enumerate} \\item Reference(\\ref{itref}).\\end{enumerate}% 无序列表\\begin{itemize}\\item ...\\end{itemize}\\begin{itemize} \\item An item. \\begin{itemize} \\item A nested item. \\item[+] A `plus&#39; item. \\item Another item. \\end{itemize} \\item Go back to upper level.\\end{itemize}关键字环境 description 的用法与以上两者类似，不同的是 \\item 后的可选参数用来写关键字，以粗体显示，一般是必填的：\\begin{description}\\item[⟨item title⟩] ...\\end{description}\\begin{description} \\item[Enumerate] Numbered list. \\item[Itemize] Non-numbered list.\\end{description} 各级有序列表的符号由命令 \\labelenumi 到 \\labelenumiv 定义，重新定义这些命令需要用到后续计数器相关命令。 各级无序列表的符号由命令 \\labelitemi 到 \\labelitemiv 定义，可以简单地重新定义它们。 \\renewcommand{\\labelenumi}%{\\Alph{enumi}&amp;gt;}\\begin{enumerate} \\item First item \\item Second item\\end{enumerate}\\renewcommand{\\labelitemi}{\\ddag}\\renewcommand{\\labelitemii}{\\dag}\\begin{itemize} \\item First item \\begin{itemize} \\item Subitem \\item Subitem \\end{itemize} \\item Second item\\end{itemize}对齐center、flushleft 和 flushright 环境分别用于生成居中、左对齐和右对齐的文本环境。\\begin{center} ... \\end{center}\\begin{flushleft} ... \\end{flushleft}\\begin{flushright} ... \\end{flushright}\\begin{center}Centered text using a\\verb|center| environment.\\end{center}\\begin{flushleft}Left-aligned text using a\\verb|flushleft| environment.\\end{flushleft}\\begin{flushright}Right-aligned text using a\\verb|flushright| environment.\\end{flushright}除此之外，还可以用以下命令直接改变文字的对齐方式：\\centering \\raggedright \\raggedleft。\\centeringCentered text paragraph.\\raggedrightLeft-aligned text paragraph.\\raggedleftRight-aligned text paragraph.三个命令和对应的环境经常被误用，有一点可以将两者区分开来：center 等环境会在上下文产生一个额外间距，而 \\centering 等命令不产生，只是改变对齐方式。比如在浮动体环境 table 或 figure 内实现居中对齐，用 \\centering 命令即可，没必要再用 center 环境。引用引用环境较一般文字有额外的左右缩进。quote 用于引用较短的文字，首行不缩进；quotation 用于引用若干段文字，首行缩进。Francis Bacon says:\\begin{quote}Knowledge is power.\\end{quote}《木兰诗》:\\begin{quotation}万里赴戎机，关山度若飞。朔气传金柝，寒光照铁衣。将军百战死，壮士十年归。归来见天子，天子坐明堂。策勋十二转，赏赐百千强。⋯⋯ \\end{quotation}verse 用于排版诗歌，与 quotation 恰好相反，verse 是首行悬挂缩进的。Rabindranath Tagore&#39;s short poem:\\begin{verse}Beauty is truth&#39;s smilewhen she beholds her own face ina perfect mirror.\\end{verse}摘要摘要环境 abstract 默认只在标准文档类中的 article 和 report 文档类可用，一般用于紧跟 \\maketitle 命令之后介绍文档的摘要。如果文档类指定了 titlepage 选项，则单独成页。代码将一段代码原样转义输出，可以用代码环境 verbatim，它以等宽字体排版代码，回车和空格也分别起到换行和空位的作用；带星号的版本更进一步将空格显示成 “␣”。\\begin{verbatim}#include &amp;lt;iostream&amp;gt;int main(){ std::cout &amp;lt;&amp;lt; &quot;Hello, world!&quot; &amp;lt;&amp;lt; std::endl;return 0; }\\end{verbatim}\\begin{verbatim*}for (int i=0; i&amp;lt;4; ++i) printf(&quot;Number %d\\n&quot;,i);\\end{verbatim*} 要排版简短的代码或关键字，可使用 \\verb 命令：\\verb⟨delim⟩⟨code⟩⟨delim⟩。⟨delim⟩ 标明代码的分界位置，前后必须一致，除字母、空格或星号外，可任意选择使得不与代码本身冲突，习惯上使用 符号。\\verb 后也可以带一个星号，以显示空格： \\verb|\\LaTeX| \\\\\\verb+(a || b)+ \\verb*+(a || b)+六、表格排版表格最基本的 tabular 环境用法为：\\begin{tabular}[⟨align⟩]{⟨column-spec⟩} ⟨item1⟩ &amp;amp; ⟨item2⟩ &amp;amp; ... \\\\\\hline⟨item1⟩ &amp;amp; ⟨item2⟩ &amp;amp; ... \\\\\\end{tabular}其中 ⟨column-spec⟩ 是列格式标记，在接下来的内容将仔细介绍；&amp;amp; 用来分隔单元格；\\\\ 用来换行；\\hline 用来在行与行之间绘制横线。通常情况下 tabular 环境很少与文字直接混排，而是会放在 table 浮动体环境中，并 用 \\caption 命令加标题。列格式 列格式 说明 l/c/r 单元格内容左对齐/居中/右对齐，不折行 p{⟨width⟩} 单元格宽度固定为 ⟨width⟩，可自动折行 | 绘制竖线 @{⟨string⟩} 自定义内容 ⟨string⟩ \\begin{tabular}{lcr|p{6em}} \\hline left &amp;amp; center &amp;amp; right &amp;amp; par box with fixed width \\\\ L &amp;amp; C &amp;amp; R &amp;amp; P \\\\ \\hline\\end{tabular}表格中每行的单元格数目不能多于列格式里 l/c/r/p 的总数（可以少于这个总数），否则出错。@ 格式可在单元格前后插入任意的文本，但同时它也消除了单元格前后额外添加的间距。@ 格式可以适当使用以充当“竖线”。特别地，@{} 可直接用来消除单元格前后的间距：\\begin{tabular}{@{} r@{:}lr @{}} \\hline 1 &amp;amp; 1 &amp;amp; one \\\\ 11 &amp;amp; 3 &amp;amp; eleven \\\\ \\hline\\end{tabular}LaTex 还提供了简便的将格式参数重复的写法 *{⟨n⟩}{⟨column-spec⟩}，比如以下两种写法是等效的:\\begin{tabular}{|c|c|c|c|c|p{4em}|p{4em}|}\\begin{tabular}{|*{5}{c|}*{2}{p{4em}|}}横线\\hline 用于绘制横线，\\cline{⟨i⟩-⟨j⟩} 用来绘制跨越部分横线单元格的横线。\\begin{tabular}{|c|c|c|} \\hline 4 &amp;amp; 9 &amp;amp; 2 \\\\ \\cline{2-3} 3 &amp;amp; 5 &amp;amp; 7 \\\\ \\cline{1-1} 8 &amp;amp; 1 &amp;amp; 6 \\\\ \\hline\\end{tabular}在科技论文排版中广泛应用的表格形式是三线表，形式干净简明。三线表由 booktabs 宏包支持，它提供了 \\toprule、\\midrule 和 \\bottomrule 命令用以排版三线表的三条线，以及和 \\cline 对应的 \\cmidrule。除此之外，最好不要用其它横线以及竖线：\\begin{tabular}{cccc} \\toprule &amp;amp; \\multicolumn{3}{c}{Numbers} \\\\ \\cmidrule{2-4} &amp;amp; 1 &amp;amp; 2 &amp;amp; 3 \\\\ \\midrule Alphabet &amp;amp; A &amp;amp; B &amp;amp; C \\\\ Roman &amp;amp; I &amp;amp; II&amp;amp; III \\\\ \\bottomrule\\end{tabular}合并单元格LaTex 是一行一行排版表格的，横向合并单元格较为容易，由 \\multicolumn 命令实现：\\multicolumn{⟨n⟩}{⟨column-spec⟩}{⟨item⟩}。 其中 ⟨n⟩ 为要合并的列数，⟨column-spec⟩ 为合并单元格后的列格式，只允许出现一个 l/c/r 或 p 格式。如果合并前的单元格前后带表格线 ，合并后的列格式也要带 以使得表格的竖线一致。 \\begin{tabular}{|c|c|c|} \\hline 1 &amp;amp; 2 &amp;amp; Center \\\\ \\hline \\multicolumn{2}{|c|}{3} &amp;amp; \\multicolumn{1}{r|}{Right} \\\\ \\hline 4 &amp;amp; \\multicolumn{2}{c|}{C} \\\\ \\hline\\end{tabular}上面的例子还体现了，形如 \\multicolumn{1}{⟨column-spec⟩}{⟨item⟩} 的命令可以用来修改某一个单元格的列格式。纵向合并单元格需要用到 multirow 宏包提供的 \\multirow 命令：\\multirow{⟨n⟩}{⟨width⟩}{⟨item⟩}，⟨width⟩ 为合并后单元格的宽度，可以填 * 以使用自然宽度。下面是一个结合 \\cline、\\multicolumn 和 \\multirow 的例子：\\begin{tabular}{ccc} \\hline \\multirow{2}{*}{Item} &amp;amp; \\multicolumn{2}{c}{Value} \\\\ \\cline{2-3} &amp;amp; First &amp;amp; Second \\\\ \\hline A &amp;amp; 1 &amp;amp; 2 \\\\ \\hline\\end{tabular}行距控制原生的表格看起来通常比较紧凑。修改参数 \\arraystretch 可以得到行距更加宽松的表格：\\renewcommand\\arraystretch{1.8}\\begin{tabular}{|c|} \\hline Really loose \\\\ \\hline tabular rows.\\\\ \\hline\\end{tabular}另一种增加间距的办法是给换行命令 \\ 添加可选参数，在这一行下面加额外的间距：\\begin{tabular}{c} \\hline Head lines \\\\[6pt] tabular lines \\\\ tabular lines \\\\ \\hline\\end{tabular}但是这种换行方式的存在导致了一个缺陷：表格的首个单元格不能直接使用中括号 []， 否则 \\ 往往会将下一行的中括号当作自己的可选参数，因而出错。如果要使用中括号，应当放在花括号 {} 里面。或者也可以选择将换行命令写成 \\[0pt]。七、图片LaTex 本身不支持插图功能，需要由 graphicx 宏包辅助支持。使用 latex + dvipdfmx 编译命令时，调用 graphicx 宏包时要指定 dvipdfmx 选项；而使用 pdflatex 或 xelatex 命令编译时不需要。各编译方式支持的主流图片格式： 格式 矢量图 位图 latex + dvipdfmx .eps n/a pdflatex .pdf .jpg .png xelatex .pdf .eps .jpg .png .bmp 在调用了 graphicx 宏包以后，就可以使用 \\includegraphics 命令加载图片了：\\includegraphics[⟨options⟩]{⟨filename⟩}，其中 ⟨filename⟩ 为图片文件名，与 \\include 命令的用法类似，文件名可能需要用相对路径或绝对路径表示。图片文件的扩展名一般可不写。另外 graphicx 宏包还提供了 \\graphicspath 命令，用于声明一个或多个图片文件存放的目录，使用这些目录里的图片时可不用写路径：% 假设主要的图片放在 pics 子目录下，标志放在 logo 子目录下\\graphicspath{ {pics/} {logo/} }\\includegraphics 命令的可选参数 ⟨options⟩ 支持 ⟨key⟩=⟨value⟩ 形式赋值，常用的参数如下： 参数 含义 width=⟨width⟩ 将图片缩放到宽度为 ⟨width⟩ height=⟨height⟩ 将图片缩放到高度为 ⟨height⟩ scale=⟨scale⟩ 将图片相对于原尺寸缩放 ⟨scale⟩ 倍 angle=⟨angle⟩ 令图片逆时针旋转 ⟨angle⟩ 度 八、盒子标尺盒子\\rule 命令用来画一个实心的矩形盒子，也可适当调整以用来画（(标尺）：\\rule[⟨raise⟩]{⟨width⟩}{⟨height⟩}。Black \\rule{12pt}{4pt} box.Upper \\rule[4pt]{6pt}{8pt} andlower \\rule[-4pt]{6pt}{8pt} box.A \\rule[-.4pt]{3em}{.4pt} line." }, { "title": "LaTex 符号", "url": "/posts/latex_character/", "categories": "language, latex", "tags": "latex", "date": "2021-08-22 00:00:00 +0800", "snippet": "[toc]本章介绍如何在 LaTex 中输入各种文字符号，包括标点符号等，以及控制文字断行和断页的方式。编码Unicode 是一个多国字符的集合，覆盖了几乎全球范围内的语言文字。UTF-8 是 Unicode 的一套编码方案，一个字符由一个到四个字节编码，其中单字节字符的编码与 ASCII 编码兼容。较为现代的 TEX 引擎，如 XƎTEX 和 LuaTEX，它们均原生支持 UTF-8 编码。使用 xelatex 和 lualatex 排版时，将源代码保存为 UTF-8 编码，并借助 fontspec 宏包调用适当的字体，原则上就可以在源代码中输入任意语言的文字。中文CJK 宏包对中文字体的支持比较麻烦，已经不再推荐直接使用。XƎTEX 和 LuaTEX 除了直接支持 UTF-8 编码外，还支持直接调用 TrueType / OpenType 格式的字体。xeCJK 及 luatexja 宏包则在此基础上封装了对汉字排版细节的处理功能。ctex 宏包和文档类进一步封装了 CJK、xeCJK、luatexja 等宏包，使得用户在排版中文时不用再考虑排版引擎等细节。ctex 宏包本身用于配合各种文档类排版中文，而 ctex 文档类对 LaTex 的标准文档类进行了封装，对一些排版根据中文排版习惯做了调整，包括 ctexart / ctexrep / ctexbook。ctex 宏包和文档类能够识别操作系统和 TEX 发行版中安装的中文字体，因此基本无需额外配置即可排版中文文档。下面举一个使用 ctex 文档类排版中文的最简例子:\\documentclass{ctexart}\\begin{document}在\\LaTeX{}中排版中文。 汉字和English单词混排，通常不需要在中英文之间添加额外的空格。 当然，为了代码的可读性，加上汉字和 English 之间的空格也无妨。 汉字换行时不会引入多余的空格。\\end{document}注意源代码须保存为 UTF-8 编码，并使用 xelatex 或 lualatex 命令编译。一、字符空格和分段 空格键和 Tab 键输入的空白字符视为“空格” 连续的若干个空白字符视为一个空格 一行开头的空格忽略不计 行末的换行符视为一个空格 连续两个换行符，也就是空行，会将文字分段 多个空行被视为一个空行 可以在行末使用 \\par 命令分段Several spaces equal one. Front spaces are ignored.An empty line starts a new paragraph.\\parA \\verb|\\par| command does the same.注释% 字符作为注释。在这个字符之后直到行末，所有的字符都被忽略，行末的换行符也不引入空格。This is an % short comment% ---% Long and organized% comments% ---example: Comments do not bre%ak a word.特殊字符# $ % &amp;amp; { } _ ^ ~ \\ 为特殊字符，无法直接输入，需要按照以下带反斜线方式输入：\\# \\$ \\% \\&amp;amp; \\{ \\} \\_ \\^{} \\~{} \\textbackslash其中 \\^ 和 \\~ 两个命令需要一个参数，加一对花括号的写法相当于提供了空的参数，否则它们可能会将后面的字符作为参数，形成重音效果。\\ 被直接定义成了手动换行的命令，输入反斜线就需要用 \\textbackslash。标点单引号 ‘ ’ 分别用 ` 和 ‘ 输入，双引号 “ 和” 分别用 `` 和 ‘’ 输入。``Please press the `x&#39; key.&#39;&#39;连字号(hyphen)、短破折号(en-dash)和长破折号(em-dash)。连字号 - 用来组成复合词；短破折号 – 用来连接数字表示范围，长破折号 — 用来连接单词，语义上类似中文的破折号。daughter-in-law, X-rated\\\\pages 13--67\\\\yes---or no?省略号：\\dots，\\ldots。one, two, three, \\dots one hundred.其它符号：LaTex 标志\\TeX\\LaTeX\\LaTeXe二、断行和断页LaTex 将文字段落在合适的位置进行断行，尽可能做到每行的疏密程度匀称，单词间距不会过宽或过窄。文字段落和公式、图表等内容从上到下顺序排布，并在合适的位置断页，分割成匀称的页面。在绝大多数时候，我们无需自己操心断行和断页。但偶尔会遇到需要手工调整的地方。单词间距西文排版实践中，断行的位置优先选取在两个单词之间，也就是在源代码中输入的“空格”。“空格”本身通常生成一个间距，它会根据行宽和上下文自动调整，文字密一些的地方，单词间距就略窄，反之略宽。文字在单词间的“空格”处断行时，“空格”生成的间距随之舍去。我们可以使用字符 ~ 输入一个不会断行的空格，通常用在英文人名、图表名称等上下文环境:Fig.~2a \\\\Donald~E. Knuth手动断行和断页断行命令：\\\\[⟨length⟩] % 可以带可选参数 ⟨length⟩，用于在断行处向下增加垂直间距，也在表格、公式等地方用于换行\\\\*[⟨length⟩] % 禁止在断行处分页\\newline % 不带可选参数，只用于文本段落中断页命令：\\newpage\\clearpage" }, { "title": "LaTex 基本概念", "url": "/posts/latex_basic/", "categories": "language, latex", "tags": "latex", "date": "2021-08-22 00:00:00 +0800", "snippet": "[toc]之前的章节说明了怎么安装 LaTex，如果觉着安装麻烦或者不想在本地安装，其实还有很多线上网站可以直接用。Overleaf 就是一个在线编辑 LaTex 的网站，注册之后可以免费使用，虽然免费帐户有些同步、编译的限制，但对普通用户来说够用了。之后的系列笔记我都会用 Overleaf 来测试，而系列笔记本身是对官方文档（一份(不太)简短的 LATEX2ε 介绍）的一个精减提炼。一、 Hello World话不多说，先上两个 hello world。\\documentclass{article}\\begin{document}``Hello world!&#39;&#39; from \\LaTeX.\\end{document}\\documentclass{ctexart}\\begin{document}“你好，世界!”来自 \\LaTeX{} 的问候。\\end{document}在使用中文时，需要注意编译器要选 XeLaTex，不然会编译失败。二、命令和结构LaTex 的源代码为文本文件。这些文本除了文字本身，还包括各种命令，用在排版公式、划分文档结构、控制样式等等不同的地方。命令形式LaTex 命令大小写敏感，以反斜线 \\ 开头，为以下两种形式之一： 反斜线和后面的一串字母，如 \\LaTeX，它们以任意非字母符号（空格、数字、标点等）为界限。 反斜线和后面的单个非字母符号，如 \\$。忽略空格字母形式的命令忽略其后的所有连续空格。如果要人为引入空格，需要在命令后面加一对花括号阻止其忽略空格。Shall we call ourselves \\TeX usersor \\TeX{} users?命令参数命令可以接收一些参数，参数的内容会影响命令的效果。参数分为可选参数和必选参数： 可选参数以方括号 [ 和 ] 包裹 必选参数一般以花括号 { 和 } 包裹 带星号 * 命令，带星号和不带星号的命令效果有一定差异环境环境用以令一些效果在局部生效，或是生成特殊的文档元素，用法为一对命令 \\begin 和 \\end:\\begin{⟨environment name⟩}[⟨optional arguments⟩]{⟨mandatory arguments⟩}...\\end{⟨environment name⟩}分组有些命令会对其后所有内容产生作用。若要限制其作用范围，则需要使用分组。使用一对花括号 { 和 } 作为分组，在分组中使用的命令被限制在分组内，不会影响到分组外的内容。代码结构LaTex 源码以一个 \\documentclass 命令作为开头，它指定了文档使用的文档类。document 环境当中的内容是文档正文。在 \\documentclass 和 \\begin{document} 之间的位置称为导言区。在导言区中一般会使用 \\usepackage 命令调用宏包，以及进行文档的全局设置。\\documentclass{...} % ... 为某文档类 % 导言区\\begin{document}% 正文内容\\end{document}% 此后内容会被忽略三、文档类和宏包文档类文档类规定了源码所要生成的文档类型：普通文章、书籍、演示文稿、个人简历等等。语法为：\\documentclass[⟨options⟩]{⟨class-name⟩}。LaTex 提供的标准文档类有以下三种： article：文章格式的文档类，广泛用于科技论文、报告、说明文档等。 report：长篇报告格式的文档类，具有章节结构，用于综述、长篇论文、简单的书籍等。 book：书籍文档类，包含章节结构和前言、正文、后记等结构。可选参数 ⟨options⟩ 为文档类指定选项，以全局地规定一些排版的参数，如字号、纸张大小、 单双面等等。比如调用 article 文档类排版文章，指定纸张为 A4 大小，基本字号为 11pt，双面排版：\\documentclass[11pt,twoside,a4paper]{article}。标准文档类可指定选项： 10pt, 11pt, 12pt：指定文档的基本字号。默认为 10pt。 a4paper, letterpaper, …：指定纸张大小，默认为美式信纸 letterpaper (8.5 × 11 英寸)。 可指定选项还包括 a5paper，b5paper，executivepaper 和 legalpaper。 twoside, oneside：指定单面/双面排版。双面排版时，奇偶页的页眉页脚、页边距不同。article 和 report 默认为 oneside，book 默认为 twoside onecolumn, twocolumn：指定单栏/双栏排版。默认为 onecolumn。 openright, openany：指定新的一章 \\chapter 是在奇数页（右侧）开始，还是直接紧跟着上一页开始。report 默认为 openany，book 默认为 openright。对 article 无效。 landscape：指定横向排版。默认为纵向。 titlepage, notitlepage：指定标题命令 \\maketitle 是否生成单独的标题页。article 默认为 notitlepage，report 和 book 默认为 titlepage。 fleqn：令行间公式左对齐。默认为居中对齐。 leqno：将公式编号放在左边。默认为右边。 draft, final：指定草稿/终稿模式。草稿模式下，断行不良的地方会在行尾添加一个黑色方 块。默认为 final。宏包在使用 LaTex 时，时常需要依赖一些扩展来增强或补充 LaTex 的功能，比如排版复杂的表 格、插入图片、增加颜色甚至超链接等等。这些扩展称为宏包。调包语法：\\usepackage[⟨options⟩]{⟨package-name⟩}。帮助语法：texdoc ⟨pkg-name⟩。四、文件类型LaTex 源码是以 .tex 为后缀的文本文件，但在 LaTex 使用和编译过程中还会遇到很多其它后缀的文件，对应文件的说明如下： .sty 宏包文件。宏包的名称与文件名一致。 .cls 文档类文件。文档类名称与文件名一致。 .bib BIBTEX 参考文献数据库文件。 .bst BIBTEX 用到的参考文献格式模板。 .log 排版引擎生成的日志文件，供排查错误使用。 .aux LATEX 生成的主辅助文件，记录交叉引用、目录、参考文献的引用等。 .toc LATEX 生成的目录记录文件。 .lof LATEX 生成的图片目录记录文件。 .lot LATEX 生成的表格目录记录文件。 .bbl BIBTEX 生成的参考文献记录文件。 .blg BIBTEX 生成的日志文件。 .idx LATEX 生成的供 makeindex 处理的索引记录文件。 .ind makeindex 处理 .idx 生成的用于排版的格式化索引文件。 .ilg makeindex 生成的日志文件。 .out hyperref 宏包生成的 PDF 书签记录文件。五、文件组织当编写长篇文档时，例如当编写书籍、毕业论文时，单个源文件会使修改、校对变得十分困难。将源文件分割成若干个文件，例如将每章内容单独写在一个文件中，会大大简化修改和校对的工作。命令 \\include 用来在源代码里插入文件:\\include{⟨filename⟩}\\include{chapters/a.tex} % 相对路径\\include{/home/Bob/file.tex} % 绝对路径命令 \\include 在读入文件之前会另起一页，但有时我们并不想这样，而是用 \\input 命令进行插入：\\input{⟨filename⟩}。最后工具宏包 syntonly 可令 LaTex 编译后不生成 DVI 或者 PDF 文档，只排查错误，编译速度会快不少。\\usepackage{syntonly}\\syntaxonly六、术语和概念 引擎 ​ 全称为排版引擎，是编译源代码并生成文档的程序，如 pdfTEX、XƎTEX 等。有时也称为编译器。 格式 ​ 定义了一组命令的代码集。LaTex 就是最广泛应用的一个格式。 编译命令 ​ 实际调用的、结合了引擎和格式的命令。如 xelatex 命令是结合 XƎTEX 引擎和 LaTex 格式的一个编译命令。 几个编译命令的特点： latex ​ 虽然名为 latex 命令，底层调用的引擎其实是 pdfTEX。该命令生成 dvi(Device Inde-pendent) 格式的文档，用 dvipdfmx 命令可以将其转为 pdf。 pdflatex ​ 底层调用的引擎也是 pdfTEX，可以直接生成 pdf 格式的文档。 xelatex ​ 底层调用的引擎是 XƎTEX，支持 UTF-8 编码和对 TrueType / OpenType 字体的调用。 当前较为方便的中文排版解决方案基于 xelatex。 lualatex ​ 底层调用的引擎是 LuaTEX，这个引擎在 pdfTEX 引擎基础上发展而来，除了支持 UTF-8 编码和对 TrueType / OpenType 字体的调用外，还支持通过 Lua 语言扩展 TEX 的功能。lualatex 编译命令下的中文排版支持需要借助 luatexja 宏包。 " }, { "title": "LaTex 介绍及安装", "url": "/posts/latex_install/", "categories": "language, latex", "tags": "latex", "date": "2021-08-09 00:00:00 +0800", "snippet": "LaTex 是基于 Tex 的排版系统，适用于生成高印刷质量的科技、数学和物理文档（用来发 paper）。首先说下 Tex 是个啥，Tex 其实是个软件，它是由美国的计算机教授高德纳编写，用来给计算机、物理、数学等科学界学术文档进行排版的软件。高德纳最早开始自行编写 TeX 的原因，是由于当时的电脑排版技术十分粗糙，已经影响到他的巨著《计算机程序设计艺术》的印刷质量。因此他以典型的黑客思维模式，决定自行编写一个排版软件：TeX。Tex 的版本号也非常极客，以 π 作为版本号，每次升级都会在当前版本号后增加一位数字，使其越来越接近 π。Tex 当前的版本号是 3.141592653。再说下 LaTex 又是个啥，LaTex 是 Tex 中的一种格式，是建立在 Tex 基础上的宏语言，每一个 LaTex 命令最终都会被解释为 Tex 命令，可以简单理解为 LaTex 是对 Tex 软件命令的封装，这种封装是为了方便人们使用。LaTex 根据常见的排版习惯，定义了许多命令和模板，通过这些命令和模板，我们可以很快的得到漂亮的排版结果。从使用者的角度，我认为理解上边的概念就可以了。如果我想要写一篇排版精美的文档或者论文，那么我通过遵从 LaTex 的语法，按照对应的语法写出我的文章后，利用 LaTex 去排版我的文章生成 pdf 就可以了。至于具体底层的原理就交给专业的人员去做吧。所以，最终想要利用 LaTex 进行写作和排版，我们需要安装：Tex、LaTex 和 一款趁手的编辑器（vim、vs-code 或者一些专门为 LaTex 开发的编辑器）。下边是以 Linux 平台为例的安装步骤，在树莓派上安装步骤也跟下边一样。1. 安装准备Getting LaTeX 给了各平台的 LaTex 发行版安装程序和镜像地址。 Linux：Tex Live Mac：MacTex Windows：MikTexLinux 平台下不同发行版的软件源虽然包含 LaTex，但是大多数发行版都是包含的旧版本 LaTex，譬如 Ubuntu 20.04 源中包含了 2019 版的 LaTex， Raspbian Stable 包含的是 2018 版 LaTex。因此，并不推荐从软件源直接安装 LaTex，而是通过 Tex Live 进行安装。Tex Live 是 Tex 及其相关程序在 GNU/Linux 及其他类 Unix 系统、Mac OS X 和 Windows 系统下的一套发行版，包括了 Tex, LaTex2ε, ConTEXt, METAFONT, MetaPost, BibTEX 等许多可执行程序；种类繁多的宏包、字体和文档，并支持世界上许多不同的语言。所以，通过安装 Tex Live，就可以满足我们的需求。Tex Live 通过网络进行安装，其安装程序是一个 5M 左右的压缩包，安装指南中有详尽的安装步骤，按照指南中的步骤来就可以，不是很难，也有中文版。2. 安装 Tex Live安装程序下载完成并解压后，在其根目录下有个名为 install-tl 的可执行 perl 脚本，直接在命令行输入 sudo ./install-tl 就可以启动安装程序。Linux 默认会启动文本形式的安装节目，这个不需要 gui 就可以直接在 terminal 中进行操作。文本界面如下，需要输入对应的字母来进行配置。======================&amp;gt; TeX Live installation procedure &amp;lt;===========================&amp;gt; Letters/digits in &amp;lt;angle brackets&amp;gt; indicate &amp;lt;=============&amp;gt; menu items for actions or customizations &amp;lt;======== help&amp;gt; https://tug.org/texlive/doc/install-tl.html &amp;lt;======= Detected platform: GNU/Linux on x86_64 &amp;lt;B&amp;gt; set binary platforms: 1 out of 16 &amp;lt;S&amp;gt; set installation scheme: scheme-full &amp;lt;C&amp;gt; set installation collections: 40 collections out of 41, disk space required: 7231 MB &amp;lt;D&amp;gt; set directories: TEXDIR (the main TeX directory): /usr/local/texlive/2021 TEXMFLOCAL (directory for site-wide local files): /usr/local/texlive/texmf-local TEXMFSYSVAR (directory for variable and automatically generated data): /usr/local/texlive/2021/texmf-var TEXMFSYSCONFIG (directory for local config): /usr/local/texlive/2021/texmf-config TEXMFVAR (personal directory for variable and automatically generated data): ~/.texlive2021/texmf-var TEXMFCONFIG (personal directory for local config): ~/.texlive2021/texmf-config TEXMFHOME (directory for user-specific files): ~/texmf &amp;lt;O&amp;gt; options: [ ] use letter size instead of A4 by default [X] allow execution of restricted list of programs via \\write18 [X] create all format files [X] install macro/font doc tree [X] install macro/font source tree [ ] create symlinks to standard directories &amp;lt;V&amp;gt; set up for portable installationActions: &amp;lt;I&amp;gt; start installation to hard disk &amp;lt;P&amp;gt; save installation profile to &#39;texlive.profile&#39; and exit &amp;lt;Q&amp;gt; quitEnter command: 输入 b，可以进到平台选择界面，默认的检测结果应该是准确的。===============================================================================Available platforms: a [ ] Cygwin on Intel x86 (i386-cygwin) b [ ] Cygwin on x86_64 (x86_64-cygwin) c [ ] MacOSX current (10.14-) on ARM/x86_64 (universal-darwin) d [ ] MacOSX legacy (10.6-) on x86_64 (x86_64-darwinlegacy) e [ ] FreeBSD on x86_64 (amd64-freebsd) f [ ] FreeBSD on Intel x86 (i386-freebsd) g [ ] GNU/Linux on ARM64 (aarch64-linux) h [ ] GNU/Linux on ARMv6/RPi (armhf-linux) i [ ] GNU/Linux on Intel x86 (i386-linux) j [X] GNU/Linux on x86_64 (x86_64-linux) k [ ] GNU/Linux on x86_64 with musl (x86_64-linuxmusl) l [ ] NetBSD on x86_64 (amd64-netbsd) m [ ] NetBSD on Intel x86 (i386-netbsd) o [ ] Solaris on Intel x86 (i386-solaris) p [ ] Solaris on x86_64 (x86_64-solaris) s [ ] Windows (win32)Actions: (disk space required: 7231 MB) &amp;lt;-&amp;gt; deselect all &amp;lt;+&amp;gt; select all &amp;lt;R&amp;gt; return to main menu &amp;lt;Q&amp;gt; quitEnter letter(s) to (de)select platforms: 输入 s，可以进到方案选择界面，从这里可以选择一套 “安装方案”，也就是对软件包集合的一个统一划分。===============================================================================Select scheme: a [X] full scheme (everything) b [ ] medium scheme (small + more packages and languages) c [ ] small scheme (basic + xetex, metapost, a few languages) d [ ] basic scheme (plain and latex) e [ ] minimal scheme (plain only) f [ ] ConTeXt scheme g [ ] GUST TeX Live scheme h [ ] infrastructure-only scheme (no TeX at all) i [ ] teTeX scheme (more than medium, but nowhere near full) j [ ] custom selection of collectionsActions: (disk space required: 7231 MB) &amp;lt;R&amp;gt; return to main menu &amp;lt;Q&amp;gt; quitEnter letter to select scheme: 输入 c，可以进到集合选择界面，collection (安装集合) 是比 scheme (方案) 要更细的一层，实际上一个方案包含了多个集合，而一个集合又包含了一到多个软件包，然后每个软件包 (Tex Live 中最小的组织单位) 则包含了实际的 Tex 宏文件，字体文件，等等。如果觉得 collection 菜单对安装控制还不够细，可以在安装后使用 Tex Live Manager (tlmgr) 程序，它能在软件包一层控制安装。在集合选择界面，我选择了：abclmDFGJOP，具体每个集合是什么作用，可以参考 Tex Live宏包集合和自定义安装。===============================================================================Select collections: a [X] Essential programs and files w [ ] Italian b [X] BibTeX additional styles x [ ] Japanese c [X] TeX auxiliary programs y [ ] Korean d [ ] ConTeXt and packages z [ ] Other languages e [ ] Additional fonts A [ ] Polish f [ ] Recommended fonts B [ ] Portuguese g [ ] Graphics and font utilities C [ ] Spanish h [ ] Additional formats D [X] LaTeX fundamental packages i [ ] Games typesetting E [ ] LaTeX additional packages j [ ] Humanities packages F [X] LaTeX recommended packages k [ ] Arabic G [X] LuaTeX packages l [X] Chinese H [ ] MetaPost and Metafont packages m [X] Chinese/Japanese/Korean (base) I [ ] Music packages n [ ] Cyrillic J [X] Graphics, pictures, diagrams o [ ] Czech/Slovak K [ ] Plain (La)TeX packages p [ ] US and UK English L [ ] PSTricks s [ ] Other European languages M [ ] Publisher styles, theses, etc. t [ ] French N [ ] Windows-only support programs u [ ] German O [X] XeTeX and packages v [ ] Greek P [X] Mathematics, natural sciences, computer science packages S [ ] TeXworks editor; TL includes only the Windows binaryActions: (disk space required: 1866 MB) &amp;lt;-&amp;gt; deselect all &amp;lt;+&amp;gt; select all &amp;lt;R&amp;gt; return to main menu &amp;lt;Q&amp;gt; quitEnter letter(s) to (de)select collection(s): 最后在 main menu 中输入 i 进行安装。3. 安装后的操作安装完 Tex Live 后，还有两个操作需要处理：环境变量配置、系统字体配置。默认安装配置下没有勾选最后一项创建符号连接，那么就需要手动添加 LaTex 相关的程序路径到 PATH。 &amp;lt;O&amp;gt; options: [ ] use letter size instead of A4 by default [X] allow execution of restricted list of programs via \\write18 [X] create all format files [X] install macro/font doc tree [X] install macro/font source tree [ ] create symlinks to standard directories添加以下命令到对象的 shrc 中，具体路径需要根据自己系统上的路径和安装版本做调整。export PATH=/usr/local/texlive/2021/bin/x86_64-linux:$PATHexport MANPATH=/usr/local/texlive/2021/texmf-dist/doc/man:$MANPATHexport INFOPATH=/usr/local/texlive/2021/texmf-dist/doc/info:$INFOPATHXeTex 和 LuaTex 可以使用任何系统安装的字体，而不只是 Tex 目录树中的那些，但在 Linux 下需要把系统按如下配置一番 XeTex 才能找到随 Tex Live 安装的那些字体。XeTex 安装后会在 TEXMFSYSVAR/fonts/conf/texlive-fontconfig.conf 创建一个必需的配置文件。（TEXMFSYSVAR：/usr/local/texlive/2021/texmf-var）要在整个系统中使用 Tex Live 的字体，需要： sudo 将 texlive-fontconfig.conf 文件复制到 /etc/fonts/conf.d/09-texlive.conf 运行 sudo fc-cache-fsv 如果你没有足够的权限执行上述操作，或者只需要把 Tex Live 字体提供给自己用，可以这么做: 将 texlive-fontconfig.conf 文件复制到 ~/.fonts.conf 运行 fc-cache-fvTex Live 包含一个叫 tlmgr 的程序，它可以用来管理安装后的系统。它的功能包括:• 列出方案 (scheme)，集合和安装包;• 安装、升级、备份、恢复、卸载软件包，并且能自动计算依赖关系;• 查找和列出软件包以及它们的描述;• 列出、添加和删除不同平台的可执行文件;• 改变安装选项，比如纸张大小和源文件位置。4. 测试安装结果## 查看版本$ tex --versionTeX 3.141592653 (TeX Live 2021)kpathsea version 6.3.3Copyright 2021 D.E. Knuth.There is NO warranty. Redistribution of this software iscovered by the terms of both the TeX copyright andthe Lesser GNU General Public License.For more information about these matters, see the filenamed COPYING and the TeX source.Primary author of TeX: D.E. Knuth.## 处理样例，生成结果$ latex sample2e.texThis is pdfTeX, Version 3.141592653-2.6-1.40.23 (TeX Live 2021) (preloaded format=latex) restricted \\write18 enabled.entering extended mode(/usr/local/texlive/2021/texmf-dist/tex/latex/base/sample2e.texLaTeX2e &amp;lt;2021-06-01&amp;gt; patch level 1L3 programming layer &amp;lt;2021-07-12&amp;gt;(/usr/local/texlive/2021/texmf-dist/tex/latex/base/article.clsDocument Class: article 2021/02/12 v1.4n Standard LaTeX document class(/usr/local/texlive/2021/texmf-dist/tex/latex/base/size10.clo))(/usr/local/texlive/2021/texmf-dist/tex/latex/l3backend/l3backend-dvips.def)No file sample2e.aux.(/usr/local/texlive/2021/texmf-dist/tex/latex/base/omscmr.fd) [1] [2] [3](./sample2e.aux) )Output written on sample2e.dvi (3 pages, 7576 bytes).Transcript written on sample2e.log.## 即时预览结果$ xdvi sample2e.dvi" }, { "title": "JNI", "url": "/posts/jni/", "categories": "language, java", "tags": "jni", "date": "2021-08-03 00:00:00 +0800", "snippet": "看代码的时候碰到个 System.identityHashCode(obj)，没见过，更没用过。直接看了下 doc，描述如下： Returns the same hash code for the given object as would be returned by the default method hashCode(), whether or not the given object’s class overrides hashCode(). The hash code for the null reference is zero.Params: x – object for which the hashCode is to be calculatedReturns: the hashCodeSince: 1.1意思是说，不管传进去的参数类有没有重写过 hashcode 方法，identityHashCode 都会返回其默认的 Object.hashcode() 返回值。那么它有什么用呢？这里给了答案：When to use System.identityhashcode() and hashcode() method?简单来说，当一个类重写了 equal 和 hashcode 方法，它多个实例的 hashcode 是可能返回相同值的，当我需要区分不同的实例时，就可以用 identityHashCode 方法。在搜索用法的时候发现了另一篇文章，对 identityHashCode 的底层实现也给了说明，是有关 JNI 的。所以我又看了下 JNI 相关的两篇文章，做个备忘。System.identityHashCode(obj) 与 obj.hashcode() - 简书 (jianshu.com)使用JNI（Java Native Interface）的总结 - 简书 (jianshu.com)Jni教程（一）—Linux下jni调用 - 简书 (jianshu.com)1. 自顶向下 JNI看 Java 工程源码时，遇到各种 API 都可以在 IDE 里通过鼠标点击进行跳转，但有的时候跳转到 native 方法就没法再往下看了。譬如上边的 identityHashCode 方法，它只有下边这么一个声明，并没有具体的实现。@HotSpotIntrinsicCandidatepublic static native int identityHashCode(Object x);其实，它并不是没有具体实现，而是 native 方法都是通过 c 或者 c++ 来实现的。native 方法大体可以这么理解：在 jdk 的 java 代码中定义接口（头文件），然后在 c、c++ 中实现接口（实现头文件中定义的方法）。要查看 native 方法的实现，就需要下载 jdk 的源码。在 jdk 源码里有各个平台的 c、c++ 实现。源码可以从这里下载：JDK Builds from Oracle (java.net)，选择不同的 jdk 版本之后，在 RI Source Code 有源码下载链接。我下载的 jdk 11，跟 identityHashCode 实现相关的文件路径如下：1) openjdk/src/java.base/share/native/libjava/System.c，是 Java_java_lang_System_identityHashCode 的实现。（可以看出来 c 中的方法名和 java 中的方法名不一样，转换规则可以参考这里：【转】对于JNI方法名，数据类型和方法签名的一些认识 - InfantSorrow - 博客园 (cnblogs.com)） JNIEXPORT jint JNICALL Java_java_lang_System_identityHashCode(JNIEnv *env, jobject this, jobject x) { return JVM_IHashCode(env, x); }上边的方法里调用了 jvm 的 JVM_IHashCode 方法。2) openjdk/src/hotspot/share/prims/jvm.cpp，给出了 JVM_IHashCode 的实现，它又调用了 ObjectSynchronizer::FastHashCode。 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle)) JVMWrapper(&quot;JVM_IHashCode&quot;); // as implemented in the classic virtual machine; return 0 if object is NULL return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ; JVM_END3) openjdk/src/hotspot/share/runtime/synchronizer.cpp，最终的 hashcode 实现。 intptr_t ObjectSynchronizer::FastHashCode(Thread * Self, oop obj) { ... hash = get_next_hash(Self, obj); // allocate a new hash code ... } static inline intptr_t get_next_hash(Thread * Self, oop obj) { intptr_t value = 0; if (hashCode == 0) { // This form uses global Park-Miller RNG. // On MP system we&#39;ll have lots of RW access to a global, so the // mechanism induces lots of coherency traffic. value = os::random(); } else if (hashCode == 1) { // This variation has the property of being stable (idempotent) // between STW operations. This can be useful in some of the 1-0 // synchronization schemes. intptr_t addrBits = cast_from_oop&amp;lt;intptr_t&amp;gt;(obj) &amp;gt;&amp;gt; 3; value = addrBits ^ (addrBits &amp;gt;&amp;gt; 5) ^ GVars.stwRandom; } else if (hashCode == 2) { value = 1; // for sensitivity testing } else if (hashCode == 3) { value = ++GVars.hcSequence; } else if (hashCode == 4) { value = cast_from_oop&amp;lt;intptr_t&amp;gt;(obj); } else { // Marsaglia&#39;s xor-shift scheme with thread-specific state // This is probably the best overall implementation -- we&#39;ll // likely make this the default in future releases. unsigned t = Self-&amp;gt;_hashStateX; t ^= (t &amp;lt;&amp;lt; 11); Self-&amp;gt;_hashStateX = Self-&amp;gt;_hashStateY; Self-&amp;gt;_hashStateY = Self-&amp;gt;_hashStateZ; Self-&amp;gt;_hashStateZ = Self-&amp;gt;_hashStateW; unsigned v = Self-&amp;gt;_hashStateW; v = (v ^ (v &amp;gt;&amp;gt; 19)) ^ (t ^ (t &amp;gt;&amp;gt; 8)); Self-&amp;gt;_hashStateW = v; value = v; } value &amp;amp;= markOopDesc::hash_mask; if (value == 0) value = 0xBAD; assert(value != markOopDesc::no_hash, &quot;invariant&quot;); TEVENT(hashCode: GENERATE); return value; }以上就是怎么去看 native 方法的实现。2. 自底向上 JNI当我想要自己实现一个 native 方法时，应该怎么做呢？在这部分给出一个最简单的例子。总共分为两个大步骤：声明接口（生成头文件）、实现接口（编译 so/dll）。2.1 声明接口 先创建一个最简单的 Java 项目，结构和代码如下，这一步只关注 java 代码，先不用关心 .h .so .c 和 makefile。 LocalLib 中声明了 sayHi 方法，加载了 locallib 这个我们将在后边生成的动态链接库。 package com.cy; public class LocalLib { static{ System.loadLibrary(&quot;locallib&quot;); } public static native void sayHi();} JniMain 调用了 LocalLib 的 sayHi 方法。 package com.cy; public class JniMain { public static void main(String[] args) { LocalLib.sayHi(); }} 在 src 目录下，也就是 com 同级的目录下使用 javah 命令生成头文件。 $ javah com.cy.LocalLib 执行完以上命令，会在同一目录下生成 com_cy_LocalLib.h 头文件，其内容声明了 sayHi 方法。 /* DO NOT EDIT THIS FILE - it is machine generated */#include &amp;lt;jni.h&amp;gt;/* Header for class com_cy_LocalLib */ #ifndef _Included_com_cy_LocalLib#define _Included_com_cy_LocalLib#ifdef __cplusplusextern &quot;C&quot; {#endif/* * Class: com_cy_LocalLib * Method: sayHi * Signature: ()V */JNIEXPORT void JNICALL Java_com_cy_LocalLib_sayHi (JNIEnv *, jclass); #ifdef __cplusplus}#endif#endif 这样程序主体搭建和 native 接口声明就完成了。2.2 实现接口实现接口就是实现 com_cy_LocalLib.h 头文件里声明的方法。 创建 LocalLib.c 文件，在其中包含 com_cy_LocalLib.h 头文件，并实现 sayHi 方法。 #include &amp;lt;stdio.h&amp;gt;#include &quot;com_cy_LocalLib.h&quot; JNIEXPORT void JNICALL Java_com_cy_LocalLib_sayHi(JNIEnv *, jclass) { printf(&quot;Hi World!\\n&quot;);} 创建 makefile，不同平台的写法不同，下边是 Linux 的写法。 liblocallib.so : LocalLib.c g++ -o $@ $+ -fPIC -shared -I/usr/lib/jvm/java-11-openjdk-amd64/include -I/usr/lib/jvm/java-11-openjdk-amd64/include/linux .PHONY : cleanclean : -rm liblocallib.so 生成 so 动态链接库（Windows 下是 dll），生成动态链接库需要相应的工具链：make 和 g++。Ubuntu 通过命令：sudo apt install build-essential 进行安装。 $ make make 之后会在目录下生成一个 liblocallib.so 的文件，这个就是包含了 sayHi 方法的动态链接库。 2.3 运行在 idea 里运行的话，把 so 的路径加到 vm 参数 -Djava.library.path 就可以了，譬如：-Djava.library.path=/home/enchyaa/Coding/jni/src。/usr/lib/jvm/java-11-openjdk-amd64/bin/java -Djava.library.path=/home/cy/Coding/jni/src -javaagent:/opt/idea-IC-212.4746.92/lib/idea_rt.jar=45911:/opt/idea-IC-212.4746.92/bin -Dfile.encoding=UTF-8 -classpath /home/cy/Coding/jni/out/production/jni com.cy.JniMainHi World!Process finished with exit code 0" }, { "title": "gist", "url": "/posts/gist/", "categories": "tool", "tags": "gist", "date": "2021-08-02 00:00:00 +0800", "snippet": "gist 是用来共享代码、片段的平台，它的操作非常简单，只需要粘贴上自己想要分析的内容，点下鼠标再把链接分享给其他人就可以了，一如它的 slogan。 Instantly share code, notes, and snippets.但 gist 其实还有一些有趣的用法，下边的文章里列了 10 种 gist 用法，挺有意思的。What You Can Do With Gists on Github? - Digital Inspiration (labnol.org)1. 匿名分享Create secret gist，用来创建匿名分享，这个匿名是针对搜索引擎。也就是说这个 gist 片段搜索不到，只能通过链接的方式访问。3. 富文本文档可以用来分享 Markdown 文档，记得文件名要带上正确的后缀，否则不能识别。5. 托管单个页面Bl.ocks 是一个为 gist 开发的有趣应用。可以用纯文本把 HTML、CSS、JavaScript 代码写下来以 index.html 为文件名保存为 gist，然后用 Bl.ocks 把渲染好的结果在浏览器中展示出来。譬如：这个 gist 的展示 结果。6. 任务列表利用 Markdown 的语法实现在线的 todo list，语法如下。- [ ] a task list item- [ ] list syntax required- [ ] normal **formatting**, @mentions, #1234 refs- [ ] incomplete- [x] completed效果见这里：A Markdown todo list. (github.com)7. 网页收藏夹Chrome 浏览器的 GistBox 插件保存网页内容为 gist。8. 嵌入网页一行 js 代码就可以把任何一条 gist 嵌入到网页中。" }, { "title": "树莓派连接 Wi-Fi", "url": "/posts/enterprise_wpa2/", "categories": "pi", "tags": "wpa2", "date": "2021-08-02 00:00:00 +0800", "snippet": "树莓派 官方文档 提供了在没有外设的情况下 开启 ssh 和 连接 wifi 的配置说明，但是没有说明如何连接 WPA2-Enterprise Wi-Fi，在 Raspberry Pi OS 界面上也无法直接连接（图标是灰色的）。搜索到以下两篇文章，第二篇适用于我的情况。树莓派 3B+ 连接 WPA2 企业级加密的 WIFI树莓派链接WPA2-Enterprise（企业级加密）WIFI我的可用配置如下，reboot 后可以连接并正常访问网络。## /etc/wpa_supplicant/wpa_supplicant.confctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1country=CNnetwork={ ssid=&quot;your_AP_name&quot; key_mgmt=WPA-EAP eap=PEAP identity=&quot;your_username&quot; password=&quot;password&quot; phase1=&quot;peaplabel=auto pepver=auto&quot; phase2=&quot;MSCHAPV2&quot; proactive_key_caching=1}" }, { "title": "serialVersionUID 和 Runtime", "url": "/posts/serialversionuid_runtime_process/", "categories": "language, java", "tags": "", "date": "2021-08-02 00:00:00 +0800", "snippet": "关于 serialVersionUID、Runtime、ProcessBuilder 的三篇教程，serialVersionUID 和后两者没啥关系，不想开新帖了，就写在一起。 [What is the serialVersionUID? Baeldung](https://www.baeldung.com/java-serial-version-uid) Java.lang.Runtime class in Java - GeeksforGeeks [Guide to java.lang.ProcessBuilder API Baeldung](https://www.baeldung.com/java-lang-processbuilder-api) Serial Version UID Simply put, we use the serialVersionUID attribute to remember versions of a Serializable class to verify that a loaded class and the serialized object are compatible.简单来说：serialVersionUID 是用来校验反序列化的类和内存里已加载的类是否兼容的。具体过程：1) 类进行序列化时 serialVersionUID 会被写到文件中，如果没有这个值，虚拟机也会自动生成一个。 If serialVersionUID is not provided in a Serializable class, the JVM will generate one automatically. However, it is good practice to provide the serialVersionUID value and update it after changes to the class so that we can have control over the serialization/deserialization process.2) 一个类经过序列化后，它会以一个文件的方式存在于磁盘或者网络中。经过一段时间之前的代码发生了更新，同一个类增加或者删除了某个属性。这时候如果开发人员认为跟更改之前不兼容了，那么就需要更新 serialVersionUID；如果认为依然兼容之前的类，那么开发人员可以保持 serialVersionUID 不变。3) 类文件反序列化时，虚拟机检查文件中的 serialVersionUID，判断它是否与当前类的 serialVersionUID 一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。生成方式： 默认的1L，比如：private static final long serialVersionUID = 1L; 根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如：private static final long serialVersionUID = xxxxL; Runtime Every Java application has a single instance of class Runtime that allows the application to interface with the environment in which the application is running. The current runtime can be obtained from the getRuntime method.Runtime 是一个封装了 JVM 进程的类。每一个 Java 应用实际上都是启动了一个 JVM 进程，每一个 JVM 进程就是一个 Runtime 实例。Runtime 实例可以用来与所在运行环境进行交互，譬如：获取计算机资源、执行 shell 命令等。下边是教程中的几个例子：// 获取当前空闲内存public class GFG{ public static void main(String[] args) { // get the current runtime assosiated with this process Runtime run = Runtime.getRuntime(); // print the current free memory for this runtime System.out.println(&quot;&quot; + run.freeMemory()); }}// linux 下打开 chromepublic class GFG{ public static void main(String[] args) { try { // create a process and execute google-chrome Process process = Runtime.getRuntime().exec(&quot;google-chrome&quot;); System.out.println(&quot;Google Chrome successfully started&quot;); } catch (Exception e) { e.printStackTrace(); } }}// 程序退出时打印新的 Messagepublic class GFG{ // a class that extends thread that is to be called when program is exiting static class Message extends Thread { public void run() { System.out.println(&quot;Program exiting&quot;); } } public static void main(String[] args) { try { // register Message as shutdown hook Runtime.getRuntime().addShutdownHook(new Message()); // cause thread to sleep for 3 seconds System.out.println(&quot;Waiting for 5 seconds...&quot;); Thread.sleep(5000); } catch (Exception e) { e.printStackTrace(); } }}// 执行命令public class GFG{ public static void main(String[] args) { try { String[] cmd = new String[2]; cmd[0] = &quot;atom&quot;; cmd[1] = &quot;File.java&quot;; // create a process and execute cmdArray Process process = Runtime.getRuntime().exec(cmd); // print another message System.out.println(&quot;File.java opening in atom&quot;); } catch (Exception e) { e.printStackTrace(); } }}// 在特定环境变量和目录下，执行命令public class GFG{ public static void main(String[] args) { try { String[] cmd = new String[2]; cmd[0] = &quot;atom&quot;; cmd[1] = &quot;File.java&quot;; // create a file with the working directory we wish File dir = new File(&quot;/home/saket/Desktop&quot;); // create a process and execute cmdArray Process process = Runtime.getRuntime().exec(cmd, null, dir); System.out.println(&quot;File.java opening.&quot;); } catch (Exception e) { e.printStackTrace(); } }}ProcessBuilder The ProcessBuilder class provides methods for creating and configuring operating system processes.ProcessBuilder 用于创建操作系统进程，提供了启动和管理进程（也就是应用程序）的方法。 Each ProcessBuilder instance allows us to manage a collection of process attributes. We can then start a new Process with those given attributes.ProcessBuilder 实例用来管理进程属性集，通过 start 方法使用这些属性去创建 Process，start 方法可以从同一 ProcessBuilder 实例重复调用，以利用相同的或相关的属性创建新的子进程。Runtime 的 exec 方法就是通过调用 ProcessBuilder API 实现的。一些 API： ProcessBuilder(String... command) To create a new process builder with the specified operating system program and arguments, we can use this convenient constructor. 构造函数 directory(File directory) We can override the default working directory of the current process by calling the directory method and passing a File object. By default, the current working directory is set to the value returned by the user.dir system property. 工作目录，默认是 user.dir environment() If we want to get the current environment variables, we can simply call the environment method. It returns us a copy of the current process environment using System.getenv() but as a Map. 获取环境变量 inheritIO() If we want to specify that the source and destination for our subprocess standard I/O should be the same as that of the current Java process, we can use the inheritIO method. 子进程使用当前 Java 进程相同的 IO redirectInput(File file), redirectOutput(File file), redirectError(File file) When we want to redirect the process builder’s standard input, output and error destination to a file, we have these three similar redirect methods at our disposal. 重定向输入、输出、错误的重定向 start() Last but not least, to start a new process with what we’ve configured, we simply call start(). 启动进程 一个例子：@Testpublic void givenProcessBuilder_whenModifyWorkingDir_thenSuccess() throws IOException, InterruptedException { ProcessBuilder processBuilder = new ProcessBuilder(&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls&quot;); processBuilder.directory(new File(&quot;src&quot;)); Process process = processBuilder.start(); List&amp;lt;String&amp;gt; results = readOutput(process.getInputStream()); assertThat(&quot;Results should not be empty&quot;, results, is(not(empty()))); assertThat(&quot;Results should contain directory listing: &quot;, results, contains(&quot;main&quot;, &quot;test&quot;)); int exitCode = process.waitFor(); assertEquals(&quot;No errors should be detected&quot;, 0, exitCode);}" }, { "title": "SleepWatcher", "url": "/posts/sleepwatcher/", "categories": "tool", "tags": "", "date": "2021-07-26 00:00:00 +0800", "snippet": "Mac 之前遇到了合盖后掉电比较快的问题，可能是跟代理或者 wi-fi 有关，没有具体查问题的原因，之后发现了 SleepWatcher 这个工具。SleepWatcher 可以在 Mac 睡眠、唤醒以及空闲的时候通过脚本执行一些定制的命令。安装直接通过 brew 就能安装，安装完后也是通过 brew 启动 service。$ brew install sleepwatcher$ brew services start sleepwatcher通过 brew 安装完 sleepwatcher 后，terminal 里提示说明文档是在：/usr/local/opt/sleepwatcher/ReadMe.rtf，里边也是说怎么升级和安装的。只需要睡眠和唤醒后执行一些命令，那直接到下一步准备脚本就可以了。如果有更高级的需求，man 一下。脚本在 home 目录下分别创建 .sleep 和 .wakeup 文件，并赋予可执行权限就可以了。至于脚本的内容，就根据自己需求来，譬如下边是睡眠时关闭某个 app 和 wi-fi，唤醒时再打开。# .sleep#! /usr/bin/env zshosascript -e &#39;quit app &quot;xxx&quot;&#39;networksetup -setairportpower en0 off# .wakeup#! /usr/bin/env zshnetworksetup -setairportpower en0 onosascript -e &#39;open app &quot;xxx&quot;&#39;" }, { "title": "Shell (5)", "url": "/posts/shell5/", "categories": "language, shell", "tags": "shell", "date": "2021-07-03 00:00:00 +0800", "snippet": "Linux 命令大全，这里有很多命令的使用方法，不想看英文 man 手册的时候可以来这里先学习下某个命令。在文本处理中有三个比较常见的命令，分别是 grep、sed 和 awk。 grep 主要用于在文件或者目录中查找相应的关键字 sed 主要用于编辑匹配到的文本，做一些替换或者增删操作 awk 本身是一种语言，可以写成像 shell 脚本那样的 awk 脚本来执行，在 linux 命令中主要用于格式化文本 grepgrep 命令用于查找文件里符合条件的字符串。grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。语法grep [-abcEFGhHilLnqrsvVwxy][-A&amp;lt;显示行数&amp;gt;][-B&amp;lt;显示列数&amp;gt;][-C&amp;lt;显示列数&amp;gt;][-d&amp;lt;进行动作&amp;gt;][-e&amp;lt;范本样式&amp;gt;][-f&amp;lt;范本文件&amp;gt;][--help][范本样式][文件或目录...]实例1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：$ grep test *file 结果如下所示：$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件 testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行 testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行 testfile_2:Linux test #列出testfile_2 文件中包含test字符的行 2、以递归的方式查找符合条件的文件。例如，查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容，使用的命令为：$ grep -r update /etc/acpi 输出结果如下：$ grep -r update /etc/acpi #以递归的方式查找“etc/acpi” #下包含“update”的文件 /etc/acpi/ac.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.) Rather than /etc/acpi/resume.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.) Rather than /etc/acpi/events/thinkpad-cmos:action=/usr/sbin/thinkpad-keys--update 3、反向查找。前面各个例子是查找并打印出符合条件的行，通过”-v”参数可以打印出不符合条件行的内容。查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为：$ grep -v test *test*结果如下所示：$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行 testfile1:helLinux! testfile1:Linis a free Unix-type operating system. testfile1:Lin testfile_1:HELLO LINUX! testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM. testfile_1:THIS IS A LINUX TESTFILE! testfile_2:HELLO LINUX! testfile_2:Linux is a free unix-type opterating system. sedsed 命令利用脚本来处理文本文件。sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。语法sed [-hnVi][-e&amp;lt;script&amp;gt;][-f&amp;lt;script文件&amp;gt;][文本文件]参数说明： -e -f或--file= 以选项中指定的script文件来处理输入的文本文件。 -h或–help 显示帮助。 -n或–quiet或–silent 仅显示script处理后的结果。 -V或–version 显示版本信息。 -i 直接修改文件内容。动作说明： a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚； i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～ s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！实例在testfile文件的第四行后添加一行，并将结果输出到标准输出，在命令行提示符下输入如下命令：sed -e 4a\\newLine testfile 首先查看testfile中的内容如下：$ cat testfile #查看testfile 中的内容 HELLO LINUX! Linux is a free unix-type opterating system. This is a linux testfile! Linux test 使用sed命令后，输出结果如下：$ sed -e 4a\\newline testfile #使用sed 在第四行后添加新字符串 HELLO LINUX! #testfile文件原有的内容 Linux is a free unix-type opterating system. This is a linux testfile! Linux test newline 以行为单位的新增/删除将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！[root@www ~]# nl /etc/passwd | sed &#39;2,5d&#39;1 root:x:0:0:root:/root:/bin/bash6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown.....(后面省略).....sed 的动作为 ‘2,5d’ ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗～ 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 后面接的动作，请务必以 ‘’ 两个单引号括住喔！只要删除第 2 行nl /etc/passwd | sed &#39;2d&#39; 要删除第 3 到最后一行nl /etc/passwd | sed &#39;3,$d&#39; 在第二行后(亦即是加在第三行)加上『drink tea?』字样！[root@www ~]# nl /etc/passwd | sed &#39;2a drink tea&#39;1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologindrink tea3 daemon:x:2:2:daemon:/sbin:/sbin/nologin.....(后面省略).....那如果是要在第二行前nl /etc/passwd | sed &#39;2i drink tea&#39; 如果是要增加两行以上，在第二行后面加入两行字，例如 Drink tea or ….. 与 drink beer?[root@www ~]# nl /etc/passwd | sed &#39;2a Drink tea or ......\\&amp;gt; drink beer ?&#39;1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologinDrink tea or ......drink beer ?3 daemon:x:2:2:daemon:/sbin:/sbin/nologin.....(后面省略).....每一行之间都必须要以反斜杠『 \\ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \\ 存在。以行为单位的替换与显示将第2-5行的内容取代成为『No 2-5 number』呢？[root@www ~]# nl /etc/passwd | sed &#39;2,5c No 2-5 number&#39;1 root:x:0:0:root:/root:/bin/bashNo 2-5 number6 sync:x:5:0:sync:/sbin:/bin/sync.....(后面省略).....透过这个方法我们就能够将数据整行取代了！仅列出 /etc/passwd 文件内的第 5-7 行[root@www ~]# nl /etc/passwd | sed -n &#39;5,7p&#39;5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown可以透过这个 sed 的以行为单位的显示功能， 就能够将某一个文件内的某些行号选择出来显示。数据的搜寻并显示搜索 /etc/passwd有root关键字的行nl /etc/passwd | sed &#39;/root/p&#39;1 root:x:0:0:root:/root:/bin/bash1 root:x:0:0:root:/root:/bin/bash2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh3 bin:x:2:2:bin:/bin:/bin/sh4 sys:x:3:3:sys:/dev:/bin/sh5 sync:x:4:65534:sync:/bin:/bin/sync....下面忽略 如果root找到，除了输出所有行，还会输出匹配行。使用-n的时候将只打印包含模板的行。nl /etc/passwd | sed -n &#39;/root/p&#39;1 root:x:0:0:root:/root:/bin/bash数据的搜寻并删除删除/etc/passwd所有包含root的行，其他行输出nl /etc/passwd | sed &#39;/root/d&#39;2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh3 bin:x:2:2:bin:/bin:/bin/sh....下面忽略#第一行的匹配root已经删除了数据的搜寻并执行命令搜索/etc/passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行：nl /etc/passwd | sed -n &#39;/root/{s/bash/blueshell/;p;q}&#39; 1 root:x:0:0:root:/root:/bin/blueshell最后的q是退出。数据的搜寻并替换除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样：sed &#39;s/要被取代的字串/新的字串/g&#39;先观察原始信息，利用 /sbin/ifconfig 查询 IP[root@www ~]# /sbin/ifconfig eth0eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:LinkUP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1.....(以下省略).....本机的ip是192.168.1.100。将 IP 前面的部分予以删除[root@www ~]# /sbin/ifconfig eth0 | grep &#39;inet addr&#39; | sed &#39;s/^.*addr://g&#39;192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0接下来则是删除后续的部分，亦即： 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0将 IP 后面的部分予以删除[root@www ~]# /sbin/ifconfig eth0 | grep &#39;inet addr&#39; | sed &#39;s/^.*addr://g&#39; | sed &#39;s/Bcast.*$//g&#39;192.168.1.100多点编辑一条sed命令，删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshellnl /etc/passwd | sed -e &#39;3,$d&#39; -e &#39;s/bash/blueshell/&#39;1 root:x:0:0:root:/root:/bin/blueshell2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh-e表示多点编辑，第一个编辑命令删除/etc/passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。直接修改文件内容(危险动作)sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由於这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置来测试！ 我们还是使用文件 regular_express.txt 文件来测试看看吧！regular_express.txt 文件内容如下：[root@www ~]# cat regular_express.txt runoob.google.taobao.facebook.zhihu-weibo-利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 ![root@www ~]# sed -i &#39;s/\\.$/\\!/g&#39; regular_express.txt[root@www ~]# cat regular_express.txt runoob!google!taobao!facebook!zhihu-weibo-利用 sed 直接在 regular_express.txt 最后一行加入 # This is a test:[root@www ~]# sed -i &#39;$a # This is a test&#39; regular_express.txt[root@www ~]# cat regular_express.txt runoob!google!taobao!facebook!zhihu-weibo-# This is a test由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增 # This is a test！awkawk 是一种处理文本文件的语言，是一个强大的文本分析工具。之所以叫 awk 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。语法awk [选项参数] &#39;script&#39; var=value file(s)或awk [选项参数] -f scriptfile var=value file(s)选项参数说明： -F fs or –field-separator fs指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。 -v var=value or –asign var=value赋值一个用户定义变量。 -f scripfile or –file scriptfile从脚本文件中读取awk命令。基本用法log.txt文本内容如下：2 this is a test3 Are you like awkThis&#39;s a test10 There are orange,apple,mongo用法一：awk &#39;{[pattern] action}&#39; {filenames} # 行匹配语句 awk &#39;&#39; 只能用单引号实例：# 每行按空格或TAB分割，输出文本中的1、4项 $ awk &#39;{print $1,$4}&#39; log.txt --------------------------------------------- 2 a 3 like This&#39;s 10 orange,apple,mongo # 格式化输出 $ awk &#39;{printf &quot;%-8s %-10s\\n&quot;,$1,$4}&#39; log.txt --------------------------------------------- 2 a 3 like This&#39;s 10 orange,apple,mongo 用法二：awk -F #-F相当于内置变量FS, 指定分割字符实例：# 使用&quot;,&quot;分割 $ awk -F, &#39;{print $1,$2}&#39; log.txt --------------------------------------------- 2 this is a test 3 Are you like awk This&#39;s a test 10 There are orange apple # 或者使用内建变量 $ awk &#39;BEGIN{FS=&quot;,&quot;} {print $1,$2}&#39; log.txt --------------------------------------------- 2 this is a test 3 Are you like awk This&#39;s a test 10 There are orange apple # 使用多个分隔符.先使用空格分割，然后对分割结果再使用&quot;,&quot;分割 $ awk -F &#39;[ ,]&#39; &#39;{print $1,$2,$5}&#39; log.txt --------------------------------------------- 2 this test 3 Are awk This&#39;s a 10 There apple用法三：awk -v # 设置变量实例： $ awk -va=1 &#39;{print $1,$1+a}&#39; log.txt --------------------------------------------- 2 3 3 4 This&#39;s 1 10 11 $ awk -va=1 -vb=s &#39;{print $1,$1+a,$1b}&#39; log.txt --------------------------------------------- 2 3 2s 3 4 3s This&#39;s 1 This&#39;ss 10 11 10s用法四：awk -f {awk脚本} {文件名}实例： $ awk -f cal.awk log.txt运算符 运算符 描述 = += -= *= /= %= ^= **= 赋值 ?: C条件表达式 || 逻辑或 &amp;amp;&amp;amp; 逻辑与 ~ 和 !~ 匹配正则表达式和不匹配正则表达式 &amp;lt; &amp;lt;= &amp;gt; &amp;gt;= != == 关系运算符 空格 连接 + - 加，减 * / % 乘，除与求余 + - ! 一元加，减和逻辑非 ^ *** 求幂 ++ – 增加或减少，作为前缀或后缀 $ 字段引用 in 数组成员 过滤第一列大于2的行$ awk &#39;$1&amp;gt;2&#39; log.txt #命令#输出3 Are you like awkThis&#39;s a test10 There are orange,apple,mongo过滤第一列等于2的行$ awk &#39;$1==2 {print $1,$3}&#39; log.txt #命令#输出2 is过滤第一列大于2并且第二列等于’Are’的行$ awk &#39;$1&amp;gt;2 &amp;amp;&amp;amp; $2==&quot;Are&quot; {print $1,$2,$3}&#39; log.txt #命令#输出3 Are you内建变量 变量 描述 $n 当前记录的第n个字段，字段间由FS分隔 $0 完整的输入记录 ARGC 命令行参数的数目 ARGIND 命令行中当前文件的位置(从0开始算) ARGV 包含命令行参数的数组 CONVFMT 数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组 ERRNO 最后一个系统错误的描述 FIELDWIDTHS 字段宽度列表(用空格键分隔) FILENAME 当前文件名 FNR 各文件分别计数的行号 FS 字段分隔符(默认是任何空格) IGNORECASE 如果为真，则进行忽略大小写的匹配 NF 一条记录的字段的数目 NR 已经读出的记录数，就是行号，从1开始 OFMT 数字的输出格式(默认值是%.6g) OFS 输出字段分隔符，默认值与输入字段分隔符一致。 ORS 输出记录分隔符(默认值是一个换行符) RLENGTH 由match函数所匹配的字符串的长度 RS 记录分隔符(默认是一个换行符) RSTART 由match函数所匹配的字符串的第一个位置 SUBSEP 数组下标分隔符(默认值是/034) $ awk &#39;BEGIN{printf &quot;%4s %4s %4s %4s %4s %4s %4s %4s %4s\\n&quot;,&quot;FILENAME&quot;,&quot;ARGC&quot;,&quot;FNR&quot;,&quot;FS&quot;,&quot;NF&quot;,&quot;NR&quot;,&quot;OFS&quot;,&quot;ORS&quot;,&quot;RS&quot;;printf &quot;---------------------------------------------\\n&quot;} {printf &quot;%4s %4s %4s %4s %4s %4s %4s %4s %4s\\n&quot;,FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}&#39; log.txtFILENAME ARGC FNR FS NF NR OFS ORS RS---------------------------------------------log.txt 2 1 5 1log.txt 2 2 5 2log.txt 2 3 3 3log.txt 2 4 4 4$ awk -F\\&#39; &#39;BEGIN{printf &quot;%4s %4s %4s %4s %4s %4s %4s %4s %4s\\n&quot;,&quot;FILENAME&quot;,&quot;ARGC&quot;,&quot;FNR&quot;,&quot;FS&quot;,&quot;NF&quot;,&quot;NR&quot;,&quot;OFS&quot;,&quot;ORS&quot;,&quot;RS&quot;;printf &quot;---------------------------------------------\\n&quot;} {printf &quot;%4s %4s %4s %4s %4s %4s %4s %4s %4s\\n&quot;,FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}&#39; log.txtFILENAME ARGC FNR FS NF NR OFS ORS RS---------------------------------------------log.txt 2 1 &#39; 1 1log.txt 2 2 &#39; 1 2log.txt 2 3 &#39; 2 3log.txt 2 4 &#39; 1 4# 输出顺序号 NR, 匹配文本行号$ awk &#39;{print NR,FNR,$1,$2,$3}&#39; log.txt---------------------------------------------1 1 2 this is2 2 3 Are you3 3 This&#39;s a test4 4 10 There are# 指定输出分割符$ awk &#39;{print $1,$2,$5}&#39; OFS=&quot; $ &quot; log.txt---------------------------------------------2 $ this $ test3 $ Are $ awkThis&#39;s $ a $10 $ There $使用正则，字符串匹配# 输出第二列包含 &quot;th&quot;，并打印第二列与第四列$ awk &#39;$2 ~ /th/ {print $2,$4}&#39; log.txt---------------------------------------------this a~ 表示模式开始。// 中是模式。# 输出包含 &quot;re&quot; 的行$ awk &#39;/re/ &#39; log.txt---------------------------------------------3 Are you like awk10 There are orange,apple,mongo忽略大小写$ awk &#39;BEGIN{IGNORECASE=1} /this/&#39; log.txt---------------------------------------------2 this is a testThis&#39;s a test模式取反$ awk &#39;$2 !~ /th/ {print $2,$4}&#39; log.txt---------------------------------------------Are likeaThere orange,apple,mongo$ awk &#39;!/th/ {print $2,$4}&#39; log.txt---------------------------------------------Are likeaThere orange,apple,mongoawk 脚本关于 awk 脚本，我们需要注意两个关键词 BEGIN 和 END。 BEGIN{ 这里面放的是执行前的语句 } END {这里面放的是处理完所有的行后要执行的语句 } {这里面放的是处理每一行时要执行的语句}假设有这么一个文件（学生成绩表）：$ cat score.txtMarry 2143 78 84 77Jack 2321 66 78 45Tom 2122 48 77 71Mike 2537 87 97 95Bob 2415 40 57 62我们的 awk 脚本如下：$ cat cal.awk#!/bin/awk -f#运行前BEGIN { math = 0 english = 0 computer = 0 printf &quot;NAME NO. MATH ENGLISH COMPUTER TOTAL\\n&quot; printf &quot;---------------------------------------------\\n&quot;}#运行中{ math+=$3 english+=$4 computer+=$5 printf &quot;%-6s %-6s %4d %8d %8d %8d\\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5}#运行后END { printf &quot;---------------------------------------------\\n&quot; printf &quot; TOTAL:%10d %8d %8d \\n&quot;, math, english, computer printf &quot;AVERAGE:%10.2f %8.2f %8.2f\\n&quot;, math/NR, english/NR, computer/NR}我们来看一下执行结果：$ awk -f cal.awk score.txtNAME NO. MATH ENGLISH COMPUTER TOTAL---------------------------------------------Marry 2143 78 84 77 239Jack 2321 66 78 45 189Tom 2122 48 77 71 196Mike 2537 87 97 95 279Bob 2415 40 57 62 159--------------------------------------------- TOTAL: 319 393 350AVERAGE: 63.80 78.60 70.00另外一些实例AWK 的 hello world 程序为：BEGIN { print &quot;Hello, world!&quot; }计算文件大小$ ls -l *.txt | awk &#39;{sum+=$5} END {print sum}&#39;--------------------------------------------------666581从文件中找出长度大于 80 的行：awk &#39;length&amp;gt;80&#39; log.txt" }, { "title": "Shell (4)", "url": "/posts/shell4/", "categories": "language, shell", "tags": "shell", "date": "2021-06-13 00:00:00 +0800", "snippet": "[toc]阮一峰老师写的教程，这里做个精简笔记。1 循环Bash 提供三种循环语法 for、while 和 until。until 是 while 的反逻辑版。while 循环，只要满足 condition 条件就一直执行。while condition; do commandsdoneuntil 循环，只要不满足 condition 条件就一直执行。until condition; do commandsdonefor in 循环，遍历列表的所有项。for variable in list; do commandsdone## 例子1for i in word1 word2 word3; do echo $idone## 例子2for i in *.png; do ls -l $idone## in list 的部分可以省略，这时 list 默认等于脚本的所有参数 $@。但是，为了可读性，最好还是不要省略，参考下面的例子。for filename; do echo &quot;$filename&quot;done# 等同于for filename in &quot;$@&quot; ; do echo &quot;$filename&quot;donefor 循环，支持 C 语言写法。for (( expression1; expression2; expression3 )); do commandsdonefor (( i=0; i&amp;lt;5; i=i+1 )); do echo $idoneselect 结构，用于生成简单菜单，与 for in 语法一致。select name [in list]; do commandsdone## 例子select brand in Samsung Sony iphone symphony Waltondo echo &quot;You have chosen $brand&quot;done$ ./select.sh1) Samsung2) Sony3) iphone4) symphony5) Walton#?## select 与 case 结合使用select os in Ubuntu LinuxMint Windows8 Windows10 WindowsXPdo case $os in &quot;Ubuntu&quot;|&quot;LinuxMint&quot;) echo &quot;I also use $os.&quot; ;; &quot;Windows8&quot; | &quot;Windows10&quot; | &quot;WindowsXP&quot;) echo &quot;Why don&#39;t you try Linux?&quot; ;; *) echo &quot;Invalid entry.&quot; break ;; esacdone2 函数函数与别名的区别：别名一般用于封装简单的单行命令，函数则用来封装复制的多行命令。函数总是在当前 Shell 执行，这是跟脚本的重大区别，Bash 执行脚本时会新建一个子 Shell 来执行。如果函数与脚本同名，函数会优先被执行。但函数的优先级不如别名，存在同名的函数和别名时，别名会优先被执行。优先级：别名 &amp;gt; 函数 &amp;gt; 脚本。函数的定义语法，两种语法等价：# 第一种fn() { # codes}# 第二种function fn() { # codes}# 删除函数$ unset -f functionName# 查看当前 Shell 已定义的函数$ declare -f$ declare -f functionName$ declare -F # 只输出函数名，不包含函数体2.1 参数变量函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。 $1~$9：函数的第一个到第9个的参数。 $0：函数所在的脚本名。 $#：函数的参数总数。 $@：函数的全部参数，参数之间使用空格分隔。 $*：函数的全部参数，参数之间使用变量 $IFS 值的第一个字符分隔，默认为空格，但是可以自定义。如果函数的参数多于 9 个，那么第 10 个参数可以用 ${10} 的形式引用，以此类推。function log_msg { echo &quot;[`date &#39;+ %F %T&#39;` ]: $@&quot;}$ log_msg &quot;This is sample log message&quot;[ 2018-08-16 19:56:34 ]: This is sample log message2.2 变量作用域Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。fn () { foo=1 echo &quot;fn: foo = $foo&quot;}fnecho &quot;global: foo = $foo&quot;## 执行结果$ bash test.shfn: foo = 1global: foo = 1函数里面可以用 local 命令声明局部变量。fn () { local foo foo=1 echo &quot;fn: foo = $foo&quot;}fnecho &quot;global: foo = $foo&quot;## 执行结果$ bash test.shfn: foo = 1global: foo =3 数组3.1 数组创建数组可以采用逐个赋值或者一次性赋值的方式进行创建。## 逐个赋值$ array[0]=val$ array[1]=val$ array[2]=val## 一次性赋值$ array=(value1 value2 ... valueN)# 或$ array=( value1 value2 value3)示例$ array=(a b c)$ days=(Sun Mon Tue Wed Thu Fri Sat)# 可以在每个值前面指定位置$ array=([2]=c [0]=a [1]=b)$ days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat)# 只为某些值指定位置，hatter是数组的0号位置，duchess是5号位置，alice是6号位置，没有赋值的数组元素的默认值是空字符串$ names=(hatter [5]=duchess alice)# 可以使用通配符$ mp3s=( *.mp3 )# 声明数组$ declare -a ARRAYNAME# 用户输入存入数组$ read -a dice3.2 访问数组元素单个元素，指定索引或者不指定索引返回数组第一个元素。# 注意要加上大括号，否则返回的就是 ${array[0]}[i] 了$ echo ${array[i]}# 不指定索引，默认返回 array[0]$ echo $array所有元素，使用 @ 和 * 可以返回所有元素。$ foo=(a b c d e f)$ echo ${foo[@]}a b c d e f# 配合 for 循环进行遍历for i in &quot;${names[@]}&quot;; do echo $idone@ 和 * 放不放在双引号之中，是有差别的。$ activities=( swimming &quot;water skiing&quot; canoeing &quot;white-water rafting&quot; surfing )## 直接遍历，数组 activities 实际包含 5 个成员，但是 for...in 循环直接遍历 ${activities[@]}，导致返回 7 个结果。$ for act in ${activities[@]}; \\do \\echo &quot;Activity: $act&quot;; \\doneActivity: swimmingActivity: waterActivity: skiingActivity: canoeingActivity: white-waterActivity: raftingActivity: surfing## 加引号，把 ${activities[@]} 放在双引号之中可以保证遍历的正确性。$ for act in &quot;${activities[@]}&quot;; \\do \\echo &quot;Activity: $act&quot;; \\doneActivity: swimmingActivity: water skiingActivity: canoeingActivity: white-water raftingActivity: surfing${activities[*]} 不放在双引号之中，跟 ${activities[@]} 不放在双引号之中是一样的。$ for act in ${activities[*]}; \\do \\echo &quot;Activity: $act&quot;; \\doneActivity: swimmingActivity: waterActivity: skiingActivity: canoeingActivity: white-waterActivity: raftingActivity: surfing## 放在双引号之中，所有成员就会变成单个字符串返回。$ for act in &quot;${activities[*]}&quot;; \\do \\echo &quot;Activity: $act&quot;; \\doneActivity: swimming water skiing canoeing white-water rafting surfing拷贝一个数组的最方便方法，就是写成下面这样。$ hobbies=( &quot;${activities[@]}&quot; )上面例子中，数组 activities 被拷贝给了另一个数组 hobbies。这种写法也可以用来为新数组添加成员。$ hobbies=( &quot;${activities[@]&quot; diving )上面例子中，新数组 hobbies 在数组 activities 的所有成员之后，又添加了一个成员。3.3 数组属性长度，空的元素不会计入长度中。${#array[*]}${#array[@]}$ a[100]=foo$ echo ${#a[*]}1$ echo ${#a[@]}1索引，返回所有非空元素的位置。${!array[@]}${!array[*]}$ arr=([5]=a [9]=b [23]=c)$ echo ${!arr[@]}5 9 23$ echo ${!arr[*]}5 9 233.4 数组元素提取，${array[@]:position:length}$ food=( apples bananas cucumbers dates eggs fajitas grapes )$ echo ${food[@]:1:1}bananas$ echo ${food[@]:1:3}bananas cucumbers dates# 如果省略长度参数 length，则返回从指定位置开始的所有成员。$ echo ${food[@]:4}eggs fajitas grapes追加，+=$ foo=(a b c)$ echo ${foo[@]}a b c$ foo+=(d e f)$ echo ${foo[@]}a b c d e f删除，unset$ foo=(a b c d e f)$ echo ${foo[@]}a b c d e f$ unset foo[2]$ echo ${foo[@]}a b d e f$ echo ${#foo[@]}5$ echo ${!foo[@]}0 1 3 4 5## foo[2]=&#39;&#39; 可以用来隐藏元素，删除和隐藏的区别可以用 null 和 &quot;&quot; 进行理解，一个是没有值，一个是空字符串$ foo=(a b c d e f)$ foo[1]=&#39;&#39;$ echo ${foo[@]}a c d e f$ echo ${#foo[@]}6$ echo ${!foo[@]}0 1 2 3 4 53.4 关联数组Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。declare -A 可以声明关联数组。declare -A colorscolors[&quot;red&quot;]=&quot;#ff0000&quot;colors[&quot;green&quot;]=&quot;#00ff00&quot;colors[&quot;blue&quot;]=&quot;#0000ff&quot;关联数组必须用带有 -A 选项的 declare 命令声明创建。相比之下，整数索引的数组，可以直接使用变量名创建数组，关联数组就不行。访问关联数组成员的方式，几乎与整数索引数组相同。echo ${colors[&quot;blue&quot;]}4 setBash 执行脚本时，会创建一个子 Shell。子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。直接运行 set，会显示所有的环境变量和 Shell 函数。set 参数： -u：执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。加上 -u 后，脚本遇到不存在的变量就会报错并停止执行。 -x：用来在运行结果之前，先输出执行的那一行命令，在行首以 + 号表示执行的命令。 -e：脚本只要发生错误，就终止执行。 -o pipefail：-e 不适用于管道命令，所谓管道命令，就是多个子命令通过管道运算符（|）组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，-e 就失效了。-o pipefail 可以避免这种情况发生，只要一个子管道命令失效，整个管道命令就会失败，脚本就会终止执行。 -n：不运行命令，只检查语法是否正确。 -f：不对通配符进行文件名扩展。 -v：打印 Shell 接收到的每一行输入。set 的参数一般放在脚本头部，也可以在执行 Bash 脚本时从命令行传入。$ bash -euxo pipefail script.sh5 shoptshopt 命令用来调整 Shell 的参数，跟 set 命令的作用很类似。之所以会有这两个类似命令的主要原因是，set 是从 Ksh 继承的，属于 POSIX 规范的一部分，而 shopt 是 Bash 特有的。直接输入 shopt 可以查看所有参数，以及它们各自打开和关闭的状态。$ shoptshopt 命令后面跟着参数名，可以查询该参数是否打开。$ shopt globstarglobstar off上面例子表示 globstar 参数默认是关闭的。（1）-s-s 用来打开某个参数。$ shopt -s optionNameHere（2）-u-u 用来关闭某个参数。$ shopt -u optionNameHere举例来说，histappend 这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，那么当前 Shell 的操作历史将替换掉整个历史文件。$ shopt -u histappend6 Debug 相关环境变量6.1 LINENO变量 LINENO 返回它在脚本里面的行号。#!/bin/bashecho &quot;This is line $LINENO&quot;执行上面的脚本 test.sh，$LINENO 会返回 3。$ ./test.shThis is line 36.2 FUNCNAME变量 FUNCNAME 返回一个数组，内容是当前的函数调用堆栈。该数组的 0 号成员是当前调用的函数，1 号成员是调用当前函数的函数，以此类推。#!/bin/bashfunction func1(){ echo &quot;func1: FUNCNAME0 is ${FUNCNAME[0]}&quot; echo &quot;func1: FUNCNAME1 is ${FUNCNAME[1]}&quot; echo &quot;func1: FUNCNAME2 is ${FUNCNAME[2]}&quot; func2}function func2(){ echo &quot;func2: FUNCNAME0 is ${FUNCNAME[0]}&quot; echo &quot;func2: FUNCNAME1 is ${FUNCNAME[1]}&quot; echo &quot;func2: FUNCNAME2 is ${FUNCNAME[2]}&quot;}func1执行上面的脚本 test.sh，结果如下。$ ./test.shfunc1: FUNCNAME0 is func1func1: FUNCNAME1 is mainfunc1: FUNCNAME2 isfunc2: FUNCNAME0 is func2func2: FUNCNAME1 is func1func2: FUNCNAME2 is main6.3 BASH_SOURCE变量 BASH_SOURCE 返回一个数组，内容是当前的脚本调用堆栈。该数组的 0 号成员是当前执行的脚本，1 号成员是调用当前脚本的脚本，以此类推，跟变量 FUNCNAME 是一一对应关系。下面有两个子脚本 lib1.sh 和 lib2.sh。# lib1.shfunction func1(){ echo &quot;func1: BASH_SOURCE0 is ${BASH_SOURCE[0]}&quot; echo &quot;func1: BASH_SOURCE1 is ${BASH_SOURCE[1]}&quot; echo &quot;func1: BASH_SOURCE2 is ${BASH_SOURCE[2]}&quot; func2}# lib2.shfunction func2(){ echo &quot;func2: BASH_SOURCE0 is ${BASH_SOURCE[0]}&quot; echo &quot;func2: BASH_SOURCE1 is ${BASH_SOURCE[1]}&quot; echo &quot;func2: BASH_SOURCE2 is ${BASH_SOURCE[2]}&quot;}然后，主脚本 main.sh 调用上面两个子脚本。#!/bin/bash# main.shsource lib1.shsource lib2.shfunc1执行主脚本 main.sh，会得到下面的结果。$ ./main.shfunc1: BASH_SOURCE0 is lib1.shfunc1: BASH_SOURCE1 is ./main.shfunc1: BASH_SOURCE2 isfunc2: BASH_SOURCE0 is lib2.shfunc2: BASH_SOURCE1 is lib1.shfunc2: BASH_SOURCE2 is ./main.sh7 mktempBash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 /tmp 目录里面创建文件或目录，这样做有很多弊端，使用 mktemp 命令是最安全的做法。使用直接运行 mktemp 命令，就能生成一个临时文件。$ mktemp/tmp/tmp.4GcsWSG4vj$ ls -l /tmp/tmp.4GcsWSG4vj-rw------- 1 ruanyf ruanyf 0 12月 28 12:49 /tmp/tmp.4GcsWSG4vj上面命令中，mktemp 命令生成的临时文件名是随机的，而且权限是只有用户本人可读写。Bash 脚本使用 mktemp 命令的用法如下。#!/bin/bashTMPFILE=$(mktemp)echo &quot;Our temp file is $TMPFILE&quot;为了确保临时文件创建成功，mktemp 命令后面最好使用 OR 运算符（||），保证创建失败时退出脚本。#!/bin/bashTMPFILE=$(mktemp) || exit 1echo &quot;Our temp file is $TMPFILE&quot;为了保证脚本退出时临时文件被删除，可以使用 trap 命令指定退出时的清除操作。#!/bin/bashtrap &#39;rm -f &quot;$TMPFILE&quot;&#39; EXITTMPFILE=$(mktemp) || exit 1echo &quot;Our temp file is $TMPFILE&quot;参数-d 参数可以创建一个临时目录。$ mktemp -d/tmp/tmp.Wcau5UjmN6-p 参数可以指定临时文件所在的目录。默认是使用 $TMPDIR 环境变量指定的目录，如果这个变量没设置，那么使用 /tmp 目录。$ mktemp -p /home/ruanyf//home/ruanyf/tmp.FOKEtvs2H3-t 参数可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的 X 字符，表示随机字符，建议至少使用六个 X。默认的文件名模板是 tmp. 后接十个随机字符。$ mktemp -t mytemp.XXXXXXX/tmp/mytemp.yZ1HgZV8 traptrap 命令用来在 Bash 脚本中响应系统信号。最常见的系统信号就是 SIGINT（中断），即按 Ctrl + C 所产生的信号。trap 命令的 -l 参数，可以列出所有的系统信号。$ trap -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAXtrap 的命令格式如下。$ trap [动作] [信号1] [信号2] ...上面代码中，“动作”是一个 Bash 命令，“信号”常用的有以下几个。 HUP：编号1，脚本与所在的终端脱离联系。 INT：编号2，用户按下 Ctrl + C，意图让脚本终止运行。 QUIT：编号3，用户按下 Ctrl + 斜杠，意图退出脚本。 KILL：编号9，该信号用于杀死进程。 TERM：编号15，这是kill命令发出的默认信号。 EXIT：编号0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。 trap 命令响应 EXIT 信号的写法如下。$ trap &#39;rm -f &quot;$TMPFILE&quot;&#39; EXIT上面命令中，脚本遇到 EXIT 信号时，就会执行 rm -f &quot;$TMPFILE&quot;。trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。#!/bin/bashtrap &#39;rm -f &quot;$TMPFILE&quot;&#39; EXITTMPFILE=$(mktemp) || exit 1ls /etc &amp;gt; $TMPFILEif grep -qi &quot;kernel&quot; $TMPFILE; then echo &#39;find&#39;fi上面代码中，不管是脚本正常执行结束，还是用户按 Ctrl + C 终止，都会产生 EXIT 信号，从而触发删除临时文件。注意，trap 命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。如果 trap 需要触发多条命令，可以封装一个 Bash 函数。function egress { command1 command2 command3}trap egress EXIT9 命令提示符命令提示符有 4 个相关的环境变量。 PS1：常规输入的提示符，$ 是普通用户，# 是根用户。 PS2：令行折行输入时系统的提示符，默认为 &amp;gt; 。 PS3：使用 select 命令时，系统输入菜单的提示符。 PS4：默认为 + ，它是使用 Bash 的 -x 参数执行脚本时行首的符号。内容 \\a：响铃，计算机发出一记声音。 \\d：以星期、月、日格式表示当前日期，例如“Mon May 26”。 \\h：本机的主机名。 \\H：完整的主机名。 \\j：运行在当前 Shell 会话的工作数。 \\l：当前终端设备名。 \\n：一个换行符。 \\r：一个回车符。 \\s：Shell 的名称。 \\t：24小时制的hours:minutes:seconds格式表示当前时间。 \\T：12小时制的当前时间。 \\@：12小时制的AM/PM格式表示当前时间。 \\A：24小时制的hours:minutes表示当前时间。 \\u：当前用户名。 \\v：Shell 的版本号。 \\V：Shell 的版本号和发布号。 \\w：当前的工作路径。 \\W：当前目录名。 \\!：当前命令在命令历史中的编号。 \\#：当前 shell 会话中的命令数。 \\$：普通用户显示为$字符，根用户显示为#字符。 \\[：非打印字符序列的开始标志。 \\]：非打印字符序列的结束标志。前景颜色 \\[\\033[00m\\]：颜色恢复 \\[\\033[0;30m\\]：黑色 \\[\\033[1;30m\\]：深灰色 \\[\\033[0;31m\\]：红色 \\[\\033[1;31m\\]：浅红色 \\[\\033[0;32m\\]：绿色 \\[\\033[1;32m\\]：浅绿色 \\[\\033[0;33m\\]：棕色 \\[\\033[1;33m\\]：黄色 \\[\\033[0;34m\\]：蓝色 \\[\\033[1;34m\\]：浅蓝色 \\[\\033[0;35m\\]：粉红 \\[\\033[1;35m\\]：浅粉色 \\[\\033[0;36m\\]：青色 \\[\\033[1;36m\\]：浅青色 \\[\\033[0;37m\\]：浅灰色 \\[\\033[1;37m\\]：白色背景颜色 \\[\\033[0;40m\\]：蓝色 \\[\\033[0;41m\\]：红色 \\[\\033[0;42m\\]：绿色 \\[\\033[0;43m\\]：棕色 \\[\\033[1;44m\\]：黑色 \\[\\033[1;45m\\]：粉红 \\[\\033[1;46m\\]：青色 \\[\\033[1;47m\\]：浅灰色License：署名-相同方式共享 3.0" }, { "title": "Shell (3)", "url": "/posts/shell3/", "categories": "language, shell", "tags": "shell", "date": "2021-06-12 00:00:00 +0800", "snippet": "[toc]阮一峰老师写的教程，这里做个精简笔记。1 首行脚本第一行通常通过 #! 来指定解释器，即该脚本通过什么程序来执行。#! /usr/bin/env bash以上命令使用 env 命令（这个命令总是在 /usr/bin 目录），返回 Bash 可执行文件的位置。env 命令总是指向 /usr/bin/env 文件，或者说，这个二进制文件总是在目录 /usr/bin，env NAME 表示返回 NAME 的可执行文件位置。## 新建一个不带任何环境变量的 Shell$ env -i /bin/sh2 脚本参数调用脚本时，脚本文件名后可以跟随参数，譬如：$ ./script.sh var1 var2 var3脚本文件内部，可以使用特殊变量，引用这些参数。 $0：脚本文件名，即 script.sh。 $1~$9：对应脚本的第一个参数到第九个参数。 $#：参数的总数。 $@：全部的参数，参数之间使用空格分隔。 $*：全部的参数，参数之间使用变量$IFS值的第一个字符分隔，默认为空格，但是可以自定义。 如果脚本的参数多于9个，那么第10个参数可以用${10}的形式引用，以此类推。 如果多个参数放在双引号里面，视为一个参数。 如果命令是 command -o foo bar，那么 -o 是 $1，foo 是 $2，bar 是 $3。2.1 shiftshift 命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（$1），使得后面的参数向前一位，即 $2变成 $1、$3 变成 $2、$4 变成 $3，以此类推。通常使用 while 循环结合 shift 进行参数遍历。#!/bin/bashecho &quot;一共输入了 $# 个参数&quot;while [ &quot;$1&quot; != &quot;&quot; ]; do echo &quot;剩下 $# 个参数&quot; echo &quot;参数：$1&quot; shiftdoneshift 命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为 1。2.2 getoptsgetopts 命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与 while 循环一起使用，取出脚本所有的带有前置连词线（-）的参数。getopts optstring name它带有两个参数。第一个参数 optstring 是字符串，给出脚本所有的连词线参数。比如，某个脚本可以有三个配置项参数 -l、-h、-a，其中只有 -a 可以带有参数值，而 -l 和 -h 是开关参数，那么 getopts 的第一个参数写成 lha:，顺序不重要。注意，a 后面有一个冒号，表示该参数带有参数值，getopts 规定带有参数值的配置项参数，后面必须带有一个冒号（:）。getopts 的第二个参数 name 是一个变量名，用来保存当前取到的配置项参数，即 l、h 或 a。下面是一个例子。while getopts &#39;lha:&#39; OPTION; do case &quot;$OPTION&quot; in l) echo &quot;linuxconfig&quot; ;; h) echo &quot;h stands for h&quot; ;; a) avalue=&quot;$OPTARG&quot; echo &quot;The value provided is $OPTARG&quot; ;; ?) echo &quot;script usage: $(basename $0) [-l] [-h] [-a somevalue]&quot; &amp;gt;&amp;amp;2 exit 1 ;; esacdoneshift &quot;$(($OPTIND - 1))&quot;上面例子中，while 循环不断执行 getopts &#39;lha:&#39; OPTION命令，每次执行就会读取一个连词线参数（以及对应的参数值），然后进入循环体。变量 OPTION 保存的是，当前处理的那一个连词线参数（即 l、h 或 a）。如果用户输入了没有指定的参数（比如 -x），那么 OPTION 等于 ?。循环体内使用 case 判断，处理这四种不同的情况。如果某个连词线参数带有参数值，比如 -a foo，那么处理 a 参数的时候，环境变量 $OPTARG 保存的就是参数值。注意，只要遇到不带连词线的参数，getopts 就会执行失败，从而退出 while 循环。比如，getopts 可以解析command -l foo，但不可以解析 command foo -l。另外，多个连词线参数写在一起的形式，比如 command -lh，getopts 也可以正确处理。变量 $OPTIND 在 getopts 开始执行前是 1，然后每次执行就会加 1。等到退出 while 循环，就意味着连词线参数全部处理完毕。这时，$OPTIND - 1 就是已经处理的连词线参数个数，使用 shift 命令将这些参数移除，保证后面的代码可以用 $1、$2 等处理命令的主参数。变量当作命令的参数时，有时希望指定变量只能作为实体参数，不能当作配置项参数，这时可以使用配置项参数终止符 --。3 退出exit 命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。退出时，脚本会返回一个退出值。 0 表示正常 1 表示发生错误 2 表示用法不对 126 表示不是可执行脚本 127 表示命令没有发现 如果脚本被信号 N 终止，则退出值为 128 + N。简单来说，只要退出值非0，就认为执行出错。命令执行结束后，会有一个返回值。0 表示执行成功，非 0（通常是 1）表示执行失败。环境变量 $? 可以读取前一个命令的返回值。4 sourcesource 命令用于执行一个脚本，通常用于重新加载一个配置文件。source 命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，source 命令执行脚本时，不需要 export 变量。#!/bin/bash# test.shecho $foo# 当前 Shell 新建一个变量 foo$ foo=1# 打印输出 1$ source test.sh1# 打印输出空字符串$ bash test.shsource 命令的另一个用途，是在脚本内部加载外部库。#!/bin/bashsource ./lib.shfunction_from_libsource 有一个简写形式，可以使用一个点（.）来表示。$ . .bashrc5 readread 读取用户输入或者文件。## 读取用户输入，存入变量 text#!/bin/bashecho -n &quot;输入一些文本 &amp;gt; &quot;read textecho &quot;你的输入：$text&quot;## 读取多个用户输入#!/bin/bashecho Please, enter your firstname and lastnameread FN LNecho &quot;Hi! $LN, $FN !&quot; 如果用户的输入项少于 read 命令给出的变量数目，那么额外的变量值为空。 如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。 如果 read 命令之后没有定义变量名，那么环境变量 REPLY 会包含所有的输入。#!/bin/bash# read-single: read multiple values into default variableecho -n &quot;Enter one or more values &amp;gt; &quot;readecho &quot;REPLY = &#39;$REPLY&#39;&quot;read 命令除了读取键盘输入，可以用来读取文件。#!/bin/bashfilename=&#39;/etc/hosts&#39;while read mylinedo echo &quot;$myline&quot;done &amp;lt; $filename上面的例子通过 read 命令，读取一个文件的内容。done 命令后面的定向符 &amp;lt;，将文件内容导向 read 命令，每次读取一行，存入变量 myline，直到文件读取完毕。参数如下： -t，超时秒数 #!/bin/bash echo -n &quot;输入一些文本 &amp;gt; &quot;if read -t 3 response; then echo &quot;用户已经输入了&quot;else echo &quot;用户没有输入&quot;fi -p，提示信息 -a，用户输入赋值给数组 -n，只读取若干字符作为变量值 -e，允许用户输入的时候使用 readline 库提供的快捷方式，例如自动补全 -d delimiter，指定 delimiter 的第一个字符作为用户输入的结束而不是换行符 -r，raw 模式，不解释转义字符 -s，用户输入不显示在屏幕上，用于密码输入 IFSread 命令读取的值，默认是以空格分隔。可以通过自定义环境变量 IFS（内部字段分隔符，Internal Field Separator 的缩写），修改分隔标志。IFS 的默认值是空格、Tab 符号、换行符号，通常取第一个（即空格）。如果把 IFS 定义成冒号（:）或分号（;），就可以分隔以这两个符号分隔的值，这对读取文件很有用。#!/bin/bash# read-ifs: read fields from a fileFILE=/etc/passwdread -p &quot;Enter a username &amp;gt; &quot; user_namefile_info=&quot;$(grep &quot;^$user_name:&quot; $FILE)&quot;if [ -n &quot;$file_info&quot; ]; then IFS=&quot;:&quot; read user pw uid gid name home shell &amp;lt;&amp;lt;&amp;lt; &quot;$file_info&quot; echo &quot;User = &#39;$user&#39;&quot; echo &quot;UID = &#39;$uid&#39;&quot; echo &quot;GID = &#39;$gid&#39;&quot; echo &quot;Full Name = &#39;$name&#39;&quot; echo &quot;Home Dir. = &#39;$home&#39;&quot; echo &quot;Shell = &#39;$shell&#39;&quot;else echo &quot;No such user &#39;$user_name&#39;&quot; &amp;gt;&amp;amp;2 exit 1fi上面例子中，IFS 设为冒号，然后用来分解 /etc/passwd 文件的一行。IFS 的赋值命令和 read 命令写在一行，这样的话，IFS 的改变仅对后面的命令生效，该命令执行后IFS会自动恢复原来的值。如果不写在一行，就要采用下面的写法。OLD_IFS=&quot;$IFS&quot;IFS=&quot;:&quot;read user pw uid gid name home shell &amp;lt;&amp;lt;&amp;lt; &quot;$file_info&quot;IFS=&quot;$OLD_IFS&quot;另外，上面例子中，&amp;lt;&amp;lt;&amp;lt; 是 Here 字符串，用于将变量值转为标准输入，因为 read 命令只能解析标准输入。6 条件判断if 条件判断的基本结构：if commands; then commands[elif commands; then commands...][else commands]fi## 或者删除分隔符 ; 把 then 放在下一行if commandsthen commands[elif commandsthen commands...][else commands]fi## 或者全部放在一行if commands; then commands; fiif 后面是主要的判断条件（true false），或者是命令（命令执行成功，即返回值是 0 表示判断条件成立）。if 后面可以跟任意数量的命令。这时所有命令都会执行，但是判断条件是否成立只取决于最后一个命令，即使前面所有命令都失败，只要最后一个命令返回 0，就会执行 then 的部分。if 的判断条件使用 test 命令，有三种形式：# 写法一test expression# 写法二[ expression ]# 写法三，支持正则判断[[ expression ]]6.1 判断表达式文件判断 [ -a file ]：如果 file 存在，则为true。 [ -b file ]：如果 file 存在并且是一个块（设备）文件，则为true。 [ -c file ]：如果 file 存在并且是一个字符（设备）文件，则为true。 [ -d file ]：如果 file 存在并且是一个目录，则为true。 [ -e file ]：如果 file 存在，则为true。 [ -f file ]：如果 file 存在并且是一个普通文件，则为true。 [ -g file ]：如果 file 存在并且设置了组 ID，则为true。 [ -G file ]：如果 file 存在并且属于有效的组 ID，则为true。 [ -h file ]：如果 file 存在并且是符号链接，则为true。 [ -k file ]：如果 file 存在并且设置了它的“sticky bit”，则为true。 [ -L file ]：如果 file 存在并且是一个符号链接，则为true。 [ -N file ]：如果 file 存在并且自上次读取后已被修改，则为true。 [ -O file ]：如果 file 存在并且属于有效的用户 ID，则为true。 [ -p file ]：如果 file 存在并且是一个命名管道，则为true。 [ -r file ]：如果 file 存在并且可读（当前用户有可读权限），则为true。 [ -s file ]：如果 file 存在且其长度大于零，则为true。 [ -S file ]：如果 file 存在且是一个网络 socket，则为true。 [ -t fd ]：如果 fd 是一个文件描述符，并且重定向到终端，则为true。 这可以用来判断是否重定向了标准输入／输出／错误。 [ -u file ]：如果 file 存在并且设置了 setuid 位，则为true。 [ -w file ]：如果 file 存在并且可写（当前用户拥有可写权限），则为true。 [ -x file ]：如果 file 存在并且可执行（有效用户有执行／搜索权限），则为true。 [ file1 -nt file2 ]：如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为true。 [ file1 -ot file2 ]：如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为true。 [ FILE1 -ef FILE2 ]：如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为true。字符串判断 [ string ]：如果string不为空（长度大于0），则判断为真。 [ -n string ]：如果字符串string的长度大于零，则判断为真。 [ -z string ]：如果字符串string的长度为零，则判断为真。 [ string1 = string2 ]：如果string1和string2相同，则判断为真。 [ string1 == string2 ] 等同于[ string1 = string2 ]。 [ string1 != string2 ]：如果string1和string2不相同，则判断为真。 [ string1 &#39;&amp;gt;&#39; string2 ]：如果按照字典顺序string1排列在string2之后，则判断为真。 [ string1 &#39;&amp;lt;&#39; string2 ]：如果按照字典顺序string1排列在string2之前，则判断为真。注意，test 命令内部的 &amp;gt; 和 &amp;lt;，必须用引号引起来（或者是用反斜杠转义）。否则，它们会被 shell 解释为重定向操作符。整数判断 [ integer1 -eq integer2 ]：如果integer1等于integer2，则为true。 [ integer1 -ne integer2 ]：如果integer1不等于integer2，则为true。 [ integer1 -le integer2 ]：如果integer1小于或等于integer2，则为true。 [ integer1 -lt integer2 ]：如果integer1小于integer2，则为true。 [ integer1 -ge integer2 ]：如果integer1大于或等于integer2，则为true。 [ integer1 -gt integer2 ]：如果integer1大于integer2，则为true。正则判断 [[ string1 =~ regex ]]：regex 是正则表达式，=~ 进行正则比较 #!/bin/bash INT=-5 if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then echo &quot;INT is an integer.&quot; exit 0else echo &quot;INT is not an integer.&quot; &amp;gt;&amp;amp;2 exit 1fi 逻辑运算 AND 运算：符号&amp;amp;&amp;amp;，也可使用参数-a。 OR 运算：符号||，也可使用参数-o。 NOT 运算：符号!。使用否定操作符 ! 时，最好用圆括号确定转义的范围。if [ ! \\( $INT -ge $MIN_VAL -a $INT -le $MAX_VAL \\) ]; then echo &quot;$INT is outside $MIN_VAL to $MAX_VAL.&quot;else echo &quot;$INT is in range.&quot;fi上面例子中，test 命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。算术判断((...)) 可以进行算术运算的判断。注意，算术判断不需要使用 test 命令，而是直接使用 ((...)) 结构。这个结构的返回值，决定了判断的真伪。如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。7 casecase 结构用于多值判断，可以为每个值指定对应的命令，跟包含多个 elif 的 if 结构等价，但是语义更好。它的语法如下。case expression in pattern ) commands ;; pattern ) commands ;; ...esac上面代码中，expression 是一个表达式，pattern 是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号（;）结尾。#!/bin/bashecho -n &quot;输入一个1到3之间的数字（包含两端）&amp;gt; &quot;read charactercase $character in 1 ) echo 1 ;; 2 ) echo 2 ;; 3 ) echo 3 ;; * ) echo 输入不符合要求esac上面例子中，最后一条匹配语句的模式是 *，这个通配符可以匹配其他字符和没有输入字符的情况，类似 if 的 else 部分。下面是另一个例子，判断当前操作系统。#!/bin/bashOS=$(uname -s)case &quot;$OS&quot; in FreeBSD) echo &quot;This is FreeBSD&quot; ;; Darwin) echo &quot;This is Mac OSX&quot; ;; AIX) echo &quot;This is AIX&quot; ;; Minix) echo &quot;This is Minix&quot; ;; Linux) echo &quot;This is Linux&quot; ;; *) echo &quot;Failed to identify this OS&quot; ;;esaccase 的匹配模式可以使用各种通配符，下面是一些例子。 a)：匹配a。 a|b)：匹配a或b。 [[:alpha:]])：匹配单个字母。 ???)：匹配3个字符的单词。 *.txt)：匹配.txt结尾。 *)：匹配任意输入，通过作为case结构的最后一个模式。#!/bin/bashecho -n &quot;输入一个字母或数字 &amp;gt; &quot;read charactercase $character in [[:lower:]] | [[:upper:]] ) echo &quot;输入了字母 $character&quot; ;; [0-9] ) echo &quot;输入了数字 $character&quot; ;; * ) echo &quot;输入不符合要求&quot;esac上面例子中，使用通配符 [[:lower:]] | [[:upper:]] 匹配字母，[0-9] 匹配数字。Bash 4.0之前，case 结构只能匹配一个条件，然后就会退出 case 结构。Bash 4.0之后，允许匹配多个条件，这时可以用 ;;&amp;amp; 终止每个条件块。#!/bin/bash# test.shread -n 1 -p &quot;Type a character &amp;gt; &quot;echocase $REPLY in [[:upper:]]) echo &quot;&#39;$REPLY&#39; is upper case.&quot; ;;&amp;amp; [[:lower:]]) echo &quot;&#39;$REPLY&#39; is lower case.&quot; ;;&amp;amp; [[:alpha:]]) echo &quot;&#39;$REPLY&#39; is alphabetic.&quot; ;;&amp;amp; [[:digit:]]) echo &quot;&#39;$REPLY&#39; is a digit.&quot; ;;&amp;amp; [[:graph:]]) echo &quot;&#39;$REPLY&#39; is a visible character.&quot; ;;&amp;amp; [[:punct:]]) echo &quot;&#39;$REPLY&#39; is a punctuation symbol.&quot; ;;&amp;amp; [[:space:]]) echo &quot;&#39;$REPLY&#39; is a whitespace character.&quot; ;;&amp;amp; [[:xdigit:]]) echo &quot;&#39;$REPLY&#39; is a hexadecimal digit.&quot; ;;&amp;amp;esac执行上面的脚本，会得到下面的结果。$ test.shType a character &amp;gt; a&#39;a&#39; is lower case.&#39;a&#39; is alphabetic.&#39;a&#39; is a visible character.&#39;a&#39; is a hexadecimal digit.可以看到条件语句结尾添加了 ;;&amp;amp; 以后，在匹配一个条件之后，并没有退出 case 结构，而是继续判断下一个条件。License：署名-相同方式共享 3.0" }, { "title": "Shell (2)", "url": "/posts/shell2/", "categories": "language, shell", "tags": "shell", "date": "2021-06-07 00:00:00 +0800", "snippet": "[toc]阮一峰老师写的教程，这里做个精简笔记。1 引号和转义1.1 转义$ &amp;amp; * 在 Bash 中有特殊含义，需要通过转义字符 \\ 进行转义后才能原样输出。换行符也是一个特殊字符，表示命令的结束，Bash 收到这个字符以后，就会对输入的命令进行解释执行。换行符前面加上反斜杠转义，就使得换行符变成一个普通字符，Bash 会将其当作空格处理，从而可以将一行命令写成多行。$ mv \\/path/to/foo \\/path/to/bar# 等同于$ mv /path/to/foo /path/to/bar1.2 引号单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（*）、美元符号（$）、反斜杠（\\）等。双引号比单引号宽松，大部分特殊字符在双引号里都会失去特殊含义变成普通字符。但是，美元符号、反引号和反斜杠，这三个字符在双引号之中依然会被 Bash 自动扩展。换行符在双引号中失去特殊含义，Bash 不再将其解释为命令的结束，只是作为普通的换行符。所以可以利用双引号，在命令行输入多行文本。双引号还有一个作用，就是利用换行符失去特殊含义，可以保存原始命令的输出格式。# 单行输出$ echo $(cal)# 原始格式输出$ echo &quot;$(cal)&quot;1.3 Here 文档/字符串Here 文档（here document）是一种输入多行字符串的方法，格式如下。&amp;lt;&amp;lt; tokentexttoken它的格式分成开始标记（&amp;lt;&amp;lt; token）和结束标记（token）。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。$ cat &amp;lt;&amp;lt; _EOF_&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt; The title of your page &amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; Your page content goes here.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;_EOF_Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。$ foo=&#39;hello world&#39;$ cat &amp;lt;&amp;lt; _example_$foo&quot;$foo&quot;&#39;$foo&#39;_example_hello world&quot;hello world&quot;&#39;hello world&#39;如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。$ foo=&#39;hello world&#39;$ cat &amp;lt;&amp;lt; &#39;_example_&#39;$foo&quot;$foo&quot;&#39;$foo&#39;_example_$foo&quot;$foo&quot;&#39;$foo&#39;Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了 echo 命令。$ command &amp;lt;&amp;lt; token stringtoken# 等同于$ echo string | command所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如echo命令就不能用 Here 文档作为参数。$ echo &amp;lt;&amp;lt; _example_hello_example_上面例子不会有任何输出，因为 Here 文档对于 echo 命令无效。此外，Here 文档也不能作为变量的值，只能用于命令的参数。Here 文档还有一个变体，叫做 Here 字符串（Here string），使用三个小于号（&amp;lt;&amp;lt;&amp;lt;）表示。&amp;lt;&amp;lt;&amp;lt; string它的作用是将字符串通过标准输入，传递给命令。有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如 cat 命令只接受标准输入传入的字符串。2 变量## 打印所有变量（自定义 + 环境）$ set## 打印环境变量$ env## 自定义变量，等号两边不能有空格a=z # 变量 a 赋值为字符串 zb=&quot;a string&quot; # 变量值包含空格，就必须放在引号里面c=&quot;a string and $b&quot; # 变量值可以引用其他变量的值d=&quot;\\t\\ta string\\n&quot; # 变量值可以使用转义字符e=$(ls -l foo.txt) # 变量值可以是命令的执行结果f=$((5 * 7)) # 变量值可以是数学运算的结果## 读取变量，变量前加 $ 即可，如果变量值本身也是变量，可以使用 ${!varname} 的语法，读取最终值$ myvar=USER$ echo ${!myvar}cy## 删除变量unset NAME用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用 export 命令。这样输出的变量，对于子 Shell 来说就是环境变量。2.1 特殊变量 $?，上一个命令的退出码，用于判断之前的命令是否执行成功。0 为成功，非 0 为失败 $$，当前 Shell 进程 id $_，上一命令的最后一个参数 $!，最近一个后台执行的异步命令进程 id $ firefox &amp;amp;[1] 11064 $ echo $!11064 $0，当前 Shell 名称 $-，当前 Shell 启动参数 $@ $#，脚本参数数量 2.2 变量默认值Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。## varname 存在且不为空，则返回它的值，否则返回 word。目的是返回一个默认值${varname:-word}## varname 存在且不为空，则返回它的值，否则将它设为 word，并且返回 word。目的是设置变量的默认值${varname:=word}## 变量名存在且不为空，则返回 word，否则返回空值。目的是测试变量是否存在${varname:+word}## varname 存在且不为空，则返回它的值，否则打印出 varname: message，并中断脚本的执行。如果省略了 message，则输出默认的信息 “parameter null or not set.”。目的是防止变量未定义${varname:?message}上面四种语法如果用在脚本中，变量名的部分可以用数字 1 到 9，表示脚本的参数。## 1 表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。filename=${1:?&quot;filename missing.&quot;}3 字符串## 字符串长度${#varname}## 子字符串，不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串${varname:offset:length}## offset 为负数时，表示从末尾开始计算搜索和替换，Bash 提供字符串搜索和替换的多种方法。## 字符串头匹配# 如果 pattern 匹配变量 variable 的开头，# 删除最短匹配（非贪婪匹配）的部分，返回剩余部分${variable#pattern}# 如果 pattern 匹配变量 variable 的开头，# 删除最长匹配（贪婪匹配）的部分，返回剩余部分${variable##pattern}$ myPath=/home/cam/book/long.file.name$ echo ${myPath#/*/}cam/book/long.file.name$ echo ${myPath##/*/}long.file.name$ path=/home/cam/book/long.file.name$ echo ${path##*/}long.file.name$ phone=&quot;555-456-1414&quot;$ echo ${phone#*-}456-1414$ echo ${phone##*-}1414## 匹配不成功，返回原始字符串$ phone=&quot;555-456-1414&quot;$ echo ${phone#444}555-456-1414## 字符串头替换# 模式必须出现在字符串的开头${variable/#pattern/string}# 示例$ foo=JPG.JPG$ echo ${foo/#JPG/jpg}jpg.JPG## 字符串尾匹配# 如果 pattern 匹配变量 variable 的结尾，# 删除最短匹配（非贪婪匹配）的部分，返回剩余部分${variable%pattern}# 如果 pattern 匹配变量 variable 的结尾，# 删除最长匹配（贪婪匹配）的部分，返回剩余部分${variable%%pattern}## 字符串尾替换# 模式必须出现在字符串的结尾${variable/%pattern/string}# 示例$ foo=JPG.JPG$ echo ${foo/%JPG/jpg}JPG.jpg## 任意位置匹配# 如果 pattern 匹配变量 variable 的一部分，# 最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配${variable/pattern/string}# 如果 pattern 匹配变量 variable 的一部分，# 最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换${variable//pattern/string}$ path=/home/cam/foo/foo.name$ echo ${path/foo/bar}/home/cam/bar/foo.name$ echo ${path//foo/bar}/home/cam/bar/bar.name# : 换成换行符$ echo -e ${PATH//:/&#39;\\n&#39;}/usr/local/bin/usr/bin/bin...大小写# 转为大写${varname^^}# 转为小写${varname,,}$ foo=heLLo$ echo ${foo^^}HELLO$ echo ${foo,,}hello4 算术运算((...)) 语法可以进行整数的算术运算，这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是 0，命令就算执行成功。$ (( 3 + 2 ))$ echo $?0$ (( 3 - 3 ))$ echo $?1$ echo $((2 + 2))4Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。 number：没有任何特殊表示法的数字是十进制数（以10为底）。 0number：八进制数。 0xnumber：十六进制数。 base#number：base进制的数。$ echo $((0xff))255$ echo $((2#11111111))255$((...)) 支持以下的二进制位运算符。 &amp;lt;&amp;lt;：位左移运算，把一个数字的所有位向左移动指定的位。 &amp;gt;&amp;gt;：位右移运算，把一个数字的所有位向右移动指定的位。 &amp;amp;：位的“与”运算，对两个数字的所有位执行一个AND操作。 |：位的“或”运算，对两个数字的所有位执行一个OR操作。 ~：位的“否”运算，对一个数字的所有位取反。 ^：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。$((...)) 支持以下的逻辑运算符。 &amp;lt;：小于 &amp;gt;：大于 &amp;lt;=：小于或相等 &amp;gt;=：大于或相等 ==：相等 !=：不相等 &amp;amp;&amp;amp;：逻辑与 ||：逻辑或 !：逻辑否 expr1?expr2:expr3：三元条件运算符。若表达式 expr1 的计算结果为非零值（算术真），则执行表达式 expr2，否则执行表达式 expr3。如果逻辑表达式为真，返回1，否则返回0。5 行操作Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。$ set -o vi$ set -o emacs光标移动 Ctrl + a：移到行首 Ctrl + e：移到行尾 Alt + b：移动到当前单词的词首 Alt + f：移动到当前单词的词尾Alt 键，可以用 ESC 键代替。编辑操作 Ctrl + w：删除光标前面的单词 Ctrl + t：光标位置的字符与它前面一位的字符交换位置（transpose） Alt + t：光标位置的词与它前面一位的词交换位置（transpose）自动补全 Tab：完成自动补全 Alt + ?：列出可能的补全，与连按两次 Tab 键作用相同 Alt + /：尝试文件路径补全License：署名-相同方式共享 3.0" }, { "title": "Shell (1)", "url": "/posts/shell1/", "categories": "language, shell", "tags": "shell", "date": "2021-06-06 00:00:00 +0800", "snippet": "[TOC]阮一峰老师写的教程，这里做个精简笔记。1 Shell 简述Shell 是一个程序、命令解释器、工具箱，目的是为了能让用户跟系统内核交互。Shell 主要种类： Bourne Shell（sh） Bourne Again shell（bash） C Shell（csh） TENEX C Shell（tcsh） Korn shell（ksh） Z Shell（zsh） Friendly Interactive Shell（fish，这个不是 Mac 默认安装的，需要手动安装）查看当前系统使用的 shell 、所有可用 shell、更改 shell。$ echo $SHELL$ cat /etc/shells$ chsh -s /bin/xxx2 命令参数格式和组合Shell 使用空格（或 Tab 键）区分不同的参数，多余的空格会被忽略。参数一般分为短参数和长参数两类，短参数多为单中划线+单个字母的形式 -x，长参数多为双中划线+单词的形式 --word。两类参数效果一样，短的常在人操作时使用，长的在脚本里用。多条命令的执行： 用 ; 进行分隔的命令，后续命令不会关注前边的命令是否执行成功，只要前边的命令执行完成，后续的命令就会执行 用 &amp;amp;&amp;amp; 或者 || 进行连接的命令，具备短路效应# 前后命令都会执行$ cat filelist.txt ; ls -l filelist.txt# 只有 cat 成功 才会执行 ls$ cat filelist.txt &amp;amp;&amp;amp; ls -l filelist.txt# 只有 foo 没有创建成功才会创建 bar$ mkdir foo || mkdir bar3 模式扩展（globbing）Shell 接收到命令和参数后，首先进行模式扩展和通配符扩展（wildcard expansion），然后再执行命令。扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。Bash 有八种扩展： ~ 字符扩展 ~ 被扩展为当前用户目录 ~xxx 被扩展为用户 xxx 目录，如果用户不存在则不会扩展 ~+ 被扩展为当前目录，等价于 pwd ? 字符扩展 ? 是文件名扩展，如果文件不存在则不进行扩展，其匹配任意单个非空字符。 # 当前目录有 a.txt 文件，进行扩展$ echo ?.txta.txt # 当前目录为空目录，不进行扩展$ echo ?.txt?.txt * 字符扩展 * 是文件名扩展匹配任意字符包括空字符。 方括号扩展 方括号扩展是文件名扩展，文件存在时才会扩展。 [...]，匹配其中任意一个字符 [^...] 和 [!...]，匹配不在其中的字符 [start-end]，起始写法 [!start-end]，起始写法 大括号扩展 大括号扩展不是文件名扩展，它总会扩展成所有给定的值，而不管是否有对应的文件存在。 大括号扩展 {...} 表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，{1,2,3} 扩展成 1 2 3。 $ echo {1,2,3}1 2 3$ echo d{a,e,i,u,o}gdag deg dig dug dog $ echo Front-{A,B,C}-BackFront-A-Back Front-B-Back Front-C-Back 逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。 $ echo {1 , 2}{1 , 2} 逗号前面可以没有值，表示扩展的第一项为空。 $ echo a.log{,.bak}a.log a.log.bak 可以嵌套。 $ echo {j{p,pe}g,png}jpg jpeg png $ echo a{A{1,2},B{3,4}}baA1b aA2b aB3b aB4b 大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。 # 先进行大括号扩展，然后进行*扩展，等同于执行两条echo命令$ echo /bin/{cat,b*}/bin/cat /bin/b2sum /bin/base32 /bin/base64 ... ... # 等同于$ echo /bin/cat;echo /bin/b* {start..end}，起始写法 {start..end..step}，带间隔的起始写法 变量扩展 $ 开头或者 ${xxx} 视为变量，将其扩展成变量值。 子命令扩展 $(...) 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。 $ echo $(date)Tue Jan 28 00:01:13 CST 2020$ echo `date`Tue Jan 28 00:01:13 CST 2020 $(...) 也可以嵌套，比如 $(ls $(pwd))。 算术扩展 $((...)) 可以扩展成整数运算的结果。 3.1 字符类[[:class:]] 表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。 [[:alnum:]]：匹配任意英文字母与数字 [[:alpha:]]：匹配任意英文字母 [[:blank:]]：空格和 Tab 键 [[:cntrl:]]：ASCII 码 0-31 的不可打印字符 [[:digit:]]：匹配任意数字 0-9 [[:graph:]]：A-Z、a-z、0-9 和标点符号 [[:lower:]]：匹配任意小写字母 a-z [[:print:]]：ASCII 码 32-127 的可打印字符 [[:punct:]]：标点符号（除了 A-Z、a-z、0-9 的可打印字符） [[:space:]]：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13） [[:upper:]]：匹配任意大写字母 A-Z [[:xdigit:]]：16进制字符（A-F、a-f、0-9）3.2 量词语法量词语法用来控制模式匹配的次数。它只有在 Bash 的extglob参数打开的情况下才能使用，不过一般是默认打开的。 ?(pattern-list)：匹配零个或一个模式。 *(pattern-list)：匹配零个或多个模式。 +(pattern-list)：匹配一个或多个模式。 @(pattern-list)：只匹配一个模式。 !(pattern-list)：匹配给定模式以外的任何内容。4 echo 命令echo 命令把跟在其后的输入原样输出出来。$ echo hello worldhello world内容放在引号内可以多行输出$ echo &quot;helloworld&quot;4.1 参数 -n 去掉末尾换行$ echo -n hello worldhello world$ -e 解释引号内特殊字符（zsh 没有此参数，默认会解释特殊字符）$ echo &quot;Hello\\nWorld&quot;Hello\\nWorld$ echo -e &quot;Hello\\nWorld&quot;HelloWorld5 type 命令type 用来判断命令的类型，内置命令还是外部程序。$ type echoecho is a shell builtin$ type lsls is hashed (/bin/ls)-t 参数返回命令类型，别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）。6 标准输入、输出、错误重定向在 shell 中每个进程都与三个系统文件相关联：标准输入 stdin、标准输出 stdout、标准错误 stderr，三个系统文件的文件描述符分别为0、1、2。因此有时遇到重定向时，需要根据数字进行判断。譬如： 2&amp;gt;&amp;amp;1 表示将标准错误重定向到标准输出 xxx 2 &amp;gt; /dev/null 表示丢弃标准错误License：署名-相同方式共享 3.0" }, { "title": "Prioxy", "url": "/posts/privoxy/", "categories": "tool", "tags": "", "date": "2021-05-31 00:00:00 +0800", "snippet": "Privoxy 是一款不进行网页缓存且自带过滤功能的代理服务器。用这个主要是在主力机上配置端口转发，给手机和虚拟机做代理。主力机上代理默认的配置是 127.0.0.1:port，这只能本机访问没法给局域网里其他设备用，而配置又不太好改，所以就用 Privoxy 做转发。Mac 平台 brew 可以直接安装 privoxy，安装完成后，在 usr/local/etc/privoxy/config 路径下修改配置。## 修改默认配置，127.0.0.1，改成 0.0.0.0 监听整个子网，端口默认 8118，也可以修改listen-address 0.0.0.0:8118## 添加端口转发，都转发到本机的其他端口 port6（http） 和 port7 （socks）forward / 127.0.0.1:port6forward-socks4 / 127.0.0.1:port7forward-socks4a / 127.0.0.1:port7forward-socks5 / 127.0.0.1:port7forward-socks5t / 127.0.0.1:port7## 配置改完后启动服务brew services start privoxy## 配置手机和虚拟机使用代理# ios 和 android 怎么配置代理网上帖子很多# 虚拟机上的代理配置主要是要找对宿主机的 ip，对于 virtualbox nat 网络模式下，直接看默认路由就可以了，ubuntu：$ ip route show defaultdefault via 10.0.2.2 xxx" }, { "title": "VirtualBox", "url": "/posts/virtualbox/", "categories": "tool", "tags": "virtualbox", "date": "2021-05-30 00:00:00 +0800", "snippet": "VirtualBox 是一款开源的虚拟机软件，Linux Windows Mac 三大平台均有对应的版本，现由 Oracle 进行开发。对于个人用户来说，使用虚拟机的好处就是可以把虚拟机的开发环境跟个人日常使用的环境隔离开，即使虚拟机里的开发环境被整的乱七八糟也不会对宿主机有影响，是洁癖和强迫症患者的福音。不过使用虚拟机也有坏处，因其是对硬件的虚拟，所以性能比不上原生安装在物理硬件上的系统，因此如果不是特别的需要，建议虚拟机上不要安装带 gui 的系统，譬如可以安装 ubuntu server 进行相应的开发和测试。安装如何安装 VirtualBox 并安装操作系统网上教程很多，这里只做一个概括。 安装完 VirtualBox 主程序后，建议再安装扩展包，以对 USB、磁盘加密等进行支持，当然不安装也不影响整体使用 进入 VirtualBox 主界面后，通过 new 来搭建一套环境，这套环境可以理解为物理环境，就像我们去电脑城买的一台笔记本或者组装主机，new 的过程中会被要求指定 CPU 核心数、内存大小、占用硬盘空间大小等的资源配置。 有了环境后，就需要下载系统 iso，然后放到 VirtualBox 环境的光驱上，这样 new 出来的环境在启动后，就会加载 iso 执行系统安装程序。需要注意，安装完成重启前，要把 iso 从光驱上删掉，防止重启后又进到了系统安装程序中。 系统安装好后，除了虚拟机上系统的配置外，还可以再做一些文件共享的配置，譬如把宿主机的一些目录挂在到虚拟机系统的文件系统上，网上相关的帖子也有很多，这个贴一个 ubuntu server 的：Mounting VirtualBox shared folders on Ubuntu Server 18.04 LTS (Bionic Beaver)。 ## virtualbox 虚拟机实例的 Shared Folders 可以进行共享文件夹的配置# Devices -&amp;gt; Shared Folders ## virtualbox 在打开的虚拟机实例界面上操作插入 Guest Addition CD# Devices -&amp;gt; Insert Guest Addtions CD ... ## 挂载 Guest Addtions CDsudo mkdir /media/cdromsudo mount -t iso9660 /dev/cdrom /media/cdrom ## 安装相关依赖sudo apt-get updatesudo apt-get install -y build-essential linux-headers-`uname -r` ## 安装 Guest Addsionssudo /media/cdrom/./VBoxLinuxAdditions.run ## 添加当前用户到 vboxsf 用户组，添加好之后重启就可以访问宿主机的共享文件夹了sudo usermod -aG vboxsf $USER 扩容如果安装的时候分配的硬盘空间比较少，用了一段时间后虚拟机上系统的磁盘空间不够了，就需要对虚拟机进行扩容。VirtualBox 扩容也比较简单方便，在最开始新建虚拟机的时候，新建 VDI 时就有两个选项：Dynamic allocated 和 Fixed size，这两者的区别也清楚的写在界面上。Dynamic 模式是其占用的磁盘空间是虚拟机系统的实际大小，随着虚拟机上系统的大小而变化，最大不会超过分配的空间；而 Fixed 模式顾名思义就是，分配多少空间它就会真实占用多少宿主机的空间，这种模式的好处就是使用起来虚拟机上的系统会快一些。举个例子，譬如在 new 虚拟机的时候，我分配了 30G 的磁盘空间，而实际安装的操作系统只用了 8G，那么 Dynamic 占用的宿主机硬盘就是 8G，Fixed 占用的是 30G。扩容的操作也与两种模式有关： Dynamic，可以直接在 virtualbox 界面上进行扩容 Fixed，要先 copy 成 Dynamic，在 Dynamic 模式下扩容后，再 copy 成 Fixed，这时会有两个 Fixed vdi，配置虚拟机使用新生成的 vdi，删除旧的 vdi 就行了以上的操作只是在虚拟机层面进行了磁盘扩容，相当于给主机加了块硬盘，操作系统对新加的硬盘是没法直接使用的，还需要对这块新加的硬盘进行分区上的处理，就 linux 来说分为两种情况：基于 LVM 和 非 LVM。这是对两种情况分别讲如何扩容的一个帖子，具体我并没有尝试帖子里的办法是否切实可行：Increase VirtualBox Disk Size，只是 mark 下以备不时。" }, { "title": "Vagrant", "url": "/posts/vagrant/", "categories": "tool", "tags": "virtualbox", "date": "2021-05-23 00:00:00 +0800", "snippet": "Vagrant 是一个对虚拟机进行管理的工具，使用前需要先安装好虚拟机 VirtualBox。Mac 可以直接通过 brew 安装，Windows 系统需要下载安装包。brew install --cask virtualboxbrew install --cask vagrantVagrant 有个 box 的概念，这个可以理解为一个安装好的 iso 文件。 Boxes are the package format for Vagrant environments. A box can be used by anyone on any platform that Vagrant supports to bring up an identical working environment.在 Vagrant Cloud 上能够搜索很多 box 进行安装。通常使用 Vagrantfile 进行虚拟机的配置，不仅方便，也能保证在不同环境下所建立的虚拟机都是相同的配置。以下是一个 Vagrantfile 示例，其创建 3 个虚拟机，直接在该文件所在目录执行 vagrant up，vagtrant 就会帮助创建虚拟机，创建出来的虚拟机在 virtualbox 里也是可以直接看到的。Vagrant.configure(2) do |config| # 指定使用 ubuntu 20.04 镜像 config.vm.box = &quot;ubuntu/focal64&quot; # 指定虚拟机为 virtualbox config.vm.provider &quot;virtualbox&quot; do |vb| # 指定资源可以使用 4G 内存和 4 个 cpu vb.memory = 4096 vb.cpus = 4 end # 循环 2 次 (1..2).each do |i| # 创建虚拟机，虚拟机名称为 node1，node2 config.vm.define &quot;node#{i}&quot; do |node| # 配置 hostname node.vm.hostname = &quot;node#{i}&quot; # 配置机网络 node.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.1#{i}&quot; # 配置端口映射，guest 是虚拟机，host 是本机 node.vm.network &quot;forwarded_port&quot;, guest: 80, host: &quot;908#{i}&quot; node.vm.network &quot;forwarded_port&quot;, guest: 90, host: &quot;909#{i}&quot; # 配置目录映射，[hostdir, vmdir, type] node.vm.synced_folder &quot;app#{i}&quot;, &quot;/vagrant&quot;, &quot;virtualbox&quot; end end # 单独创建一个虚拟机 config.vm.define &quot;manage&quot; do |manage| manage.vm.hostname = &quot;manage&quot; manage.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.2&quot; endend常用命令# 启动 vmvagrant up# ssh vmvagrant ssh# 停止 vmvagrant halt# 删除 vmvagrant destroy# 检查状态vagrant gloabl-statuss" }, { "title": "maven-release-plugin", "url": "/posts/maven_release_plugin/", "categories": "language, java", "tags": "maven", "date": "2021-05-23 00:00:00 +0800", "snippet": "maven-release-plugin，是官方的插件，可以结合 ci 或者发布人员手工做一些自动化工作：发布到 maven 仓库、打 tag 和自动更新 git 仓库中 pom.xml 文件的版本号。要使用该插件需要满足两个条件： the scm-section with a developerConnection，在 pom.xml 文件中需要有 &amp;lt;scm&amp;gt; &amp;lt;developerConnection&amp;gt; 部分，需要这个是因为 release 插件要通过 scm clone 代码和 push pom.xml 的更新 the maven-release-plugin with a locked version&amp;lt;scm&amp;gt; &amp;lt;developerConnection&amp;gt;scm:git:git@github.com:xxx/xxx.git&amp;lt;/developerConnection&amp;gt;&amp;lt;/scm&amp;gt;...&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-release-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.0-M4&amp;lt;/version&amp;gt;&amp;lt;/plugin&amp;gt;要发布的 maven 仓库地址由 distributionManagement 部分指定。&amp;lt;distributionManagement&amp;gt; &amp;lt;repository&amp;gt; &amp;lt;id&amp;gt;xxx&amp;lt;/id&amp;gt; &amp;lt;name&amp;gt;Releases&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://xxx&amp;lt;/url&amp;gt; &amp;lt;/repository&amp;gt; &amp;lt;snapshotRepository&amp;gt; &amp;lt;id&amp;gt;xxx&amp;lt;/id&amp;gt; &amp;lt;name&amp;gt;snapshots&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://xxx&amp;lt;/url&amp;gt; &amp;lt;/snapshotRepository&amp;gt;&amp;lt;/distributionManagement&amp;gt;通过：mvn -B release:clean release:prepare release:perform 来实现自动化发布，如果不需要进行 test 和生成 javadoc，可以指定参数：-Dmaven.skip.test=true -Dmave.skip.javadoc=true。发布过程实际进行的主要操作如下。release:clean 删除发布描述文件（release.properties） 删除备份的 pom.xmlrelease:prepare 生成 release.properties 文件 检查本地项目代码中是否有未提交的修改 检查依赖或插件是否有 SNAPSHOT 版本（allowTimestampedSnapshots 为 true 时跳过） 将 pom.xml version 从 x.y.z-SNAPSHOT 改为发布版本 x.y.z 更新 pom.xml scm 部分的 tag 执行 test（-Dmaven.skip.test=true 可以跳过） 提交 pom.xml 修改并 push 到 git 仓库 打 tag 并 push 到 git 仓库 将 pom.xml verson 从 x.y.z 改为 x.y.z+1-SNAPSHOT 提交 pom.xml 修改并再次 push 到 git 仓库release:preform 依赖之前 prepare 阶段产生的 release.properties 文件 用 prepare 阶段打的 tag 从 scm url 检出代码 执行预定义的 maven goals（deploy 和 site-deploy） release 完成后 release.properties 和其他相关的 release 文件都会被删除" }, { "title": "Java SPI", "url": "/posts/service_provider_interface/", "categories": "language, java", "tags": "spi", "date": "2021-05-17 00:00:00 +0800", "snippet": "概念 Service provider interface (SPI) is an API intended to be implemented or extended by a third party. It can be used to enable framework extension and replaceable components.SPI 是需要被第三方实现或者扩展的接口，可以被用在框架的扩展和可替代组件上。 A service is a well-known set of interfaces and (usually abstract) classes. A service provider is a specific implementation of a service. The classes in a provider typically implement the interfaces and subclass the classes defined in the service itself. Service providers can be installed in an implementation of the Java platform in the form of extensions, that is, jar files placed into any of the usual extension directories. Providers can also be made available by adding them to the application’s class path or by some other platform-specific means.一个服务就是一组接口，一个服务 Provider 就是这组接口的特殊实现。服务 Provider 可以通过提供 jar 包到通常的扩展目录来实现，也可以通过添加 jar 包到应用程序的 class path 实现。理解以上英文的说法稍稍绕了一点，SPI 可以从面向接口编程说起。先从最简单的场景说起，假设有一个 service A 对外提供服务（API），然后有调用方 B 使用这个服务，那么 B 对 A 就有了一个依赖关系。当 A 发生接口变更时，如果被 B 使用到的接口更新了（加减了参数或者改了接口名），那么调用方 B 的代码也需要进行同步更新。这种情况在简单系统开发中并没有什么问题，但是当进行规模稍大一点的系统开发时，多个组件互相依赖，每个组件的更改都需要通知其他组件同步更新，这个复杂度随着组件数量的的增加呈几何增长。因此，面向接口编程就被提出了。Service A 在对外提供服务前，首先根据调用方 B 的要求或者自己的功能点，对外提供一层抽象的接口（interface），这一层抽象的接口就像是 A 和 很多 B 之间的协议，服务方和调用方都按照协议的规定进行开发，服务方由 service provider 按照协议（接口）的定义进行具体的实现，而调用方则直接根据接口的定义进行使用。这样只要接口不变，那么调用方就无需更改。再进一步讲，如果接口是调用方 B 提出来，但是由服务方 A 来实现，这就产生了依赖反转的现象。没有接口提出之前，调用方 B 直接依赖于服务提供方 A，B -&amp;gt; A；由 B 提出需要哪些接口后，A 的实现反而需要按照 B 提出的接口进行，也就是 A 的具体实现依赖于 B 的接口定义，A -&amp;gt; B。再说到 java 的 SPI，它其实是面向接口编程＋策略模式＋配置文件 的组合，服务方 A 或者调用方 B 首先提出标准的服务接口，然后由不同的服务 Provider 进行实现，不同的服务 Provider 提供不同的 jar 包给调用方，调用方通过配置文件指定不同场景下调用服务的策略就可以实现启用、扩展、或者替换服务/框架的实现策略。JDBC加载不同类型数据库的驱动就是最典型的例子，还有SLF4J加载不同提供商的日志实现类也是类似的。约定Java SPI 的应用需要遵循以下约定。 服务 Provider 提供了接口的一种具体实现后，需要在 jar 包 META-INF/services 目录下创建一个以“接口全限定名”命名的文本文件，文件的每一行都是一个具体实现类的全限定名，这可以通过在打 jar 包前在 resources 目录下对应文件夹内添加相应文件来实现 服务 Provider 实现好的 jar 包需要在调用方的 class path 中 调用方需要使用 java.util.ServiceLoder 动态加载实现模块，其通过扫描 class path 下所有 lib 中的 META-INF/services 目录实现类加载 服务 Provider 提供的实现类必须有一个无参构造方法示例放在一个项目里进行 demo 了，没有拆分 jar 包。 resources 下方服务实现类的注册文件 com.cy.demo.spi.service 下是服务接口和对应的实现类 App 是调用方的模拟// 服务实现类注册文件：com.cy.demo.spi.service.PayServicecom.cy.demo.spi.service.impl.AliPaycom.cy.demo.spi.service.impl.WechatPay// 服务接口 PayServicepackage com.cy.demo.spi.service;public interface PayService { void pay();}// 服务实现 AliPaypackage com.cy.demo.spi.service.impl;import com.cy.demo.spi.service.PayService;public class AliPay implements PayService { @Override public void pay() { System.out.println(&quot;This is AliPay.&quot;); }}// 服务实现 WechatPaypackage com.cy.demo.spi.service.impl;import com.cy.demo.spi.service.PayService;public class WechatPay implements PayService { @Override public void pay() { System.out.println(&quot;This is WechatPay.&quot;); }}// 调用方package com.cy.demo.spi;import com.cy.demo.spi.service.PayService;import java.util.ServiceLoader;public class App { public static void main(String[] args) { ServiceLoader&amp;lt;PayService&amp;gt; loader = ServiceLoader.load(PayService.class); for (PayService payService : loader) { payService.pay(); } }}# 运行结果This is AliPay.This is WechatPay." }, { "title": "Docker", "url": "/posts/docker/", "categories": "tool", "tags": "docker", "date": "2021-05-15 00:00:00 +0800", "snippet": "[toc]Docker 是一款开源软件，用于开发、交付和运行应用程序。 Docker 允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。Docker 容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施（Infrastructure）的差异，部署到任何一个地方。容器相对虚拟机的优势： 启动快，容器里面的应用，就是底层系统的一个进程，而不是虚拟机内部的进程。启动容器相当于启动本机的一个进程，而不是启动一个操作系统，所以速度快很多。 资源占用少，容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 体积小，容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。Docker 的用途： 提供一次性的环境，比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 提供弹性的云服务，因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 组建微服务架构，通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 架构Docker 使用 CS 架构。Client（docker cli） 底层通过 Docker REST API 与 Server（dockerd） 进行通信，并且 Client 和 Server 即可以在同一机器或者不同机器上运行。Registry 用于存储 Docker image，Docker hub 就是一个公共的 registry，相当于 image 的 github，registry 也可以用来搭建公司或者私人的仓库。安装和入门安装Docker 的安装可以参考官方文档，三大平台都可以安装，甚至树莓派的也有相应的版本可以安装。需要说明的是，Docker 有几款不同的产品，不同产品的组件功能不同或者拥有的组件不一样。 Docker Engine，是 Docker 的核心产品，其包含了 docker 和 dockerd。 Docker Compose，用来运行多容器组合的应用，以 docker-compose.yml 作为启动输入。 Docker Desktop，Mac 和 Windows 平台的应用，包含了 Docker Engine, Docker CLI client, Docker Compose, Notary, Kubernetes, and Credential Helper 组件。Mac 如果使用 homebrew 安装的话，要注意 brew install docker 只是安装了 Docker Engine，brew install --cask docker 才是安装 Docker Desktop。当然，也可以直接在这里下载 dmg 文件进行安装。入门官方的入门教程写的非常好，跟着官方的教程就可以入门 docker 了，如果只是日常的简单使用或者只是想玩一玩 docker，那这个入门教程就足够了。Getting started这里对官方入门教程做一个简单整理。 启动一个容器 启动容器时，如果对应的 image 不在本地，docker 会去 docker hub 进行搜索，如果 docker hub 上有该 image，则将其拉取到本地并从该 image 启动新的容器。容器与镜像，类似 oop 中的实例与类的差别。实际上，容器就是在不可变的镜像上加了一个可写层。 # docker run [options] image-name/id # -d detached mode （后台运行模式）# -p 端口映射，[host port]:[containner port]# docker/getting-started 就是官方的入门教程，本地没有的话会从 docker hub 拉取docker run -dp 80:80 docker/getting-started 创建 image 并打 tag 镜像的 tag，大多数情况下可以理解为镜像的版本，但有时也可以用作一个镜像的别名。同一个镜像可以有多个 tag，就像指针一样，多个指针指向同一块内存地址。 docker build 命令以一个 Dockerfile 文件和一个上下文环境作为基础，进行镜像的创建。Dockerfile 文件是一个遵循 Dockerfile 规范 的文本文件，一般直接用 Dockerfile 作为文件名，当然也可以使用其他文件名，但当使用其他文件名时需要用 -f 参数显示指定 Dockerfile 文件。上下文环境就是传给 build 命令的路径或者 url 下的所有文件。 # 在当前目录下构建 tag 为 getting-started 的 image# 没有显式指定 Dockerfile 时，默认在提供的路径下查找名为 Dockerfile 的文件# -t 指定 tagdocker build -t getting-started . 停止和删除容器 没有命令行的应用场景的话，其实 Mac 和 Windows 的 Docker desktop dashboard 操作起来会更直观和方便，界面上可以直接查看拥有那些 image 以及容器的情况，点点鼠标就可以启动、删减。 # 查看正在运行的容器docker ps # 查看所有容器，包括已经停止的，这里需要知道的是，每次 docker run 其实都会新建一个容器并运行，所以如果多次 run 同一个 image，是会产生多个容器的docker ps -a # 启动一个容器，但是在运行结束后就删除该容器docker run --rm image-name/id # 停止一个容器docker stop &amp;lt;the-container-id&amp;gt; # 删除一个容器 docker rm &amp;lt;the-container-id&amp;gt; # 停止并删除一个容器docker rm -f &amp;lt;the-container-id&amp;gt; 推送到 registy 当本地构建好 image 之后，可以通过推送到 registry 供他人使用或者继续开发。推送前需要登陆到公共或者私有的 registry。 # 使用 docker hub 时，不需要指定 server，但如果是私人或者公司的 registry，需要显示指定 server 地址docker login [OPTIONS] [SERVER] # 推送。没有指定具体 tag 时，会推送 tag 为 latest 的 iamgedocker push xxx/xxxxxx:tag 持久化 持久化就是把容器运行中的一些数据保存在 host 上，以便其他容器或者应用使用。有两种实现持久化的方式：一种是 Named Volume；另一种是 Bind Mount。 Named Voulme：通过 docker volume 创建一个有名称的 volume，在 docker run 时再指定相应的 volume即可。 # 创建一个名为 todo-db 的 volumedocker volume create todo-db # 查看 todo-db volume的详细信息，譬如在磁盘上的实际存储位置docker volume inspect todo-db # -v 指定容器运行时要使用的 volume，[volume name]:[container mount point]docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started Bind Mount：不显式创建 volume，直接绑定 host 的具体目录到容器的具体目录。 # 把 host 当前目录挂载到容器的 /app 文件夹docker run -dp 3000:3000 \\ -w /app -v &quot;$(pwd):/app&quot; \\ node:12-alpine \\ sh -c &quot;yarn install &amp;amp;&amp;amp; yarn run dev&quot; 多容器应用 Docker 容器的理念是，一个容器做好一件事。那么比如遇到一个需要数据库的 web 应用时，最少就需要三个容器，前后端和数据库各一个容器。这种多容器类型的应用，Docker 有两种解决方式：一种是通过创建网络，将多容器连接到同一网络，分别启动；另一种是通过 compose，由 Docker 来管理多应用，开发人员只提供相应的配置文件（compose.yaml），在配置文件里指定各容器和其之间的联系。 容器网络：各容器默认情况下是不知道其他容器存在的，需要通过网络来让它们联系在一起。网络的创建与 volume 类似。 # 创建一个名为 todo-app 的网络docker network create todo-app # 启动 mysql 容器，--network 指定容器运行的网络，--netword-alias 指定容器在网络中的别名# -e 提供环境变量docker run -d \\ --network todo-app --network-alias mysql \\ -v todo-mysql-data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=todos \\ mysql:5.7 # 启动 app 容器，--network 指定容器运行网络，-e MYSQL_HOST 指定 mysql 的地址为之前启动的 mysql 容器网络别名docker run -dp 3000:3000 \\ -w /app -v &quot;$(pwd):/app&quot; \\ --network todo-app \\ -e MYSQL_HOST=mysql \\ -e MYSQL_USER=root \\ -e MYSQL_PASSWORD=secret \\ -e MYSQL_DB=todos \\ node:12-alpine \\ sh -c &quot;yarn install &amp;amp;&amp;amp; yarn run dev&quot; Docker Compsoe：Docker 官方出品的用于定义和分享多容器应用的工具，利用该工具只需要创建一个 yaml 文件就可以实现一条命令启停多容器应用。Yaml 文件需要遵循 Compose File 规范。 # schema versionversion: &quot;3.7&quot; # 声明和定义所有容器services: # 定义一个名为 app 的容器 app: # 要从哪个 image 启动容器 image: node:12-alpine # 启动后执行的命令 command: sh -c &quot;yarn install &amp;amp;&amp;amp; yarn run dev&quot; # 端口映射 ports: - 3000:3000 # 指定工作目录 working_dir: /app # 指定 bind mount volumes: - ./:/app # 环境变量 environment: MYSQL_HOST: mysql MYSQL_USER: root MYSQL_PASSWORD: secret MYSQL_DB: todos # 定义一个名为 mysql 的容器 mysql: image: mysql:5.7 volumes: - todo-mysql-data:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: secret MYSQL_DATABASE: todos # 声明和定义 volumevolumes: todo-mysql-data: # 在后台启动多容器应用docker-compose up -d # 查看日志docker-compose logs -fdocker-compose logs -f app # 停止多容器应用，注意如果要删除 volume，还需要加上 --volumes 标志docker-compose down 其他 # 查看一个镜像的 layer，--no-trunc 表示显示所有内容docker image history image # 查看 docker 对象的底层信息docker inspect xxx CMD 和 ENTRYPOINTDockerfile 中的 RUN、CMD、ENTRYPOINT 都可以用来执行命令。RUN 比较清晰，多用来安装一些软件，创建一个新的镜像层。CMD 和 ENTRYPOINT 比较绕，这里做个梳理。CMD 和 ENTRYPOINT 指令都有 exec 和 shell 两种格式，其中 exec 是官方的推荐格式，CMD 额外多一种默认参数的格式。# exec 格式，executable 就是可执行程序，其余是参数。这是官方的推荐格式。CMD/ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]# shell 格式CMD/ENTRYPOINT command param1 param2# 默认参数格式CMD [&quot;param1&quot;,&quot;param2&quot;]CMDCMD 指令允许用户指定容器启动后的默认执行命令。当容器没有指定 entrypoint 并且 docker run 没有指定其他命令时，CMD 的 exec 和 shell 格式的指令会被执行。譬如：# 在 Dockerfile 中指定 echo 作为容器启动后的默认命令CMD [&quot;/bin/echo&quot;, &quot;Hello world&quot;]# 当容器启动时未指定命令，则会执行 echo 命令并输出 Hello worlddocker run -it [image]Hello world# 当容器启动时指定了命令，则启动后会执行指定的命令，CMD 指定的默认 echo 命令将被忽略docker run -it [image] /bin/lsbinboot...ENTRYPOINTENTRYPOINT 用于设置容器启动时要执行的命令及其参数，同时可通过 CMD 命令或者命令行参数提供额外的参数。# 指定容器启动时执行的命令和参数ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello&quot;] # 容器无参数启动时docker run -it [image]Hello# 容器带参数启动时，会追加参数，可以等价于 ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello&quot;, &quot;world&quot;] docker run -it [image] worldHello world# Dockerfile 中同时指定了 ENTRYPOINT 和 CMD 的默认参数形式，CMD 会作为 ENTRYPOINT 的默认参数ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello&quot;] CMD [&quot;world&quot;]# 容器无参数启动时docker run -it [image] Hello world# 容器带参数启动时，CMD 的默认参数被覆盖docker run -it [image] ChinaHello ChinaDockerfile 中的 ENTRYPOINT 可以被 –entrypoint 覆盖。 You can override the ENTRYPOINT setting using --entrypoint, but this can only set the binary to exec (no sh -c will be used).Combination of CMD &amp;amp; ENTRYPOINT贴上官网的 CMD 和 ENTRYPOINT 组合表格，还是非常清楚的。   No ENTRYPOINT ENTRYPOINT exec_entry p1_entry ENTRYPOINT [“exec_entry”, “p1_entry”] No CMD error, not allowed /bin/sh -c exec_entry p1_entry exec_entry p1_entry CMD [“exec_cmd”, “p1_cmd”] exec_cmd p1_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry exec_cmd p1_cmd CMD [“p1_cmd”, “p2_cmd”] p1_cmd p2_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry p1_cmd p2_cmd CMD exec_cmd p1_cmd /bin/sh -c exec_cmd p1_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd Java通过 Jib 可以很方便的容器化 Java 应用。Jib 是一款 maven 插件，使用该插件不需要有容器 runtime，只需要了解 mvn 指令就可以完成 image 的构建。下边是一个 Hello World 的示例。 通过 mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 生成一个项目。在 pom.xml 加入 jib-maven-plugin 依赖，并通过 &amp;lt;from&amp;gt; &amp;lt;image&amp;gt; 标签指定 base-image，通过 &amp;lt;to&amp;gt; &amp;lt;image&amp;gt; 指定生成的 image:tag。 &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;com.google.cloud.tools&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jib-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;from&amp;gt; &amp;lt;!-- base image --&amp;gt; &amp;lt;image&amp;gt;openjdk:alpine&amp;lt;/image&amp;gt; &amp;lt;/from&amp;gt; &amp;lt;to&amp;gt; &amp;lt;!-- 生成的 image name 和 tage --&amp;gt; &amp;lt;image&amp;gt;jib-demo:1.0-SNAPSHOT&amp;lt;/image&amp;gt; &amp;lt;/to&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;container&amp;gt; &amp;lt;!-- 指定生成的 image 创建时间使用当前时间戳 --&amp;gt; &amp;lt;creationTime&amp;gt;USE_CURRENT_TIMESTAMP&amp;lt;/creationTime&amp;gt; &amp;lt;/container&amp;gt;&amp;lt;/plugin&amp;gt; 然后执行 mvn clean compile jib:dockerBuild 就可以生成 image 到本地 docker daemon 了，前提是 docker daemon 要在运行状态。前边提到 jib 这个插件是不需要容器运行时的，如果不是进行本地调试想直接发布的话，则可以通过 mvn clean compile jib:build 命令，这个会直接发布 image 到 registry，至于是推送到公共的 docker hub 还是私有仓库取决于 &amp;lt;to&amp;gt; &amp;lt;image&amp;gt; 的配置，具体可以参考官方文档。 最后检查本地的 image，发现已经有 jib-demo:1.0-SNAPSHOT 镜像了，直接运行就会打印出 Hello World。 $ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEjib-demo 1.0-SNAPSHOT 9e1a1730697e 9 seconds ago 103MB $ docker run jib-demo:1.0-SNAPSHOTHello World! 关于 jib 还有几点需要提及的。 生成 image 还有第三种方式：mvn compile jib:buildTar ，这会生成一个本地的 tarball，可以复制、拷贝到其他机器或者在本机，再载入：docker load --input target/jib-image.tar 如果不指定 base image，jib 默认会使用 AdoptOpenJDK 作为 base image 文件结构：默认情况下生成的 image 中会有三个文件夹存放 java 相关的内容，app/classes 下是项目的所有类文件；app/libs 是项目的所有依赖；app/resources 是项目所有的资源文件。通过 docker inspect 查看生成的 image，会发现其 entrypoint 是把这个三个文件夹指定为了 classpath。 &quot;Entrypoint&quot;: [ &quot;java&quot;, &quot;-cp&quot;, &quot;/app/resources:/app/classes:/app/libs/*&quot;, &quot;com.cy.demo.App&quot;], 如果配置了 containerizingMode 为 packaged，那么 jib 会把 target 下的 jar 包拷贝到 app/classpath 目录下，同时 entrypoint 会变为以下这样。 &quot;Entrypoint&quot;: [ &quot;java&quot;, &quot;-cp&quot;, &quot;/app/classpath/*:/app/libs/*&quot;, &quot;com.cy.demo.App&quot;], 常用命令整理# 运行，-p 端口映射；-it 交互终端；-d 后台运行；--name 指定容器名docker run# 查看容器，-a 所有容器；--no-trunc 显示长 iddocker ps# 从镜像创建容器，但不启动docker create --myNginx nginx# 启停删容器docker start/pause/restart/stop/rm myNginx# 查看记录t0=$(date &quot;+%Y-%m-%dT%H:%M:%S&quot;)...t1=$(date &quot;+%Y-%m-%dT%H:%M:%S&quot;)docker evnets --since $t0 --until $t1# 查看详细信息docker inspect# 查看资源使用情况docker stats# 查看容器内进程docker top myNginx# 查看网络，bridge 是默认网络，容器启动后会连接到这个子网，通过 inspect 可以查看docker network lsdocker netword inspect bridge# 创建网络，--driver 指定网络类型docker network create --driver bridge myNetwork# 指定容器运行的网络 --netdocker run --net=myNetwork myNginx# 把运行中的容器连接到网络，这样默认的 bridge 和 myNetwork 两个子网中都会有该容器docker network connect/diconnect myNginx myNetwork# 查看日志docker logs myNginx# 在一个运行的容器中执行命令，exec 和 attach。# exec 是重新启动一个 shell 进程，它退出后不会影响原先运行的容器# attach 顾名思义是附到了原进程上，它退出后也会停止容器的运行docker attach myNginxdocker exec myNginx ls /docker exec -it myNginx /bin/bashs# 提供环境变量docker run --env MYVAR1=foo nginxdocker run --env-file ./env-file nginx# 查看镜像docker images# 拉取镜像，不指定 tag 时，默认 latestdocker pull hello-worlddocker pull hello-world:linux# 登陆，不指定地址时，默认为 docker hubdocker login# 创建镜像docker build --tag &quot;hello-world:1.0-SNAPSHOT&quot; . # 创建 volumedocker volume create myVolumedocker volume lsdocker volume inspect myVolume# 挂载 volumedocker run -it --mount source=myVolume,target=/app alpine" }, { "title": "Chip-On-Board", "url": "/posts/chip_on_board/", "categories": "other", "tags": "", "date": "2021-05-09 00:00:00 +0800", "snippet": "工行给的那个电子密钥没电了，今天拆开看了下，里边电路板上有坨黑色的东西，小时候玩的红白机卡带也常见到这黑色的东西。网上查了查，这也是芯片的一种封装方式，叫做 Chip-On-Board，业界好像也给它一个昵称“牛屎封装”。Chip-On-Board （COB）常见的芯片封装形式是把晶元放在金属、陶瓷或者塑料的壳体内，然后通过金线连接晶元和芯片管脚。但 COB 的封装形式是直接把晶元粘在电路板上，然后在通过 wire bonding 把晶元和电路板的焊盘用金线连接起来，最后滴上环氧树脂进行保护。环氧树脂就是最后看到的那坨黑色的东西。这种封装形式一般用在比较廉价的设备上，譬如小孩子的玩具上。当芯片发生损坏时，无法进行维修，只能把设备废弃。" }, { "title": "消息队列", "url": "/posts/message_queue/", "categories": "tool", "tags": "rabbitmq", "date": "2021-05-06 00:00:00 +0800", "snippet": "[toc]消息队列是一种进程间通信或同一进程的不同线程间的通信方式，直观一点的理解可以直接从字面进行理解，消息队列就是一个容纳消息的队列，producer 有新的消息就丢给队列，consumer 轮询队列进行消息的获取。高级消息队列协议（Advanced Message Queuing Protocol AMQP）是面向消息中间件提供的开放的应用层协议。消息队列有很多基于不同协议的开源实现：RabbitMQ（AMQP）、RocketMQ（自定协议）、Kafka（自定的基于TCP的二进制协议）。 RabbitMQ：性能好、延时低、管理界面友好、社区活跃。但吞吐量较低，erlang 语言实现，较难扩展。 RocketMQ：阿里出品，接口简单易用。 Kafka：提供较少的核心功能、具备超高的吞吐量、极高的可用性和拓展性。但存在消息重复消费的缺点，适合于大数据实时计算和日志收集。消息队列常见的应用场景：异步处理、应用解耦、流量削峰、消息通讯等。一个模拟 RabbitMQ 的网站：RabbitMQ SimulatorAMQP 核心概念 Broker：接收和分发 message 的应用，即 RabbitMQ 的 server。 Virtual Host：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于 namespace 概念。当多个不同的用户使用同一个RabbitMQ server 提供服务时，可以划分出多个 virtual host，每个用户在自己的 virtual host 创建 exchange/queue 等。 Connection： publisher/consumer 和 broker 之间的 TCP 连接。断开连接的操作只会在 client 端进行，broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。 Channel：如果每一次访问 RabbitMQ server 都建立一个 connection，在消息量大的时候建立 TCP connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，channel 作为轻量级的 connection 极大减少了操作系统建立 TCP connection 的开销。 Message：服务器和应用程序之间传送的数据，由 properties 和 body 组成。Properties 可以对 message 进行修饰，比如 message 的优先级、延迟等高级特性，body 就是 message 内容。 Queue：消息最终被送到这里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。 Exchange： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。 Binding： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。 Routing Key：单个路由规则，虚拟机可用它来确定如何路由一个 message。 协议模型消息流转Exchange 类型主要有 3 种类型的 exchange。 Direct Exchange（直连交换机） Topic Exchange（主题交换机） Fanout Exchange（扇型交换机）Direct Exchange消息传递时，Routing Key 必须完全匹配才会被队列接收，否则该消息会被抛弃。Topic Exchange模糊匹配的机制。 * 匹配一个单词 # 匹配零个或多个单词 发送到 topic exchange 的消息会被转发到所有关心 routing key 中指定 topic 的 queue 上 当特殊字符“*”（星号）和“＃”（哈希）未在绑定中使用时，主题交换机的行为就像直接交换机一样。例如上图示例创建了三个绑定：Q1 绑定了绑定键 *.orange.*，Q2 绑定了*.*.rabbit 和 lazy.#。 Q1 对所有 orange 感兴趣 Q2 希望听到关于 rabbit 的一切，以及关于 lazy 的一切那么消息经过 topic exchange 的路由结果将会是如下情况。 quick.orange.rabbit 的消息会同时传递到两个队列 lazy.orange.elephant 的消息也会同事传递到两个队列 quick.orange.fox 只会传递到 Q1 lazy.brown.fox 只会转到 Q2 lazy.pink.rabbit 只会递到 Q2 一次，即使它匹配两个绑定 quick.brown.fox 与任何绑定都不匹配，因此它将被丢弃 lazy.orange.male.rabbit 虽然有四个单词，也会匹配最后一个绑定，并将被传递到 Q2Fanout Exchange名字比较形象了，像 fan 一样甩出消息到所有绑定的队列。 不处理 routing key，只需要简单的将队列绑定到交换机上 发送到 fanout exchange 的消息都会被转发到与该交换机绑定的所有队列上 Fanout Exchange 转发消息是最快的RabbitMQRabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ 服务器是用 Erlang 语言编写的。 RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman. The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ messages.安装官网给了安装指引，MacOS 下用 HomeBrew 比较简单方便，但 Linux 下的步骤稍显凌乱，这里整理下 Ubuntu 的安装步骤。 添加 apt 仓库签名密钥 ## Team RabbitMQ&#39;s main signing keysudo apt-key adv --keyserver &quot;hkps://keys.openpgp.org&quot; --recv-keys &quot;0x0A9AF2115F4687BD29803A206B73A36E6026DFCA&quot;## Launchpad PPA that provides modern Erlang releasessudo apt-key adv --keyserver &quot;keyserver.ubuntu.com&quot; --recv-keys &quot;F77F1EDA57EBB1CC&quot;## PackageCloud RabbitMQ repositorycurl -1sLf &#39;https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey&#39; | apt-key add - 安装 apt-transport-https，以便能够从 PackageCloud、Cloudsmith.io、Launchpad 下载 RabbitMQ 和 Erlang 的包文件 sudo apt-get install apt-transport-https 添加第三方软件源，将以下内容添加至 /etc/apt/sources.list.d/rabbitmq.list，需要注意不同的 Ubuntu 版本的 distribution name 有差别。 focal for Ubuntu 20.04 bionic for Ubuntu 18.04 xenial for Ubuntu 16.04 buster for Debian Buster # Source repository definition example. ## Provides modern Erlang/OTP releases#### &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release.## See the release to distribution mapping table in RabbitMQ doc guides to learn more.deb http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic maindeb-src http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main ## Provides RabbitMQ#### &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release.## See the release to distribution mapping table in RabbitMQ doc guides to learn more.deb https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic maindeb-src https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main 安装 RabbitMQ 及其相关依赖的包 ## Update package indicessudo apt-get update -y ## Install Erlang packagessudo apt-get install -y erlang-base \\ erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \\ erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \\ erlang-runtime-tools erlang-snmp erlang-ssl \\ erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl ## Install rabbitmq-server and its dependenciessudo apt-get install rabbitmq-server -y --fix-missing 启停和界面# 启动sudo service rabbitmq-server start# 停止sudo service rabbitmq-server stop # 重启sudo service rabbitmq-server restart # 查看当前状态sudo service rabbitmq-server status RabbitMQ 提供了一个管理插件（rabbitmq_management），方便在 web 端管理 RabbitMQ，默认未开启需要在命令行开启该插件。开启插件并重启 RabbitMQ server 后，就可以通过浏览器进行管理，默认端口是 15672。# 开启管理工具，然后重启服务即可通过 web 进行管理sudo rabbitmq-plugins enable rabbitmq_management默认有一个 guest/guest 的用户可以用来登录管理工具，同时也可以通过命令新建用户和赋予权限。# 添加 admin/admin 用户sudo rabbitmqctl add_user admin admin# 赋予其管理员权限sudo rabbitmqctl set_user_tags admin administrator 示例官网的一些开发示例：RabbitMQ Tutorials" }, { "title": "Git 对象", "url": "/posts/git_inner/", "categories": "tool", "tags": "git", "date": "2021-05-05 00:00:00 +0800", "snippet": ".git这个隐藏文件夹可以视为 git 的本地仓库，其内部文件主要由以下部分组成，有些是文件有些是文件夹。└── .git├── COMMIT_EDITMSG # 保存最新的commit message├── config # 仓库的配置文件├── description # 仓库的描述信息，主要给 gitweb 使用├── HEAD # 指向当前分支├── hooks # 存放一些shell脚本，可以设置特定的git命令后触发相应的脚本，.sample 后缀的脚本文件不会被执行├── index # 二进制暂存区（stage）├── info # 仓库的其他信息│ └── exclude # 本地的排除文件规则，功能和 .gitignore 类似，区别在于 .gitignore 会被提交到版本库中，info/exclude 文件中的排除规则不会被提交到版本库├── logs # 保存所有更新操作的引用记录，主要用于 git reflog 等├── objects # 所有文件的存储对象，以 hash 值最为目录名，前两位 hash 值作为父目录└── refs # 具体的引用，主要存储分支和标签的引用，是提交对象（commit object）的指针，把 hash 映射为 branch name其中四个条目很重要：HEAD 文件、index 文件，objects 目录、refs 目录。 HEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支。某些情况下，HEAD 文件可能会包含一个 git 对象的 SHA-1 值，譬如 checkout FETCH_HEAD 后。 index 文件保存暂存区信息 objects 目录存储所有数据内容 refs 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针对象git 内部有三类对象，数据对象、树对象和提交对象。 数据对象（blob object），只存文件内容 树对象（tree object），组织结构并存储文件名 提交对象（commit object），包含提交信息和树对象git对象存储向 Git 仓库提交的所有对象都会有个头部信息一并被保存。头部信息内容为：类型（blob、tree、commit） + 文件长度 + null每次我们运行 git add 和 git commit 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象，更新暂存区，记录树对象（index 文件），最后创建一个指明了顶层树对象和父提交的提交对象。底层工具git 附带了一些底层工具，可以进行一些诸如 hash 计算等的底层操作，实际上 git 的各个命令也都是利用底层工具实现的。 git hash-object 计算 hash 键值。 -w 会指示该命令不要只返回键，还要将该对象写入数据库中。 # 对一个文件进行 hash 计算， 并写该文件到 git 库$ echo &#39;test content&#39; | git hash-object -w --stdin git cat-file 显示文件内容 # 显示文件内容$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4# 显示文件类型$ git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e4 git update-index 创建暂存区 # 从 git 库创建暂存$ git update-index --add --cacheinfo 100644 `blob hashcode` test.txt# 从工作区创建暂存$ git update-index --add new.txt git write-tree 生成树对象 # 从暂存区生成树对象$ git write-tree git commit-tree 生成提交对象 # 首次提交，无父提交$ echo &#39;first commit&#39; | git commit-tree `tree hashcode`# 非首次提交，有父提交$ echo &#39;second commit&#39; | git commit-tree `tree hashcode` -p `parent commit hashcode` " }, { "title": "Java Annotation", "url": "/posts/annotation/", "categories": "language, java", "tags": "annotation", "date": "2021-05-05 00:00:00 +0800", "snippet": "Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。Java 7 又增加了3个注解。作用在代码的注解 @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。元注解 @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类)Java 7 新增 @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。三个重要类：Annotation、ElementType、RetentionPolicyAnnotation，是个接口，声明了 equals、hashcode、toString、annotationType 方法。ElementType，是个枚举类型，指定注解类型，表示其可以使用的地方。public enum ElementType { TYPE, /* 类、接口（包括注释类型）或枚举声明 */ FIELD, /* 字段声明（包括枚举常量） */ METHOD, /* 方法声明 */ PARAMETER, /* 参数声明 */ CONSTRUCTOR, /* 构造方法声明 */ LOCAL_VARIABLE, /* 局部变量声明 */ ANNOTATION_TYPE, /* 注释类型声明 */ PACKAGE /* 包声明 */ TYPE_PARAMETER, /* 类型参数 */ TYPE_USE /* 类型使用 */}RetentionPolicy，也是枚举，表示如何保存该注解。public enum RetentionPolicy { SOURCE, /* 注解将被编译器丢弃（注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里），如 @Override */ CLASS, /* 默认级别，注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候不会加载到虚拟机JVM） */ RUNTIME /* VM将在运行期也保留注解信息，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息） */}元注解@Documented -- @Documented 所标注内容，可以出现在javadoc中。@Inherited -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。@Retention -- @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。默认 class 级别。@Target -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。没有 Target 的注解，默认可以用在所有地方。@SuppressWarnings 常用关键字deprecation -- 使用了不赞成使用的类或方法时的警告unchecked -- 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。fallthrough -- 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。path -- 在类路径、源文件路径等中有不存在的路径时的警告。serial -- 当在可序列化的类上缺少 serialVersionUID 定义时的警告。finally -- 任何 finally 子句不能正常完成时的警告。all -- 关于以上所有情况的警告。" }, { "title": "SSH", "url": "/posts/ssh/", "categories": "tool", "tags": "ssh", "date": "2021-04-24 00:00:00 +0800", "snippet": "SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信。OpenSSH 是其一个开源实现。SSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 ssh；接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 sshd。OpenSSH 同时提供了辅助工具，比如文件传输相关的 scp 和 sftp，密钥管理相关的 ssh-keygen 等。基本用法登陆服务器服务器上运行有 SSH 服务软件时，客户端可以进行登陆。# 登陆 host，之后输入密码（默认采用与当前客户端相同的用户名进行登陆）$ ssh host# 指定用户名登陆 host$ ssh user@host# 指定用户名登陆 host$ ssh -l user host# 指定端口登陆 host$ ssh -p 22 host连接过程首次登陆服务器时，命令行会提示服务器的指纹是陌生的，让用户进行选择是否继续进行连接，用户输入 yes 后服务器指纹会存入 ~/.ssh/known_hosts 文件，之后再连接该服务器就不会再提示。# 第一次连接陌生指纹提示The authenticity of host &#39;xxx&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:xxx.Are you sure you want to continue connecting (yes/no)?# 命令行查看公钥指纹$ ssh-keygen -l -f ~/.ssh/xxx.pub# 查看已保存的指纹$ cat ~/.ssh/know_hosts当服务器的密钥因重装或者其他原因更改了密钥时，连接服务器会提示指纹不符，这时需要将本地已存储的指纹，然后再进行连接。# 指纹不符提示@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!...# 删除指纹$ ssh-keygen -R hostname执行远程命令SSH 登录成功后，用户就进入了远程主机的命令行环境。如果仅仅想执行一条远程指令也可以将命令直接写在 ssh 命令之后。$ ssh username@hostname command# 下面是在远程服务器上执行 cat 命令，并在本地主机显示结果$ ssh foo@server.example.com cat /etc/hosts采用上边的语法执行命令时，ssh 客户端不会提供互动式的 Shell 环境，而是直接远程命令的执行结果输出在命令行。但是，有些命令需要互动式的 Shell 环境，这时就要使用 -t 参数。# 报错$ ssh remote.server.com emacsemacs: standard input is not a tty# 不报错$ ssh -t server.example.com emacs主机配置用户的配置文件 ~/.ssh/config，可以按照不同服务器，列出各自的连接参数，从而不必每一次登录都输入重复的参数。Host * Port 2222Host remoteserver HostName remote.example.com User neo Port 2112上面配置中，Host * 表示对所有主机生效，后面的 Port 2222 表示所有主机的默认连接端口都是 2222，这样就不用在登录时特别指定端口了。这里的缩进并不是必需的，只是为了视觉上，易于识别针对不同主机的设置。后面的 Host remoteserver 表示，设置只对主机 remoteserver 生效。remoteserver 只是一个别名，具体的主机由 HostName 命令指定，User 和 Port 这两项分别表示用户名和端口。这里的 Port 会覆盖上面 Host * 部分的 Port 设置。以后，登录 remote.example.com 时，只要执行 ssh remoteserver 命令，就会自动套用 config 文件里面指定的参数。$ ssh remoteserver# 等同于$ ssh -p 2112 neo@remote.example.com密钥登陆利用非对称加密，ssh 可以实现方便的密钥登陆，而不用每次登陆都输入用户名和密码。登陆过程分为以下步骤。 客户端通过 ssh-keygen 生成自己的公钥和私钥。 手动将客户端的公钥放入远程服务器的指定位置。 客户端向服务器发起 SSH 登录的请求。 服务器收到用户 SSH 登录的请求，发送一些随机数据给用户，要求用户证明自己的身份。 客户端收到服务器发来的数据，使用私钥对数据进行签名，然后再发还给服务器。 服务器收到客户端发来的加密签名后，使用对应的公钥解密，然后跟原始数据比较。如果一致，就允许用户登录。生成密钥的过程就是通过 ssh-kengen 工具进行。# -t 指定加密算法，-C 添加额外的备注，以便区分多个密钥$ ssh-keygen -t rsa -C comments# 执行命令后，会要求指定密钥文件名和密码，没有特殊要求可以保持默认Enter file in which to save the key (/home/username/.ssh/id_dsa): press ENTEREnter passphrase (empty for no passphrase): ********Enter same passphrase again: ********Your identification has been saved in /home/username/.ssh/id_dsa.Your public key has been saved in /home/username/.ssh/id_dsa.pub.The key fingerprint is:...# 最后可以通过 cat 查看公钥# 如果选择rsa算法，生成的密钥文件默认就会是~/.ssh/id_rsa（私钥）和~/.ssh/id_rsa.pub（公钥）。上传公钥可以手动上传，也可以通过 ssh-copy-id 工具实现上传。OpenSSH 规定，用户公钥保存在服务器的 ~/.ssh/authorized_keys 文件。你要以哪个用户的身份登录到服务器，密钥就必须保存在该用户主目录的 ~/.ssh/authorized_keys 文件。只要把公钥添加到这个文件之中，就相当于公钥上传到服务器了。每个公钥占据一行。如果该文件不存在，可以手动创建。用户可以手动编辑该文件，把公钥粘贴进去，也可以在本机计算机上，执行下面的命令。$ cat ~/.ssh/id_rsa.pub | ssh user@host &quot;mkdir -p ~/.ssh &amp;amp;&amp;amp; cat &amp;gt;&amp;gt; ~/.ssh/authorized_keys&quot;通过 ssh-copy-id 工具，用户在本地计算机执行下面的命令，也可以把本地的公钥拷贝到服务器。$ ssh-copy-id -i key_file user@host端口转发（SSH 隧道）SSH 除了登录服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的通信加密跳板，使得原本不加密的通信变成加密通信。这个功能称为端口转发（port forwarding），又称 SSH 隧道（tunnel）。端口转发有三种使用方法：动态转发（-D），本地转发（-L），远程转发（-R）。动态转发动态转发指的是，本机与 SSH 服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过 SSH 转发，譬如科学上网。# -N 表示只进行转发$ ssh -D local-port tunnel-host -N# 例如全部都通过本地端口 2121$ ssh -D 2121 tunnel-host -N动态转发采用了 SOCKS5 协议。访问外部网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。下面是 SSH 隧道建立后的一个使用实例，或者也可以利用浏览器配置代理。$ curl -x socks5://localhost:2121 http://www.example.com本地转发本地转发（local forwarding）指的是，SSH 服务器作为中介的跳板机，建立本地计算机与特定目标网站之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。它会指定一个本地端口（local-port），所有发向那个端口的请求，都会转发到 SSH 跳板机（tunnel-host），然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。$ ssh -L local-port:target-host:target-port tunnel-host# 访问本地 2121 端口，即可实现通过 tunnel-host 访问 example 的 80 端口$ ssh -L 2121:www.example.com:80 tunnel-host -N远程转发远程端口指的是在远程 SSH 服务器建立的转发规则。这种场景比较特殊，主要针对内网的情况。本地计算机在外网，SSH 跳板机和目标服务器都在内网，而且本地计算机无法访问内网之中的 SSH 跳板机，但是 SSH 跳板机可以访问本机计算机。由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。必须反过来，从 SSH 跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。# 注意此命令不在本地机器执行，而是在跳板机执行，本地机器对跳板机来说是远程主机# 另外，本地机器需要安装 ssh 服务器，否则跳板机无法连接本地机器$ ssh -R local-port:target-host:target-port -N local# 跳板机绑定本地机器 2121 端口，实现对 example 的 80 端口访问$ ssh -R 2121:www.example.com:80 local -N# 从本机访问目标服务器$ curl http://localhost:2121文件传输scp、sftp、rsync 可以用来在本地主机和远程服务器之间传输文件。scp用来在两台主机之间加密传送文件（即复制文件），用于以下三种操作。 本地复制到远程。 远程复制到本地。 两个远程系统之间的复制。# 本地 -&amp;gt; 远程$ scp SourceFile user@host:directory/TargetFile# 示例$ scp file.txt remote_username@10.10.0.2:/remote/directory# 远程 -&amp;gt; 本地$ scp user@host:directory/SourceFile TargetFile# 示例$ scp remote_username@10.10.0.2:/remote/file.txt /local/directory# 远程 -&amp;gt; 远程$ scp user@host1:directory/SourceFile user@host2:directory/SourceFile# 示例$ scp user1@host1.com:/files/file.txt user2@host2.com:/files# 参数-l 限制带宽（Kb/s）-p 保留原始文件信息（修改、访问时间，文件状态）-r 递归复制目录-v 详细输出sftp相当于将 FTP 放入了 SSH。# 连接远程主机$ sftp username@hostname# 连接后，命令与 ftp 用法一致ls [directory]：列出一个远程目录的内容。如果没有指定目标目录，则默认列出当前目录。cd directory：从当前目录改到指定目录。mkdir directory：创建一个远程目录。rmdir path：删除一个远程目录。put localfile [remotefile]：本地文件传输到远程主机。get remotefile [localfile]：远程文件传输到本地。help：显示帮助信息。bye：退出 sftp。quit：退出 sftp。exit：退出 sftp。rsyncrsync 不是 SSH 工具集的一部分，但也涉及到远程操作，可以用来同步文件，在本地计算机与远程计算机之间，或者两个本地目录之间同步文件。配合上 crontab 就可以定时同步。$ rsync -av source destination$ rsync -av source/ username@remote_host:destination$ rsync -av username@remote_host:source/ destination# 参数-r 递归目录-a 等价于 -r + 同步文件元信息，更为常用-n dry-run，干跑看效果-v 详细输出--delete rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用--delete参数，这将删除只存在于目标目录、不存在于源目录的文件。--exclude 排除文件" }, { "title": "Vim Shortcuts", "url": "/posts/vim_shortcuts/", "categories": "tool", "tags": "vim", "date": "2021-04-23 00:00:00 +0800", "snippet": "网上的一篇 vim 新手教程，非常不错。简明 VIM 练级攻略:help x 命令帮助:e file 打开另一个文件到 buffer:bn 切换 buffer:bp 切换 buffer. 重复上个命令N&amp;lt;command&amp;gt; 重复某个命令 N 次100ihello [esc] 插入 100 个 hello% 括号跳转* # 匹配光标当前所在的单词，移动光标到下一个匹配单词fx 移动到下一个 x 字符处3fx 移动到第 3 个 x 字符处tx 移动到下一个 x 的前一字符处dtx 删除直到遇到下一个 x 字符ytx 复制到下一个 x 字符处ctx 类似 dtx，只是会进入 insert&amp;lt;action&amp;gt;a&amp;lt;object&amp;gt; 或 &amp;lt;action&amp;gt;i&amp;lt;object&amp;gt;，这两个命令非常强大。 action 可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。 object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落，也可以是一个特别的字符：&quot;、 &#39;、 )、 }、 ]。假设你有一个字符串 (map (+) (&quot;foo&quot;)).而光标键在第一个 o 的位置。 vi&quot; → 会选择 foo. va&quot; → 会选择 &quot;foo&quot;. vi) → 会选择 &quot;foo&quot;. va) → 会选择(&quot;foo&quot;). v2i) → 会选择 map (+) (&quot;foo&quot;) v2a) → 会选择 (map (+) (&quot;foo&quot;)) 宏录制 qa 把你的操作记录在寄存器 a。 于是 @a 会replay被录制的宏。 @@ 是一个快捷键用来replay最新录制的宏。 示例 在一个只有一行且这一行只有“1”的文本中，键入如下命令： qaYpq qa 开始录制 Yp 复制行 &amp;lt;C-a&amp;gt; 增加1 q 停止录制 @a → 在1下面写下 2 @@ → 在2 正面写下3 现在做 100@@ 会创建新的100行，并把数据增加到 103. 以下是自己之前的一些记录，学而时习之。移动Normal 模式下gg 首行G 末行#G/gg 第 # 行H 屏幕最上方M 屏幕中间L 屏幕最下方% 括号内，在左右两括号间跳转（默认支持大、中、小三种括号）0 行首^ 非空行首$ 行尾f/Fx 跳到下/前一个 x 出现的位置{ 下一个段落} 上一个段落zz 光标所在处滚动到屏幕中央C-e 屏幕下滚一行C-y 屏幕上滚一行C-d 光标下移半屏幕C-u 光标上移半屏幕C-f 光标下移整屏幕C-b 光标上移整屏幕[{ 跳转到当前代码段开始处]} 跳转到当前代码段结束处hjkl 左上下右w/W 到下一个单词首e/E 到当前单词末尾b/B 到前一单词首#xxx 以上命令之前可以加数字，表示执行多次编辑Normal 模式下I 行首插入i 光标前插入a 光标后插入A 行尾插入o 在后一行插入O 在前一行插入ea 当前词尾插入x 删除当前字符#x 删除 # 个字符dw/W 删除单词（光标处到词尾）diw/W 删除单词（单词头到单词尾）d0/$ 删除到行首/尾dd 删除当前行d#w 删除 # 个单词#dd 删除 # 行dib/B 删除代码段dab/B 删除代码段（连带括号）das 删除语句yw/W 复制到词尾yiw/W 复制当前词y0/$ 复制到行首/尾yy 复制当前行y#w 复制 # 个词#yy 复制 # 行yib/B 复制代码段yab/B 复制代码段（连带括号）yas 复制语句“+y 复制到系统剪切板p 行后粘贴P 行前粘贴“+p 从系统剪切板粘贴rx 用新字符 x 替换当前光标下的字符R 进入 replace 模式，可以连续替换字符cw/W 删除到词尾，并进入 insert 模式（change）ciw/W 删除当前单词，并进入 insert 模式ce/E 删除到词尾，并进入 insert 模式c#w/e 删除多个单词，并进入 insert 模式c0/$ 删除到行首/尾，并进入 insert 模式cc 删除整行，并进入 insert 模式cib/B 删除代码段，并进入 insert 模式 cab/B 删除代码段（连带括号），并进入 insert 模式cas 删除语句，并进入 insert 模式s 删除当前字符，并进入 insert 模式J 用空格连接当前行和下一行gJ 直接连接当前行和下一行#J 连接 # 行u undoU undo 当前行C-r redog~ 随着光标移动切换大小写gu 随着光标移动切换小写gU 随着光标移动切换大写&amp;gt;&amp;gt; 增加缩进 &amp;lt;&amp;lt; 减少缩进Insert 模式下C-h 删除前一个字符C-w 删除前一个单词C-t 缩进C-d 减少缩进查找Normal 模式下（hlsearch，incsearch）* 搜索当前光标下的单词并高亮/xxx 回车后，查找 xxx，n 向下查找，N 向上查找?xxx 与 / 查找相反:s/old/new/g 在当前行做文本替换:#,#s/old/new/g 在 #,# 行间做文本替换:%s/old/new/g 在全文做文本替换:%s/old/new/gc 每次替换前进行确认读写文件Visual 模式下:w filename 写选中内容到新文件Normal 模式下:r filename 读文件内容到当前行:r !cmd 读 cmd 执行结果到当前行:w file 另存为文件 file:m,n w file m-n 行另存到文件 file 中:m,n w &amp;gt;&amp;gt; file m-n 行追加到文件 file 中可视模式Visual 模式下（v，V，C-v）aw 标记单词a/ib 标记 () 块a/iB 标记 {} 块a/it 标记 &amp;lt;&amp;gt; 块y 复制d 删除~ 切换大小写u 改为小写U 改为大写J 连接所有行&amp;lt; &amp;gt; 左右缩进= 自动缩进标记和位置Normal 模式下m[a-z] 为当前位置做标记`[a-z] 跳转到某位置:marks 查看所有标记:ju 查看所有跳转位置`` 跳转到上次位置命令C-g 在状态栏显示当前光标所处位置:ter 打开一个终端:!cmd 执行一个 cmd 命令:x wqK man 当前光标所在词gt/T 切换标签ga 显示光标下字符的 ASCII窗口C-ww 切换窗口C-wq 关闭窗口C-ws 分割窗口C-wv 竖直分割窗口C-wh/j/k/l 移动光标到相应窗口操作 连续替换* cw xxx esc n .* 用来搜索当前光标下的单词cw 改写该单词xxx 为新单词n 跳转到下一处. 重复执行 插入多次3i xxx esc3i 表示 3 次重复xxx 需要写入的词ese 执行 3 次重复 多行注释C-v &amp;lt;select&amp;gt; I # esc escC-v 进入块选择模式&amp;lt;select&amp;gt; 选择行I 插入（大写 I）# 插入注释符号esc 两次 esc 执行" }, { "title": "googler", "url": "/posts/googler/", "categories": "tool", "tags": "", "date": "2021-04-14 00:00:00 +0800", "snippet": "googler，在命令行进行谷歌的工具，搜索后显示标题、梗概，并且可以操作在浏览器打开。用法 关键字搜索 $ googler xxx 参数 -n 每次结果显示数-N 搜索新闻-V 搜索视频-t 时间限制，-t [h5 (5 hrs), d5 (5 days), w5 (5 weeks), m5 (5 months), y5 (5years)]-w 搜索网站，-w zhihu.com 搜索结果出来后的操作 n, p 下一页，前一页index 在浏览器里打开f 转到第一页q 退出? 显示帮助* 其他输入作为下次输入的关键词 " }, { "title": "自由软件与开源许可", "url": "/posts/free_software_license/", "categories": "other", "tags": "gnu, gpl, mit, bsd, apache", "date": "2021-04-07 00:00:00 +0800", "snippet": "所谓自由软件（Free Software），就是让你可以自由使用的软件。英文 free software 里的 free 不是单单指免费（free of charge）的意思，而重要的是自由（freedom）的意思。自由软件的作者这样做，并不是因为他们不需要钱，而是因为他们觉得，自由比金钱更重要。 “自由软件”尊重用户的自由，并且尊重整个社区。粗略来讲，一个软件如果是自由软件，这意味着用户可以自由地运行，拷贝，分发，学习，修改并改进该软件。因此，“自由软件”是关乎自由的问题，与价格无关，软件如何定价并不影响它是否被归类为自由软件。 现在还有另外一伙人，使用“开源”一词来表达与“自由软件”类似，但不完全相同的概念。我们更倾向于使用“自由软件”这个词。因为一旦你看到自由二字，就明白了它所要表达的意思。而“开放”却并不意味着自由。 by Richard Stallman The terms “free software” and “open source” stand for almost the same range of programs. However, they say deeply different things about those programs, based on different values. The free software movement campaigns for freedom for the users of computing; it is a movement for freedom and justice. By contrast, the open source idea values mainly practical advantage and does not campaign for principles. This is why we do not agree with open source, and do not use that term.自由软件和开源软件总体上来说代表的同一类软件，但自由软件基金会的创始人理查德·斯托曼从理念的角度给出了其两者深层次的巨大差异。自由软件是以用户的自由作为出发点的，而开源软件则重视的是实践上的优势。开源许可开源许可证有很多种，但我们常见的主要有：MIT、BSD、Apache、LGPL 和 GPL。这里有这些许可的内容：https://opensource.org/licenses这些开源许可从宽松到严格排序是：MIT &amp;lt;= BSD &amp;lt; Apache &amp;lt; LGPL &amp;lt; GPLMIT、BSD 源自大学，体现了简单、开放和包容的特点。MIT、BSD、Apache 三者都支持闭源的后续开发，可以用在商业领域。GPL、LGPL 传染性开源，编译的代码里用了这里的代码，都必须开源。具体每一种许可的限制如下： MIT 只需要保留作者的版权，而再无其他任何限制。 有对软件/源码有无限制的处理权力，包括但不限于使用、复制、发布、出售等等 在项目副本中要包含版权声明和许可声明 作者和版权所有者无需承担任何责任 BSD BSD 分为 2-Clause 和 3-Clause 两种，2-Clause 的又叫做 FreeBSD。3-Clause 是额外增加了不可以用作者或者贡献者的名字做推广的要求。 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的 BSD 协议。 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的 BSD 协议。 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 Apache License 2.0 需要给代码的用户一份Apache Licence。 需要对任何被修改文件进行说明。 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 如果再发布的产品中包含一个 Notice 文件，则在 Notice 文件中需要带有 Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。 GPL 来源自由软件联盟 GNU，GPL/LGPL 侧重于代码及衍生代码的开源与免费使用。 GPL 协议的主要内容是只要在一个软件中使用（“使用”指类库引用，修改代码或者衍生代码）GPL 协议的产品，则该软件产品必须也采用 GPL 协议，既必须也是开源和免费，这就是所谓的”传染性”。 Linux 采用了 GPL。 LGPL Lesser GPL 是稍宽松的 GPL 许可。LGPL 跟 GPL 的主要差别在于引用方式的类库在 LGPL 许可下不需要开源，这就使得其可以以类库引用的方式应用在商业软件上，不需要商业软件强制开源。 但如果需要修改 LGPL 许可的代码或者衍生，那所有修改的代码或者衍生代码依然还是需要采用 LGPL 许可。 最后附上阮一峰老师制作的中文版开源许可选择图。" }, { "title": "vim插件", "url": "/posts/vim_plugin/", "categories": "tool", "tags": "vim", "date": "2021-04-06 00:00:00 +0800", "snippet": "VundleVim 的插件管理器，可以很方便的管理 Vim 插件，包括安装、更新、卸载。 安装 Vundle 到 Vim 的用户目录，git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 配置插件，编辑 .vimrc 文件，加入需要的插件，以下以 Plugin 开头的行即位需要添加的插件，其余为 Vundle 必须的脚本 &quot; vundle 环境设置开始filetype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin &#39;VundleVim/Vundle.vim&#39;Plugin &#39;scrooloose/nerdtree&#39;Plugin &#39;majutsushi/tagbar&#39;Plugin &#39;scrooloose/syntastic&#39;Plugin &#39;valloric/youcompleteme&#39;Plugin &#39;morhetz/gruvbox&#39;Plugin &#39;vim-airline/vim-airline&#39;call vundle#end()filetype plugin indent on&quot; vundle 环境设置结束 启动 Vim，执行 :PluginInstall ；或者直接在命令行执行 vim +PluginInstall +qall 安装完毕后，可以通过 :h vundle 查看帮助文档 所有安装的插件都在 ~/.vim/bundle/ 路径下，可以比较直观的看出来装了哪些插件 推荐插件 NERDTreeNERDTree 是 Vim 的文件系统浏览器，安装该插件后可以在 Vim 里进行文件系统的可视化浏览，效果非常好，可以非常方便的增删改文件。常用快捷键# 光标Ctrl + w + h 光标 focus 左侧树形目录Ctrl + w + l 光标 focus 右侧文件窗口Ctrl + w + w 光标 focus 左右切换# 编辑 &amp;amp; 预览o 打开文件，并跳转到编辑窗口go 打开文件，但不跳转到编辑窗口t 打开文件到新 tab 页，并跳转到编辑窗口T 打开文件到新 tab 页，但不跳转到编辑窗口i 水平分割打开文件gi 水平分割打开文件，不跳转s 竖直分割打开文件gs 竖直分割打开文件，不跳转# 操作? 帮助菜单m 打开系统操作菜单，可以复制、移动、删除、以系统 app 打开当前文件等gt 后一个 tabgT 前一个 tab有用的配置以下配置放在 .vimrc 中。# NERDTree 打开和关闭快捷键映射nmap &amp;lt;F3&amp;gt; :NERDTreeToggle&amp;lt;CR&amp;gt;# 进入 vim 就打开 NERDTreeautocmd vimenter * NERDTree# 当 NERDTree 是最后一个窗口时，关闭 vimautocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;amp;&amp;amp; exists(&quot;b:NERDTree&quot;) &amp;amp;&amp;amp; b:NERDTree.isTabTree()) | q | endif# 显示隐藏文件let g:NERDTreeShowHidden=1 TagbarTagbar 用来显示文件大纲，依赖 Ctags# Ctags 路径let g:Tlist_Ctags_Cmd=&#39;/usr/local/Cellar/ctags/5.8_1/bin/ctags&#39;# 触发快捷键nmap &amp;lt;F8&amp;gt; :TagbarToggle&amp;lt;CR&amp;gt; Syntastic语法检查，支持多种语言。官网推荐配置如下。set statusline+=%#warningmsg#set statusline+=%{SyntasticStatuslineFlag()}set statusline+=%*let g:syntastic_always_populate_loc_list = 1# 自动打开和关闭 error listlet g:syntastic_auto_loc_list = 1# 打开文件时是否进行检查let g:syntastic_check_on_open = 1# 保存文件时是否进行检查let g:syntastic_check_on_wq = 0 gruvbox一款比较火的主题。colorscheme gruvboxset background=dark YouCompleteMe代码补全大杀器，没怎么配置，因为依赖比较大，安装会慢很多。 vim-airline状态栏增强。let g:airline#extensions#tabline#enabled = 1let g:airline#extensions#tabline#left_sep = &#39; &#39;let g:airline#extensions#tabline#left_alt_sep = &#39;|&#39;" }, { "title": "网络协议", "url": "/posts/http/", "categories": "other", "tags": "http", "date": "2021-04-06 00:00:00 +0800", "snippet": "阮一峰老师的博客摘录。互联网协议入门（一）互联网协议入门（二）另外还有一个系列贴，讲解数据包如何在网络上进行传输，看完后对网络模型就有了很清楚的认识。Packet Traveling – Practical Networking .net五层网络协议模型 实体层（物理层） 物理层就是实体的网卡、光缆、双绞线等，通过物理的方式连接在一起，规定了电气层面的一些特性，用来传输高低电平，也就是 0、1 信号。 链接层 数据链路层定义 0、1 电信号的分组方式。以太网（Ethernet）协议是链路层中一个比较重要的协议。 以太网规定，一组电信号构成一个数据包，叫做帧（Frame）。每一帧分成两个部分：Head 和 Data。 Head 的长度，固定为 18 字节。Data 的长度，最短为 46 字节，最长为 1500 字节。因此，整个 frame 最短为 64 字节，最长为 1518 字节。如果数据很长，就必须分割成多个帧进行发送。 Mac 地址 以太网协议的头部包含了收发者的信息，收发者的信息通过 mac 地址进行标识。Mac 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示，前 6 个十六进制数表示厂商编号，后 6 个是网卡流水。 广播 &amp;amp; ARP 通过 ARP（Address Resolution Protocol） 协议可以通过 IP 地址获取到 Mac 地址。主机发送信息时将包含目标 IP 地址的 ARP 请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；局域网上主机收到广播后把广播中的 IP 地址与自身 IP 地址做比较，如果相同则回应 Mac 地址，否则就丢弃广播消息；主机收到返回消息后将该 IP 地址和 Mac 地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。 知道了目标的 Mac 地址后，以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。局域网内所有主机收到广播后与自身的 Mac 地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。 有了数据包的定义、网卡的 Mac 地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。 网络层 只依靠数据链路层确实可以实现不同主机间的通信，但有个问题是以太网采用广播的方式太消耗资源了，每个包都会广播到网络中，效率太低，而当主机越来越多时该机制基本就无效了。 互联网的子网络就是用来解决这个问题的，也就是网络层的作用。引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。如果是同一个子网络，就采用广播方式发送，否则就发送给默认网关通过”路由”方式发送。 网络地址帮助我们确定计算机所在的子网络，Mac 地址则将数据包送到该子网络中的目标网卡。 IP 协议 IP 用于规定网络地址，该地址称为 IP 地址。 IPv4 中网络地址由32个二进制位组成，分为 4 段，每段 8位，从 0.0.0.0 一直到 255.255.255.255。 互联网上的每一台计算机，都会分配到一个 IP 地址。前一部分代表网络，后一部分代表主机。子网掩码用来区分网络和主机，它的网络部分全部为1，主机部分全部为0。IP 地址与子网掩码做与运算后即可得到子网地址，而 IP 地址剩余的部分即为主机号。 传输层 通过 IP 地址和 Mac 地址，我们已经可以在互联网上任意两台主机上建立通信。但还有问题是，同一台主机上有许多程序（进程）都需要用到网络，比如，边浏览网页，边在线聊天，当一个数据包从互联网上发来的时候，如何知道它是表示网页的内容，还是表示在线聊天的内容？ 也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 传输层的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix 系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。 TCP &amp;amp; UDP TCP 和 UDP 是传输层的两个重要协议，UDP 实现简单可靠性差，DNS 查询用到了 UDP。TCP 相对 UDP 而言，带有确认机制，确保数据不会丢失，但实现复杂且需要消耗更多的资源。 应用层 应用层就是规定应用程序的数据格式。这里的协议就很多了，HTTP、HTTPS、FTP、SSH 等等。 HTTP 协议HTTP 协议（Hyper Text Transfer Protocol）用于从服务器传输超文本到本地浏览器。HTTP 默认端口 80，HTTPS 默认端口443。HTTP 无连接、无状态。客户端请求消息包含：请求行、请求头部、空行、请求数据。服务器响应消息包含：状态行、消息报头、空行、响应正文。客户端请求方法：   方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 服务器响应码： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 " }, { "title": "OpenMediaVault", "url": "/posts/omv/", "categories": "pi", "tags": "nas", "date": "2019-11-03 00:00:00 +0800", "snippet": "OpenMediaValut，是一款基于 Debian 专门为 NAS 设计的Linux发行版。镜像下载地址：https://sourceforge.net/projects/openmediavault/files/Raspberry%20Pi%20images/，3B+、4都支持。安装烧录镜像到 SD 卡，启动树莓派，第一次启动需要连显示器和键盘，因为默认的80端口访问不到。需要改成其他端口才能通过web访问。具体步骤： 烧录镜像，连接树莓派到显示器和键盘，启动树莓派。 启动后等待login提示，用户名/密码：admin/openmeidavault，root/openmediavault，用 admin 账户登陆好像没效果，需要用 root 账户登陆，第一次登陆会强制要求改密码，改完密码正式登陆到系统。 输入命令：omv-firstaid，在 Configure web control panel 里把端口号改掉，默认的 80 访问不了，我改成 8080 了。 在电脑上访问：ip:端口，用户名/密码：admin/openmeidavault。 配置，参考各类omv的配置教程就可以。插件autoshutdown：配置树莓派自动关机，这样上班的时候或者没有访问时关机，回家或者想访问时 wol 唤醒下就可以访问了。具体的 shutdown 规则：https://github.com/OpenMediaVault-Plugin-Developers/openmediavault-autoshutdown/blob/master/README/README_for_script。按 0-5 的优先级： Stayup-range: UPHOURS (is the server in the timerange, where it should stay online) IPs Ports (Network sockets) UL/DL-Rate in kB/s (only over the last minute) processes, daemons ASD-plugins性能树莓派3b+的100M网卡和4个USB2.0共用USB2.0 hub，所以网卡和usb2.0一分流基本上速度就是个位数的MB。频繁拷贝电影就不要想了，上传手机照片和浏览还能凑合用，看小视频也很流畅，没有速度需求或者使用量很少的化，树莓派3b+的omv可以用用。树莓派3b+的网卡芯片虽然支持 wol，但因为是 USB2.0 hub 转的，所以 wol 行不行取决于 usb 能不能用，树莓派3b+系统不运行的状态下，usb 处于掉电状态，所以 wol 没戏。树莓派4b是真·千兆网卡+2个USB3.0，所以用树莓派4b装omv组建家庭nas基本就够用了，但不知道树莓派4支不支持 wol。其他NAS蜗牛星际J1900，一套下来肯定比树莓派4b搭的实惠，而且性能也有保证。" }, { "title": "Lakka", "url": "/posts/lakka/", "categories": "pi", "tags": "", "date": "2019-11-03 00:00:00 +0800", "snippet": "Lakka 是 RetroArch 官方的 Linux 发行版，以多机种游戏模拟器 libretro 为核心。它能玩的游戏很多，街机游戏，红白机游戏，PS、PSP游戏等。树莓派上安装 Lakka 非常简单。下载镜像烧录到 MicroSD 卡中。下载地址：https://www.lakka.tv/get/linux/烧录软件：https://www.balena.io/etcher/配置： 时间：修改时区。 echo &quot;TIMEZONE=Asia/Shanghai&quot; &amp;gt; /storage/.cache/timezone 语言：如果需要改中文，需要额外下载个字库，系统自带的中文字库不全，界面上会有小方块。 字库放置位置：/storage/assets/xmb/monochrome。 ssh：默认不开启，需要在界面上打开，默认登陆名/密码：root/root。 smb：默认不开启，需要在界面上打开，开smb主要是往上边拷贝游戏rom。所有游戏的rom存放路径都是：/storage/rom。 PS游戏：https://www.lakka.tv/doc/playstation/，需要注意下rom格式（cue+bin），并把三个bios文件放到：/storagte/system。BIOS文件下载地址：http://eightvirtues.com/lakka/bios/psx/ 资源：http://www.rendiyu.com/emu/http://www.cqucg.com/index.php/archives/7/都配置好之后，扫描rom文件，打开时选对模拟器就可以玩了。" }, { "title": "格雷码计算", "url": "/posts/grey_code/", "categories": "language, algorithm", "tags": "bit, xor", "date": "2019-10-28 00:00:00 +0800", "snippet": "格雷码 Gray Code，又叫循环二进制码或反射二进制码，基本特点： 任意相邻两个数只有一位二进制数不同 首尾两个数也只有一位二进制数不同（所以叫循环二进制码）LeetCode上两道Gray Code题目：89. Gray Code1238. Circular Permutation in Binary Representation一、格雷码与二进制码转换Binary –&amp;gt; Gray code G(n-1) = B(n-1) G(i) = B(i+1) xor B(i), i = 0, 1, 2, … n-2int decimal2Gray(int x) { return x ^ x&amp;gt;&amp;gt;1;}Gray code –&amp;gt; Binary B(n-1) = G(n-1) B(i-1) = B(i) xor G(i-1), i = 1, 2, 3, … n-1int gray2Decimal(int x) { int b = x; while (x &amp;gt; 0) { x &amp;gt;&amp;gt;= 1; b ^= x; } return b;}二、异或二进制的位运算，用符号 XOR 或者 ^ 表示，运算法则是对运算符两侧数的每一个二进制位，同值取0，异值取1。性质： 交换律，A ^ B = B ^ A 结合律，A ^ (B ^ C) = (A ^ B) ^ C 任意X，X ^ X = 0，X ^ 0 = X 自反性，A ^ B ^ B = A ^ 0 = A应用： 一个数组存放若干整数，一个数出现奇数次，其余数均出现偶数次，找出这个出现奇数次的数？ 全部异或，偶数次的数X，X ^ X = 0，全部异或的结果即为奇数次的这个数。 " }, { "title": "httpie", "url": "/posts/httpie/", "categories": "tool", "tags": "http", "date": "2019-10-07 00:00:00 +0800", "snippet": "HTTPieHTTPie—aitch-tee-tee-pie—is a command line HTTP client with an intuitive UI, JSON support, syntax highlighting, wget-like downloads, plugins, and more.文档：https://httpie.org/doc翻译：https://keelii.com/2018/09/03/HTTPie/" }, { "title": "JsonPath", "url": "/posts/jsonpath/", "categories": "language, java", "tags": "json", "date": "2019-07-07 00:00:00 +0800", "snippet": "JsonPathJSONPath Online Evaluator&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.jayway.jsonpath&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;json-path&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.4.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;JsonPath 表达式可以用 . 或者 [] 表示。 $.store.book[0].title $[&#39;store&#39;][&#39;book&#39;][0][&#39;title&#39;] 符号 符号 描述 $ 根节点对象 @ 过滤器处理的当前节点对象 * 通配符，可以表示一个名字或数字 .. 全局匹配 .&amp;lt;name&amp;gt; .表示的子节点 [&#39;&amp;lt;name&amp;gt;&#39; (, &#39;&amp;lt;name&amp;gt;&#39;)] []表示的子节点 [&amp;lt;number&amp;gt; (, &amp;lt;number&amp;gt;)] 数组索引 [start:end] 数组切片 [?(&amp;lt;expression&amp;gt;)] 过滤器表达式，表达式结果必须是boolean 函数 函数 描述 输出 min() 数组里的最小值 Double max() 数组里的最大值 Double avg() 数组平均值 Double stddev() 数组标准差 Double length() 数组长度 Integer 过滤器 操作 描述 == 等于 != 不等 &amp;lt; 小于 &amp;lt;= 小于等于 &amp;gt; 大于 &amp;gt;= 大于等于 =~ 正则表达式，例如 [?(@.name =~ /foo.*?/i)] in 包含， 例如 [?(@.size in [‘S’, ‘M’])] nin 不包含 subsetof 子集，例如 [?(@.sizes subsetof [‘S’, ‘M’, ‘L’])] anyof 有交集，例如 [?(@.sizes anyof [‘M’, ‘L’])] noneof 无交集，例如 [?(@.sizes noneof [‘M’, ‘L’])] size 数组、字符串长度相等 empty 数组、字符串为空 示例给定Json：{ &quot;store&quot;: { &quot;book&quot;: [ { &quot;category&quot;: &quot;reference&quot;, &quot;author&quot;: &quot;Nigel Rees&quot;, &quot;title&quot;: &quot;Sayings of the Century&quot;, &quot;price&quot;: 8.95 }, { &quot;category&quot;: &quot;fiction&quot;, &quot;author&quot;: &quot;Evelyn Waugh&quot;, &quot;title&quot;: &quot;Sword of Honour&quot;, &quot;price&quot;: 12.99 }, { &quot;category&quot;: &quot;fiction&quot;, &quot;author&quot;: &quot;Herman Melville&quot;, &quot;title&quot;: &quot;Moby Dick&quot;, &quot;isbn&quot;: &quot;0-553-21311-3&quot;, &quot;price&quot;: 8.99 }, { &quot;category&quot;: &quot;fiction&quot;, &quot;author&quot;: &quot;J. R. R. Tolkien&quot;, &quot;title&quot;: &quot;The Lord of the Rings&quot;, &quot;isbn&quot;: &quot;0-395-19395-8&quot;, &quot;price&quot;: 22.99 } ], &quot;bicycle&quot;: { &quot;color&quot;: &quot;red&quot;, &quot;price&quot;: 19.95 } }, &quot;expensive&quot;: 10}JsonPath 表达式及结果： JsonPath表达式 结果（点链接查看在线结果） $.store.book[*].author 全部书的作者 $..author 全部作者 $.store.* 全部东西 $.store..price 全部价格 $..book[2] 第3本 $..book[-2] 倒数第2本 $..book[0,1] 前2本 $..book[:2] 前2本 $..book[1:2] 第2本 $..book[-2:] 最后2本 $..book[2:] 第3本到最后 $..book[?(@.isbn)] 有 ISBN 的全部书 $.store.book[?(@.price &amp;lt; 10)] 价格小于 10 的全部书 $..book[?(@.price &amp;lt;= $[‘expensive’])] 价格小于 expensive 的全部书 $..book[?(@.author =~ /.*REES/i)] [作者符合正则表达式 /.REES/i 的全部书](https://jsonpath.herokuapp.com/?path=$..book[?(@.author =~ /.REES/i)]) $..* 全部 $..book.length() 书的数量 用法 单次读取 String json = &quot;...&quot;; List&amp;lt;String&amp;gt; authors = JsonPath.read(json, &quot;$.store.book[*].author&quot;); 多次读取：先解析 Json 为 ReadContext，再通过 ReadContext 读取，以避免多次解析 Json。 String json = &quot;...&quot;; ReadContext ctx = JsonPath.parse(json); List&amp;lt;String&amp;gt; authorsOfBooksWithISBN = ctx.read(&quot;$.store.book[?(@.isbn)].author&quot;); 返回值 JsonPath 表达式不明确时，返回值为 list 。不明确的表达式包含： ..：全局匹配 ?(&amp;lt;expression&amp;gt;)：过滤器表达式 [&amp;lt;number&amp;gt;, &amp;lt;number&amp;gt; (, &amp;lt;number&amp;gt;)]：多索引 JsonPath 表达式明确时，返回值为 POJO。 Configuration conf = Configuration.builder() .jsonProvider(new GsonJsonProvider()) .build();Book book = JsonPath.using(conf).parse(json).read(&quot;$.store.book[0]&quot;, Book.class); 泛型 TypeRef&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; typeRef = new TypeRef&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() {}; List&amp;lt;String&amp;gt; titles = JsonPath.parse(JSON_DOCUMENT).read(&quot;$.store.book[*].title&quot;, typeRef); 配置Configuration.builder() 实现对 JsonPath 配置。Configuration conf = Configuration.builder() .options(Option.ALWAYS_RETURN_LIST) .build();共5个配置选项： Option.DEFAULT_PATH_LEAF_TO_NULL：配置后空节点返回 null。 * [* {* &quot;foo&quot; : &quot;foo1&quot;,* &quot;bar&quot; : &quot;bar1&quot;* }* {* &quot;foo&quot; : &quot;foo2&quot;* }* ]*&amp;lt;/pre&amp;gt;** the path :** &quot;$[*].bar&quot;** Without flag [&quot;bar1&quot;] is returned* With flag [&quot;bar1&quot;, null] is returned Option.ALWAYS_RETURN_LIST：配置后返回值为 list，不返回 POJO。 Option.AS_PATH_LIST：配置后返回值为路径，非对象。 Configuration conf = Configuration.builder() .options(Option.AS_PATH_LIST).build(); List&amp;lt;String&amp;gt; pathList = using(conf).parse(json).read(&quot;$..author&quot;); assertThat(pathList).containsExactly( &quot;$[&#39;store&#39;][&#39;book&#39;][0][&#39;author&#39;]&quot;, &quot;$[&#39;store&#39;][&#39;book&#39;][1][&#39;author&#39;]&quot;, &quot;$[&#39;store&#39;][&#39;book&#39;][2][&#39;author&#39;]&quot;, &quot;$[&#39;store&#39;][&#39;book&#39;][3][&#39;author&#39;]&quot;); Option.SUPPRESS_EXCEPTIONS：配置后异常被抑制。如果同时配置了 ALWAYS_RETURN_LIST ，发生异常时返回 empty list，否则返回 null。 Option.REQUIRE_PROPERTIES：禁止通配符。比如 $[*].b，会抛出 PathNotFoundException 异常。 " }, { "title": "Gson", "url": "/posts/gson/", "categories": "language, java", "tags": "gson, json", "date": "2019-07-07 00:00:00 +0800", "snippet": "[TOC]一位博主翻译的系列教程，都是官方推荐教程。Gson用户指南（中文翻译）Gson教程一（译）：Java-JSON的序列化和反序列化Gson教程二（译）：嵌套对象的序列化和反序列化Gson教程三（译）：Arrays和Lists的映射Gson教程四（译）：Maps的映射Gson教程五（译）：Sets的映射Gson教程六（译）：空值的映射Gson教程七（译）：@SerializedName和@ExposeGson教程八（译）：GsonBuilder基础以及命名策略Gson教程九（译）：强制序列化null值Gson教程十（译）：Exclusion StrategiesGson教程十一（译）：轻松使用仁慈的Gson（容错机制）Gson教程十二（译）：Float和Double类型的特殊值Gson教程十三：模型版本化、日期格式化、漂亮输出Gson完全教程：基础篇一、Gson 介绍Gson 是一个 Java 对象与 Json 格式互转的类库。 提供简单的 toJson() 和 fromJson() 方法用于 Java 对象和 Json 互转 允许已存在的、无法修改的类与 Json 互转 支持泛型 允许自定义对象的Json格式 支持复杂对象（多层继承、泛型）API Javadoc User guideGradle：dependencies { implementation &#39;com.google.code.gson:gson:2.8.5&#39;}Maven：&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.8.5&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;二、基本使用1. 序列化 字符串类型 String 转为 “xxx”：”name”: “Norman” 非字符串类型 int、boolean 等转为 xxx：”age”: 26 对象转为 {xxx}：”userAddress”: {xxx} 数组转为 [xxx]：”families”: [xxx]@AllArgsConstructorclass UserNested { String name; String email; int age; boolean isDeveloper; UserAddress userAddress; String[] families;}@AllArgsConstructorclass UserAddress { String street; String houseNumber; String city; String country;}UserAddress userAddress = new UserAddress( &quot;Main Street&quot;, &quot;42A&quot;, &quot;Magdeburg&quot;, &quot;Germany&quot;);UserNested userObject = new UserNested( &quot;Norman&quot;, &quot;norman@futurestud.io&quot;, 26, true, userAddress, new String[]{&quot;mother&quot;, &quot;father&quot;, &quot;son&quot;});Gson gson = new Gson();String userWithAddressJson = gson.toJson(userObject);System.out.println(userWithAddressJson);输出{ &quot;name&quot;: &quot;Norman&quot;, &quot;email&quot;: &quot;norman@futurestud.io&quot;, &quot;age&quot;: 26, &quot;isDeveloper&quot;: true, &quot;userAddress&quot;: { &quot;street&quot;: &quot;Main Street&quot;, &quot;houseNumber&quot;: &quot;42A&quot;, &quot;city&quot;: &quot;Magdeburg&quot;, &quot;country&quot;: &quot;Germany&quot; }, &quot;families&quot;: [ &quot;mother&quot;, &quot;father&quot;, &quot;son&quot; ]}2. 反序列化反序列化时需要指定具体类：gson.fromJson(restaurantJson, Restaurant.class)@Data@AllArgsConstructorclass Restaurant { String name; Owner owner; Cook cook; Waiter waiter;}@Data@AllArgsConstructorclass Owner { String name; UserAddress address;}@Data@AllArgsConstructorclass Cook { String name; int age; int salary;}@Data@AllArgsConstructorclass Waiter { String name; int age; int salary;}String restaurantJson = &quot;{ &#39;name&#39;:&#39;Future Studio Steak House&#39;, &#39;owner&#39;:{ &#39;name&#39;:&#39;Christian&#39;, &#39;address&#39;:{ &#39;city&#39;:&#39;Magdeburg&#39;, &#39;country&#39;:&#39;Germany&#39;, &#39;houseNumber&#39;:&#39;42&#39;, &#39;street&#39;:&#39;Main Street&#39;}},&#39;cook&#39;:{ &#39;age&#39;:18, &#39;name&#39;: &#39;Marcus&#39;, &#39;salary&#39;: 1500 }, &#39;waiter&#39;:{ &#39;age&#39;:18, &#39;name&#39;: &#39;Norman&#39;, &#39;salary&#39;: 1000}}&quot;;gson = new Gson();Restaurant restaurantObject = gson.fromJson(restaurantJson, Restaurant.class);System.out.println(restaurantObject);输出Restaurant(name=Future Studio Steak House, owner=Owner(name=Christian, address=UserAddress(street=Main Street, houseNumber=42, city=Magdeburg, country=Germany)), cook=Cook(name=Marcus, age=18, salary=1500), waiter=Waiter(name=Norman, age=18, salary=1000))3. 空值映射 While serializing, a null field is omitted from the output. While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans. 默认情况下 序列化时，Java对象里的空值被忽略 反序列化时，Json里的缺失项会被赋予默认值：对象为 null，数值类型为 0，布尔类型为 false@Data@AllArgsConstructorclass UserSimple { String name; String email; int age; boolean isDeveloper;}UserSimple userObject = new UserSimple(null, &quot;norman@futurestud.io&quot;, 26, true);Gson gson = new Gson();String userJson = gson.toJson(userObject);System.out.println(userJson);输出{ &quot;email&quot;: &quot;norman@futurestud.io&quot;, &quot;age&quot;: 26, &quot;isDeveloper&quot;: true}三、泛型对于泛型会遇到泛型擦除的问题。譬如，对于 **Result** 和 **Result**，使用基本的fromJson 方法时 Gson 无法判断实际的类型，因为参数都是 **Result.class**。public class Result&amp;lt;T&amp;gt; { public int code; public String message; public T data;}UserAddress userAddress = new UserAddress( &quot;Main Street&quot;, &quot;42A&quot;, &quot;Magdeburg&quot;, &quot;Germany&quot;);Result&amp;lt;UserAddress&amp;gt; result = new Result&amp;lt;&amp;gt;(200, &quot;success&quot;, userAddress);Gson gson = new Gson();String resultJson = gson.toJson(result);System.out.println(resultJson);// Result.class方式下，T的类型为LinkedTreeMapresult = gson.fromJson(resultJson, Result.class);System.out.println(result);// TypeToken方式下，T的类型为UserAddressresult = gson.fromJson(resultJson, new TypeToken&amp;lt;Result&amp;lt;UserAddress&amp;gt;&amp;gt;(){}.getType());System.out.println(result);Result.class，data 类型为：LinkedTreeMap。TypeToken，data 类型为：UserAddress。四、其他使用1. GsonBuildernew Gson() 只能获取默认配置的 Gson，通过 GsonBuilder 可以实现多种配置。几个常用配置： serializeNulls()，对 null 值进行序列化。 GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeNulls(); Gson gson = gsonBuilder.create(); UserSimple user = new UserSimple(&quot;Norman&quot;, null, 26, true); String usersJson = gson.toJson(user); 输出，email 的 null 也进行了序列化。 { &quot;age&quot;: 26, &quot;email&quot;: null, &quot;isDeveloper&quot;: true, &quot;name&quot;: &quot;Norman&quot;} setFieldNamingPolicy(FieldNamingPolicy namingConvention)，Java 对象转为 Json 时所有域名的命名规则。 FieldNamingPolicy.IDENTITY：保持域名不变 FieldNamingPolicy.UPPER_CAMEL_CASE：大驼峰，someFieldName —&amp;gt; SomeFieldName FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES：大驼峰+空格，someFieldName —&amp;gt; Some Field Name FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES：小写+下划线，someFieldName —&amp;gt; some_field_name FieldNamingPolicy.LOWER_CASE_WITH_DASHES：小写+中划线，someFieldName —&amp;gt; some-field-name FieldNamingPolicy.LOWER_CASE_WITH_DOTS：小写+点，someFieldName —&amp;gt; some.field.name setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy)，FieldNamingPolicy 无法满足使用要求时，可以自定义域名的命名策略。 UserSimple userObject = new UserSimple(null, &quot;norman@futurestud.io&quot;, 26, true); GsonBuilder gb = new GsonBuilder();gb.setFieldNamingStrategy(f -&amp;gt; f.getName().toUpperCase());Gson gson = gb.create(); String userJson = gson.toJson(userObject);System.out.println(userJson); 输出，所有域名都是大写了。 { &quot;EMAIL&quot;: &quot;norman@futurestud.io&quot;, &quot;AGE&quot;: 26, &quot;ISDEVELOPER&quot;: true} setExclusionStrategies(ExclusionStrategy… strategies)，自定义的域排除策略，有两个方法供重写，重写后返回为 true 的域将被排除在外，不进行序列化。 UserSimple userObject = new UserSimple(&quot;Tony&quot;, &quot;norman@futurestud.io&quot;, 26, true);GsonBuilder gb = new GsonBuilder();gb.setExclusionStrategies(new ExclusionStrategy() { @Override public boolean shouldSkipField(FieldAttributes f) { return f.getName().startsWith(&quot;e&quot;); } @Override public boolean shouldSkipClass(Class&amp;lt;?&amp;gt; clazz) { return clazz == int.class; }}); Gson gson = gb.create();String userJson = gson.toJson(userObject);System.out.println(userJson); gson = new Gson();userJson = gson.toJson(userObject);System.out.println(userJson); 输出，开头为 e 的域被排除、整数型的域被排除。 { &quot;name&quot;: &quot;Tony&quot;, &quot;isDeveloper&quot;: true} 另外还有两个可以单独配置序列化、反序列化的方法： addSerializationExclusionStrategy(ExclusionStrategy strategy) addDeserializationExclusionStrategy(ExclusionStrategy strategy) setPrettyPrinting()，格式化输出，默认的输出格式都挤在一行，没有换行和缩进。 // 格式化后的{ &quot;name&quot;: &quot;Tony&quot;, &quot;email&quot;: &quot;norman@futurestud.io&quot;, &quot;age&quot;: 26, &quot;isDeveloper&quot;: true}// 格式化前的{&quot;name&quot;:&quot;Tony&quot;,&quot;email&quot;:&quot;norman@futurestud.io&quot;,&quot;age&quot;:26,&quot;isDeveloper&quot;:true} setVersion(double ignoreVersionsAfter)，排除设定版本外的域，结合 @Since、@Until 域注解使用，详见后文。 excludeFieldsWithoutExposeAnnotation()，排除没有 expose 注解的域，没有 @Expose 注解的域都不会被序列化和反序列化，详见后文。 2. 域注解 @Since，指定该域在某一版本及之后才存在。Java 对象转 Json 以 setVersion(double ignoreVersionsAfter) 中设定的版本为界，如 setVersion(0.99) 设定了版本为 0.99，那么所有 @Since 大于 0.99 的域都不会转 Json。 @Data@AllArgsConstructorclass UserSimple { String name; String email; int age; @Since(1.0) boolean isDeveloper;} UserSimple userObject = new UserSimple(&quot;Tony&quot;, &quot;norman@futurestud.io&quot;, 26, true); GsonBuilder gb = new GsonBuilder();gb.setPrettyPrinting();gb.setVersion(0.99);Gson gson = gb.create(); String userJson = gson.toJson(userObject);System.out.println(userJson); 输出，版本 1.0 &amp;gt; 版本 0.99，所以 isDeveloper 被排除。 { &quot;name&quot;: &quot;Tony&quot;, &quot;email&quot;: &quot;norman@futurestud.io&quot;, &quot;age&quot;: 26} @Until，指定该域一直存在到某一版本。如 setVersion(1.01) 设定了版本为 1.01，那么所有 @Until 小于 1.01 的域都不会转 Json。 @Data@AllArgsConstructorclass UserSimple { String name; String email; int age; @Until(1.0) boolean isDeveloper;} UserSimple userObject = new UserSimple(&quot;Tony&quot;, &quot;norman@futurestud.io&quot;, 26, true); GsonBuilder gb = new GsonBuilder();gb.setPrettyPrinting();gb.setVersion(1.01);Gson gson = gb.create(); String userJson = gson.toJson(userObject);System.out.println(userJson); 输出，版本 1.0 &amp;lt; 版本 1.01，所以 isDeveloper 被排除。 { &quot;name&quot;: &quot;Tony&quot;, &quot;email&quot;: &quot;norman@futurestud.io&quot;, &quot;age&quot;: 26} @Expose，配置 excludeFieldsWithoutExposeAnnotation() 后，没有 @Expose 注解的域将不会转为 Json。 @Data@AllArgsConstructorclass UserSimple { @Expose String name; @Expose String email; @Expose int age; boolean isDeveloper;} UserSimple userObject = new UserSimple(&quot;Tony&quot;, &quot;norman@futurestud.io&quot;, 26, true); GsonBuilder gb = new GsonBuilder();gb.setPrettyPrinting();gb.excludeFieldsWithoutExposeAnnotation();Gson gson = gb.create(); String userJson = gson.toJson(userObject);System.out.println(userJson); 输出，没有 @Expose 注解的 isDeveloper 被排除了。 { &quot;name&quot;: &quot;Tony&quot;, &quot;email&quot;: &quot;norman@futurestud.io&quot;, &quot;age&quot;: 26} transient、static，这两个关键字修饰的域默认不转 Json。 @Data@AllArgsConstructorclass UserSimple { String name; String email; static int age; transient boolean isDeveloper;} UserSimple userObject = new UserSimple(&quot;Tony&quot;, &quot;norman@futurestud.io&quot;, true); GsonBuilder gb = new GsonBuilder();gb.setPrettyPrinting();Gson gson = gb.create(); String userJson = gson.toJson(userObject); 输出，static 修饰的 age 和 transient 修饰的 isDeveloper 都被排除。 { &quot;name&quot;: &quot;Tony&quot;, &quot;email&quot;: &quot;norman@futurestud.io&quot;} @SerializedName，自定序列化和反序列化时 Json 中对应的域名。 @Data@AllArgsConstructorclass UserSimple { @SerializedName(&quot;MyName&quot;) String name; String email; @SerializedName(&quot;YourAge&quot;) int age; boolean isDeveloper;} UserSimple userObject = new UserSimple(&quot;Tony&quot;, &quot;norman@futurestud.io&quot;, 26, true); GsonBuilder gb = new GsonBuilder();gb.setPrettyPrinting();Gson gson = gb.create(); String userJson = gson.toJson(userObject);System.out.println(userJson); 输出，name 对应 MyName，age 对应 YourAge。 { &quot;MyName&quot;: &quot;Tony&quot;, &quot;email&quot;: &quot;norman@futurestud.io&quot;, &quot;YourAge&quot;: 26, &quot;isDeveloper&quot;: true} " }, { "title": "最长的类名", "url": "/posts/longest_class_name/", "categories": "language, java", "tags": "", "date": "2019-07-04 00:00:00 +0800", "snippet": "Java最长的类名：HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitorIOS全局变量：表妹CNLabelContactRelationYoungerCousinMothersSiblingsDaughterOrFathersSistersDaughter" }, { "title": "BigDecimal", "url": "/posts/bigdecimal/", "categories": "language, java", "tags": "bigdecimal", "date": "2019-07-03 00:00:00 +0800", "snippet": " Need Of BigDecimal The two java primitive types(double and float) are floating point numbers, which is stored as a binary representation of a fraction and a exponent. Other primitive types(except boolean) are fixed-point numbers. Unlike fixed point numbers, floating point numbers will most of the times return an answer with a small error (around 10^-19) This is the reason why we end up with 0.009999999999999998 as the result of 0.04-0.03 in the above example. But BigDecimal provides us with the exact answer.Java原始类型 double、float在使用中会有微小误差。BigDecimal提供精确计算。System.out.println(1.01+2.02);// 3.0300000000000002System.out.println(BigDecimal.valueOf(1.01).add(BigDecimal.valueOf(2.02)));// 3.03创建BigDecimal对象 BigDecimal(String val)，字符串生成对象。 static BigDecimal valueOf(double val)，静态方法等价于：new BigDecimal(Double.toString(val))。 BigDecimal(double val)，禁用，由于double的不确定性，导致构造函数结果不确定。BigDecimal b1 = new BigDecimal(&quot;3.14&quot;);BigDecimal b2 = BigDecimal.valueOf(3.14);BigDecimal b3 = new BigDecimal(3.14);System.out.println(String.format(&quot;%s, %s, %s&quot;, b1, b2, b3));// 3.14, 3.14, 3.140000000000000124344978758017532527446746826171875特殊BigDecimal对象0、1、10BigDecimal zero = BigDecimal.ZERO;BigDecimal one = BigDecimal.ONE;BigDecimal ten = BigDecimal.TEN;System.out.println(String.format(&quot;%s, %s, %s&quot;, zero, one, ten));// 0, 1, 10运算public BigDecimal add(BigDecimal value);//加法 public BigDecimal subtract(BigDecimal value);//减法 public BigDecimal multiply(BigDecimal value);//乘法 public BigDecimal divide(BigDecimal value);//除法不可变BigDecimal都是不可变的（immutable）的，进行每一步运算都会产生一个新的对象，所以在做加减乘除运算时要保存操作后的值。BigDecimal b1 =new BigDecimal(&quot;1.34&quot;);System.out.println(&quot;b1 before: &quot; + b1);BigDecimal b2 =new BigDecimal(&quot;2.34&quot;);b1.add(b2);System.out.println(&quot;b1 after: &quot; + b1);// b1 before: 1.34// b1 after: 1.34" }, { "title": "深浅拷贝", "url": "/posts/shallow_deep_copy/", "categories": "language, java", "tags": "", "date": "2019-07-01 00:00:00 +0800", "snippet": "一、什么是深浅拷贝 引用复制：复制出来的引用和原引用指向同一实例变量。 浅拷贝：拷贝出来的引用和原引用不指向同一实例变量，拷贝出来的引用指向的实例变量的内部引用和原引用指向的实例变量的内部引用指向同一实例变量。 深拷贝：对原对象的完全拷贝，包括原对象内部的引用类型。公共代码：@Data@AllArgsConstructorclass Person { private String name; private Address address;}@Data@AllArgsConstructorclass Address { private String city; private String road;}1 引用复制person1、person2指向的内存地址一致：Person1: com.cy.test.Person@41629346Person2: com.cy.test.Person@41629346public class Copy { public static void main(String[] args) throws CloneNotSupportedException { Address address = new Address(&quot;上海&quot;, &quot;淮海路&quot;); Person person1 = new Person(&quot;人一&quot;, address); Person person2 = person1; System.out.println(person1); System.out.println(person2); }}2 浅拷贝person1、person2的地址相同：Person(name=人一, address=Address(city=上海, road=南京路))Person(name=人二, address=Address(city=上海, road=南京路))public class ShallowCopy { public static void main(String[] args) throws CloneNotSupportedException { Address address = new Address(&quot;上海&quot;, &quot;淮海路&quot;); Person person1 = new Person(&quot;人一&quot;, address); Person person2 = (Person) person1.clone(); person2.setName(&quot;人二&quot;); person2.getAddress().setRoad(&quot;南京路&quot;); System.out.println(person1); System.out.println(person2); }}class Person implements Cloneable { private String name; private Address address; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); }}3 深拷贝person1、person2的地址不同：Person(name=人一, address=Address(city=上海, road=淮海路))Person(name=人二, address=Address(city=上海, road=南京路))public class DeepCopy { public static void main(String[] args) throws CloneNotSupportedException { Address address = new Address(&quot;上海&quot;, &quot;淮海路&quot;); Person person1 = new Person(&quot;人一&quot;, address); Person person2 = (Person) person1.clone(); person2.setName(&quot;人二&quot;); person2.getAddress().setRoad(&quot;南京路&quot;); System.out.println(person1); System.out.println(person2); }}class Person implements Cloneable { private String name; private Address address; @Override protected Object clone() throws CloneNotSupportedException { Person person = new Person(name, new Address(address.getCity(), address.getRoad())); return person; }}二、深拷贝实现1 Cloneable接口实现 Cloneable 接口让类可以被拷贝。默认 clone 方法里的实现是 super.clone()，是浅拷贝。重写 clone 方法，在方法体内生成新的内部实例对象，就可以实现深拷贝。但这种方法遇到多层引用时，会比较繁琐，每个类都需要实现 Cloneable 接口，并在 clone 方法体内生成新的内部引用。2 序列化实例对象先序列化再反序列化就可以避免对相同实例对象的引用，需要实现序列化接口。可以直接使用 Apache Commons Lang 的 SerializationUtils 进行 clone。public class DeepCopy { public static void main(String[] args) throws CloneNotSupportedException { Address address = new Address(&quot;上海&quot;, &quot;淮海路&quot;); Person person1 = new Person(&quot;人一&quot;, address); Person person2 = SerializationUtils.clone(person1); person2.setName(&quot;人二&quot;); person2.getAddress().setRoad(&quot;南京路&quot;); System.out.println(person1); System.out.println(person2); }}@Data@AllArgsConstructorclass Person implements Serializable { private String name; private Address address;}@Data@AllArgsConstructorclass Address implements Serializable { private String city; private String road;}3 Json实例对象转为 json，再从 json 转回对象也可以避免对相同实例对象的引用，而且不用实现任何接口。public class DeepCopy { public static void main(String[] args) throws CloneNotSupportedException { Address address = new Address(&quot;上海&quot;, &quot;淮海路&quot;); Person person1 = new Person(&quot;人一&quot;, address); Gson gson = new Gson(); Person person2 = gson.fromJson(gson.toJson(person1), Person.class); person2.setName(&quot;人二&quot;); person2.getAddress().setRoad(&quot;南京路&quot;); System.out.println(person1); System.out.println(person2); }}@Data@AllArgsConstructorclass Person { private String name; private Address address;}@Data@AllArgsConstructorclass Address { private String city; private String road;}" }, { "title": "树莓派 4b", "url": "/posts/pi_4b/", "categories": "pi", "tags": "", "date": "2019-06-30 00:00:00 +0800", "snippet": " 6 月 24 日，树莓派悄然发布了第四代产品 Raspberry Pi 4。 新一代开发板经过了从里到外的全面革新，得益于制程和架构的提升，4 代性能预计可比上代树莓派 3B+提升 2-4 倍。 树莓派开发机构（Raspberry Pi Foundation）称，这款设备可以提供「与入门级 x86 PC 系统相媲美的桌面性能」。X光下的树莓派4 配置 树莓派4 B 树莓派3 B+ CPU 1.5-GHz，4核 Broadcom BCM2711B0 (Cortex A-72) 1.4-GHz，4核 Broadcom BCM2837B0 (Cortex A-53) 内存 1 - 4GB DDR4 1GB DDR2 GPU 500 MHz VideoCore VI 400 MHz VideoCore IV 视频输出 双 micro HDMI 端口 单 HDMI 端口 最大分辨率 4K 60 Hz + 1080p 或 2x 4K 30 Hz 2560 x 1600 USB端口 2x USB 3.0 / 2x USB 2.0 4x USB 2.0 有线网络 千兆以太网 330Mbps 以太网 无线网络 蓝牙 5.0，802.11ac (2.4 / 5 GHz) 蓝牙 4.1，802.11ac (2.4 / 5 GHz) 供电端口 USB Type-C micro USB 电源要求 5V-3A 5V-2.5A 尺寸 88 x 58 x 19.5mm 82 x 56 x 19.5mm 重量 46g 50g 树莓派4的性能已经赶上我们大学时代的PC了。这里是一份4G内存版的对比测评：Raspberry Pi 4 Review: The New Gold Standard for Single-Board Computing便宜的价格、便携的尺寸、pc级别的性能以及可扩展性，占领家庭娱乐市场、移动端市场、教学市场只是一个时间问题了。目前是学生学习计算机、老人上网机的首选。树莓派4（￥300上下）+SD卡+显示器+硬盘+键鼠，很低的成本就可以组装一台Linux系统电脑。" }, { "title": "Java8（三）：Optional类", "url": "/posts/Java8_3/", "categories": "language, java", "tags": "java8, optional", "date": "2019-06-30 00:00:00 +0800", "snippet": "Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。Optional 类的引入很好的解决空指针异常。 方法 描述 **static Optional empty()** 返回空的 Optional 实例。 boolean equals(Object obj) 判断其他对象是否等于 Optional。 **Optional filter(Predicate&amp;lt;? super predicate)** 如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。 ** Optional flatMap(Function&amp;lt;? super T,Optional&amp;gt; mapper)** 如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional T get() 如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException int hashCode() 返回存在值的哈希码，如果值不存在 返回 0。 void ifPresent(Consumer&amp;lt;? super T&amp;gt; consumer) 如果值存在则使用该值调用 consumer , 否则不做任何事情。 boolean isPresent() 如果值存在则方法会返回true，否则返回 false。 **Optional map(Function&amp;lt;? super T,? extends U&amp;gt; mapper)** 如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。 **static Optional of(T value)** 返回一个指定非null值的Optional。 **static Optional ofNullable(T value)** 如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。 T orElse(T other) 如果存在该值，返回值， 否则返回 other。 T orElseGet(Supplier&amp;lt;? extends T&amp;gt; other) 如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。 ** T orElseThrow(Supplier&amp;lt;? extends X&amp;gt; exceptionSupplier)** 如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常 String toString() 返回一个Optional的非空字符串，用来调试 " }, { "title": "欺诈游戏里的两个数学问题", "url": "/posts/cheating_game/", "categories": "language, algorithm", "tags": "probability", "date": "2019-06-30 00:00:00 +0800", "snippet": "日漫《欺诈游戏》挺好看，推荐。最近又刷了一遍，里边有两个数学问题，做下笔记。一、少数决一票人参加一个叫少数决的游戏，游戏规则： 主办方随机抽取一个人到台上来，向众人问一个二选一的问题，问题内容不限，只要是能用“YES”、“NO”回答的二选一问题就行。 每个人手里都会得到两张选票，两张选票上都印有自己的名字，但其中一张纸上印有“YES”，另一张纸上印有“NO”。游戏者们有6个小时的时间进行交流和考虑，并要在时间结束前将自己的选择投入投票箱。 时间结束后，主办方进行唱票，并规定票数较少的那一方获胜，票数较多的多数派将全部被淘汰。 获胜的少数派选手将进行新一轮的游戏，主办方从剩下的人中重新选一位进行二选一提问，并要求大家在6个小时内投票，唱票后仍然宣布少数派胜出。 若某次投票后双方人数相等，则该轮游戏无效，继续下一轮。 游戏一直进行下去，直到最后只剩下一人或两人为止（只剩两人时显然已无法分辨胜负）。 所有被淘汰的人都必须缴纳罚金，这些罚金将作为奖金分给获胜者。这个游戏乍一看并没有什么思路，因为它不同于多数决，无法通过与半数以上的人结成同盟来确保胜利。但稍微转个弯，就可以想到一种不败的办法。少数决本质是个不严格的二分过程，不严格在于每次取的都是少数那部分。从不严格二分这点出发，可以得出一个结论：游戏进行的次数必然小于等于 \\(\\lfloor log_2N \\rfloor\\) ，其中N为参加游戏的人数。 游戏次数不可能大于 \\(log_2N\\) 。如果游戏次数大于\\(log_2N\\)，那么 \\(游戏人数 \\geq 2^{游戏次数} &amp;gt; 2^{log_2N} = N = 游戏人数\\)，得出了游戏人数大于游戏人数的悖论。 游戏次数不可能等于 \\(log_2N\\) 。如果 \\(log_2N\\) 为小数，游戏次数应为整数，必然不等。如果 \\(log_2N\\) 为整数，只有在严格二分的情况下，即每轮游戏都是对半分，\\(2^{游戏次数}\\) 才能等于N。由于游戏规定“YES”和“NO”投票人数相同时需重新投票，因此每次留下的玩家人数必然小于之前玩家人数的一半，不可能实现严格二分。所以游戏进行的次数一定小于：\\(log_2N\\)。 小于 \\(log_2N\\) 的最大正整数： \\(\\lfloor log_2N \\rfloor\\)。基于以上推论，在游戏中只要能够与： \\(2^{\\lfloor log_2N \\rfloor}\\) 或 \\(2^{log_2N - 1}(log_2N为整数时)\\) 个玩家组成同盟，每次对半投票就能保证同盟中有人能够坚持到最后胜利。但以上情况还不是最优解，下边是两个例子： 玩家31人时，第一轮最多留15人，第二轮最多留7人，第三轮最多留3人，第四轮留1人。游戏可以撑满 \\(\\lfloor log_231 \\rfloor = 4\\) 轮。因此结盟人数16人是必要的。 玩家22人时，第一轮最多留10人，第二轮最多留4人，第三轮留1人。游戏最多只能进行3轮，因此结盟人数8人就可以保证不败。准确的游戏轮数 i 算法应该是： \\(n = \\lfloor {(N-1)/2} \\rfloor\\) ，i = 1; \\(n = \\lfloor (n-1)/2 \\rfloor\\)，while(n &amp;gt; 2) i++;算法公式：\\(i = \\lfloor {log_2(N+1)} \\rfloor - 1\\)二、光明与黑暗光明与黑暗是一个简单的概率计算问题，只是觉得概率轮是个很神奇的知识。先说结论：每局33%的概率，想要先赢10局的概率只有6%；每局40%的概率，先赢10局的概率也只有18%。游戏规则： 两张扑克牌，一张牌两面都是黑，一张牌一面白一面黑。 两张牌放在袋子里，每局随机从袋子里拿出一张牌放在桌上。 如果拿出的牌白面朝上，则重新拿。 如果拿出的牌黑面朝上，则继续游戏。 将拿出的这张牌反过来，如果是白面则本局我方胜，如果是黑面则本局对方胜。 先胜10局的获得最终胜利。这个游戏乍一看还算公平，但稍微了解一点概率的童鞋就能看出来，双方单局获胜的概率不同。总共会出现的情况： 白（黑白牌），无效 黑（黑白牌），我方胜 黑（黑黑牌），对方胜 黑（黑黑牌），对方胜 白面朝上的情况被ban掉后，我方单局胜的情况就是1/3了，这样要想先胜10局的概率只有6%。具体计算代码：public class Probability { /** * p概率，先赢n把的概率 * * @param p 每把游戏胜利的固定概率p * @param n 先赢多少把 */ public static double solution(double p, int n) { double base = Math.pow(p, n); double combination = 0.0; for (int i = 0; i &amp;lt; n; i++) { /* * 我方先赢n把，要把对方已赢0，1，2，...，n-1把的情况都算上。 * 对方已赢i把的所有情况数：Cnm(n+i-1, i)，n+i是总数，-1是因为最后一把是我方赢，对方不能选。 * 对方已经i把的概率：Math.pow((1.0 - p), i) */ combination += Cnm(n + i - 1, i) * Math.pow((1.0 - p), i); } return base * combination; } /** * 排列组合 * * @param n 总数 * @param m 取数 * @return 组合数 */ private static long Cnm(int n, int m) { long divisor = 1; long dividend = 1; for (int i = 1; i &amp;lt;= m; i++) { divisor *= i; dividend *= n + 1 - i; } return dividend / divisor; } public static void main(String[] args) { System.out.println(solution(1 / 3.0, 10)); }}" }, { "title": "Java8（二）：Stream", "url": "/posts/Java8_2/", "categories": "language, java", "tags": "java8, lambda", "date": "2019-06-23 00:00:00 +0800", "snippet": "Stream是什么 Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 很多流操作本身就会返回一个流，所以多个操作可以直接连接起来。Stream方法1、stream()将集合转换为流List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;Army&quot;, &quot;Luna&quot;, &quot;Elle&quot;, &quot;Katherine&quot;);Stream&amp;lt;String&amp;gt; stream = list.stream();2、filter(T -&amp;gt; boolean)保留lambda结果为true的元素list = list.stream() .filter(name -&amp;gt; name.length() &amp;gt; 4) .collect(toList());3、distinct()去除重复元素，以类的equals方法作为判据list = list.stream() .distinct() .collect(toList());4、sorted() / sorted((T, T) -&amp;gt; int)如果流中的元素的类实现了 Comparable 接口，即有自己的排序规则，那么可以直接调用 sorted() 方法对元素进行排序，如 Stream。否则， 需要调用 sorted((T, T) -&amp;gt; int) 实现 Comparator 接口。list = list.stream() .sorted((p1, p2) -&amp;gt; p1.length() - p2.length()) .collect(toList());5、limit(long n)返回前n个元素list = list.stream() .limit(2) .collect(toList());6、skip(long n)去除前n个元素list = list.stream() .skip(2) .collect(toList());7、map(T -&amp;gt; R)将流中的每一个元素T映射为RList&amp;lt;String&amp;gt; newlist = list.stream().map(Person::getName).collect(toList());8、flatMap(T -&amp;gt; Stream)flat意思是：展平。把流中的每一个元素T转化为流，再合并为一个流。List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();list.add(&quot;aaa bbb ccc&quot;);list.add(&quot;ddd eee fff&quot;);list.add(&quot;ggg hhh iii&quot;);list = list.stream() .map(s -&amp;gt; s.split(&quot; &quot;)) .flatMap(Arrays::stream) .collect(toList());9、anyMatch(T -&amp;gt; boolean)流中是否有一个元素匹配给定条件。boolean b = list.stream().anyMatch(person -&amp;gt; person.getAge() == 20);10、allMatch(T -&amp;gt; boolean)流中所有元素是否都匹配给定条件。11、noneMatch(T -&amp;gt; boolean)流中是否没有元素匹配给定条件。12、findAny() 和 findFirst()找到任意一个元素；找到第一个元素。返回的是：**Optional **13、reduce((T, T) -&amp;gt; T) 和 reduce(T, (T, T) -&amp;gt; T)将流中元素两两组合，最后得到一个元素。组合的方法取决于lambda表达式。// 计算年龄总和：int sum = list.stream() .map(Person::getAge) .reduce(0, (a, b) -&amp;gt; a + b);// 计算年龄总和:int sum = list.stream() .map(Person::getAge) .reduce(0, Integer::sum);使用reduce(T, (T, T) -&amp;gt; T)方法时，第一个参数为初始值，函数返回值类型为：T使用reduce((T, T) -&amp;gt; T)方法是，函数返回值为：**Optional**14、count()计数15、collect()收集方法。List newlist = list.stream .collect(toList());Map&amp;lt;Integer, Person&amp;gt; map = list.stream() .collect(toMap(Person::getAge, p -&amp;gt; p));16、forEach()遍历数值流int sum = list.stream().map(Person::getAge).reduce(0, Integer::sum)有拆装箱成本。使用数值流可以避免这个问题。1、流转化为数值流 mapToInt(T -&amp;gt; int) : return IntStream mapToDouble(T -&amp;gt; double) : return DoubleStream mapToLong(T -&amp;gt; long) : return LongStream2、数值流方法 sum() max() min() average() …3、数值范围 rangeClosed(1, 100) ：[1, 100] range(1, 100) ：[1, 100)构建流1、值创建 Stream.of(T) Stream.of(T…) Stream.empty()Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;);2、数组创建 Arrays.stream(T[ ]) Arrays.stream(int[ ]) Arrays.stream(double[ ]) Arrays.stream(long[ ])String[] ss = {&quot;Army&quot;, &quot;Luna&quot;, &quot;Elle&quot;, &quot;Katherine&quot;};Stream&amp;lt;String&amp;gt; stream = Arrays.stream(ss, 1, 3);3、函数创建函数创建为无限流。 Stream.iterate(T, UnaryOperator)：在T基础上，依次对每个新生成的T应用函数 Stream.generate(Supplier) ：按函数生成流 // 正偶数集的流Stream.iterate(0, n -&amp;gt; n + 2);// 随机数Stream.generate(Math::random);" }, { "title": "Java8（一）：Lambda表达式-函数式接口", "url": "/posts/Java8_1/", "categories": "language, java", "tags": "java8, lambda", "date": "2019-06-16 00:00:00 +0800", "snippet": " Java supports anonymous functions, named Lambda Expressions, starting with JDK 8. Lambda Expressions, a new language feature, has been introduced in this release. They enable you to treat functionality as a method argument, or code as data. Lambda expressions let you express instances of single-method interfaces (referred to as functional interfaces) more compactly.Java8开始支持匿名函数，又叫Lambda表达式。Lambda表达式允许函数作为方法参数，并且可以让单方法接口（也叫函数式接口）的表达更为紧凑。Lambda表达式Demo：// with no parameter() -&amp;gt; System.out.println(&quot;Hello, world.&quot;)// with one parameter (this example is an identity function).a -&amp;gt; a// with one expression(a, b) -&amp;gt; a + b// with explicit type information(long id, String name) -&amp;gt; &quot;id: &quot; + id + &quot;, name:&quot; + name// with a code block(a, b) -&amp;gt; { return a + b; }// with multiple statements in the lambda body. It needs a code block.// This example also includes two nested lambda expressions (the first one is also a closure).(id, defaultPrice) -&amp;gt; { Optional&amp;lt;Product&amp;gt; product = productList.stream().filter(p -&amp;gt; p.getId() == id).findFirst(); return product.map(p -&amp;gt; p.getPrice()).orElse(defaultPrice);}函数式接口 A functional interface is any interface that contains only one abstract method.函数式接口：任何只有一个抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。定义一个函数式接口如下：interface GreetingService { void sayMessage(String message);}可以使用Lambda表达式来表示该接口的一个实现：GreetingService greetService = message -&amp;gt; System.out.println(&quot;Hello &quot; + message);greetService.sayMessage(&quot;world!&quot;);Java8使用Lambda时，需要声明函数式接口。因此，JDK设计人员内置了四大核心函数式接口。1、消费型接口Consumer&amp;lt; T &amp;gt;消费型接口：有参数，无返回值。@Testpublic void testConsumer() { Consumer&amp;lt;Double&amp;gt; consumer = m -&amp;gt; System.out.format(&quot;买苹果花费：%.1f元\\n&quot;, m); consumer.accept(1.1);}2、供给型接口Supplier&amp;lt; T &amp;gt;供给型接口：无参数，有返回值。@Testpublic void testSupplier() { Supplier&amp;lt;Double&amp;gt; supplier = () -&amp;gt; Math.random() * 10; System.out.format(&quot;卖苹果盈利：%.1f元\\n&quot;, supplier.get());}3、函数型接口Function&amp;lt; T, R &amp;gt;函数型接口：有参数，有返回值。@Testpublic void testFunction() { Function&amp;lt;String, String&amp;gt; function = (s1) -&amp;gt; StringUtils.upperCase(s1); String name = &quot;Jeff&quot;; System.out.format(&quot;名字：%s，大写是：%s&quot;, name, function.apply(name));}4、断言型接口Predicate&amp;lt; T &amp;gt;断言型接口：有参数，返回值为布尔值。@Testpublic void testPredicate() { Predicate&amp;lt;String&amp;gt; predicate = (s1) -&amp;gt; StringUtils.length(s1) &amp;gt;= 5; List&amp;lt;String&amp;gt; names = Arrays.asList(new String[]{&quot;Army&quot;, &quot;Luna&quot;, &quot;Elle&quot;, &quot;Katherine&quot;}); for (String name : names) { if (predicate.test(name)) { System.out.println(name); } }}5、四大核心函数式接口补充四大核心函数式接口，除了核心的抽象方法外，还有几个有意思的默认、静态方法。Predicate：增加了逻辑运算方法，这样就可以把很多断言型接口串起来。# 与default Predicate&amp;lt;T&amp;gt; and(Predicate&amp;lt;? super T&amp;gt; other)；# 非default Predicate&amp;lt;T&amp;gt; negate()；# 或default Predicate&amp;lt;T&amp;gt; or(Predicate&amp;lt;? super T&amp;gt; other)；# 根据equal方法，判断两个对象是否相等static &amp;lt;T&amp;gt; Predicate&amp;lt;T&amp;gt; isEqual(Object targetRef)；# 非static &amp;lt;T&amp;gt; Predicate&amp;lt;T&amp;gt; not(Predicate&amp;lt;? super T&amp;gt; target)Consumer：增加了andThen方法，可以把多个消费型接口串起来。default Consumer&amp;lt;T&amp;gt; andThen(Consumer&amp;lt;? super T&amp;gt; after)Function：增加了前序、后续函数。# V -&amp;gt; T, T -&amp;gt; Rdefault &amp;lt;V&amp;gt; Function&amp;lt;V, R&amp;gt; compose(Function&amp;lt;? super V, ? extends T&amp;gt; before)；# T -&amp;gt; R, R -&amp;gt; Vdefault &amp;lt;V&amp;gt; Function&amp;lt;T, V&amp;gt; andThen(Function&amp;lt;? super R, ? extends V&amp;gt; after)；" }, { "title": "物理", "url": "/posts/physical/", "categories": "collection, articles", "tags": "", "date": "2019-06-15 00:00:00 +0800", "snippet": " [文章] 5G网速那么快，基站辐射会很大吗？ 基站与辐射 [文章] In Defense of Fahrenheit 华氏度的合理性，华氏度是针对人的感觉设计的。 [文章] An Intuitive Guide To Exponential Functions &amp;amp; e 自然对数底数 e 的意义：自然增长的极限。 [文章] How digital cameras work 本文介绍数码相机 CMOS 芯片的感光原理，彩色的光线是如何变成数字信号的。 " }, { "title": "设计", "url": "/posts/design/", "categories": "collection, articles", "tags": "", "date": "2019-06-15 00:00:00 +0800", "snippet": " [文章] Fundamental design principles for non-designers 非设计师需要知道的设计原则，四个原则。 其实算是一个，不要把类似的颜色、字体大小、字体粗细、斜体放在一起。 Colour: use dark on light colours and vice versa. Size: only put elements next to each other that are either exactly the same size, or a considerably different size. Weight: same as with Size, only put elements next to each other that are either exactly the same weight, or a considerably different weight. Style: don’t put one italic type next to another italic type, or one serif typeface next to another serif typeface. Combine things that are different. " }, { "title": "编程", "url": "/posts/code/", "categories": "collection, articles", "tags": "", "date": "2019-06-15 00:00:00 +0800", "snippet": " [文章] Things you’re probably not using in Python 3 – but should Python 3 增加的一些功能。 f-strings (3.6+) Pathlib (3.4+) Type hinting (3.5+) Enumerations (3.4+) Built-in LRU cache (3.2+) Extended iterable unpacking (3.0+) Data classes (3.7+) Implicit namespace packages (3.3+) [Guide] Quarkus Quarkus 是一个开源的、kubernets 原生的 Java 框架，专为 GraalVM 和 OpenJDK 量身定制。 Quarkus 跟 SpringBoot 挺像的，但号称是云原生，具有占用资源少、启动速度快等特点。 [Guide] JavaServlets 讲 Servlet 是什么，从 0 到 1，看完对 Servlet 会有一个清晰的认识。 " }, { "title": "vim", "url": "/posts/vim/", "categories": "tool", "tags": "vim", "date": "2019-06-08 00:00:00 +0800", "snippet": "Vim 寄存器:reg 可以查看 vim 寄存器的状态，寄存器编号以 &quot; 开始，后跟符号标记不同寄存器。比较特殊的一个是 &quot;+ 寄存器，它表示系统的剪切板，所以如果需要从 vim 中拷贝内容到系统的剪切板，可以在 VISUAL 模式下，通过 &quot;+y 实现，相应的通过 &quot;+x 进行剪切。Vim配置说明syntax on &quot; 语法高亮set nocompatible &quot; 非 vi 兼容模式set number &quot; 显示行号set mouse=a &quot; 允许鼠标操作set backspace=2 &quot; mac 下 delete 可以正常使用set showcmd &quot; 显示输入的命令&quot; 光标模式&quot; 1 -&amp;gt; blinking block&quot; 2 -&amp;gt; solid block&quot; 3 -&amp;gt; blinking underscore&quot; 4 -&amp;gt; solid underscore&quot; 5 -&amp;gt; blinking vertical bar&quot; 6 -&amp;gt; solid vertical barlet &amp;amp;t_SI.=&quot;\\e[5 q&quot; &quot;SI = INSERT modelet &amp;amp;t_SR.=&quot;\\e[4 q&quot; &quot;SR = REPLACE modelet &amp;amp;t_EI.=&quot;\\e[1 q&quot; &quot;EI = NORMAL mode (ELSE)set hlsearch &quot; 高亮搜索 set incsearch &quot; 搜索时随着输入自动跳转搜索set showmatch &quot; 遇到括号时自动高亮另一半set autoindent &quot; 自动缩进set tabstop=4 &quot; 按下 tab 时显示的空格数set softtabstop=4 &quot; tab 转为多少空格set shiftwidth=4 &quot; 层级缩进的字符数set expandtab &quot; 自动展开 tabset cursorline &quot; 光标所在行高亮set colorcolumn=81 &quot; 设定代码长度线Vim配置备份.vimrcVim Shortcut" }, { "title": "数字签名", "url": "/posts/digital_signature/", "categories": "other", "tags": "rsa", "date": "2019-06-08 00:00:00 +0800", "snippet": "编码、摘要与加密一文的最后提到了非对称加密算法。非对称加密算法的正向应用是：RSA。非对称加密算法的反向应用就是：数字签名。数字签名：私钥持有者发出数据时，对数据的摘要使用私钥加密，这个加密后的信息就是数字签名。发送者将数据+数字签名发出，接收者收到数据及签名后用公钥解密数字签名得到摘要信息1，并对数据进行摘要算法得到摘要信息2，然后对比两个摘要信息是否一致，就可以验证数据是否从发送者处发出。风险情况：当接收者本地的公钥被坏人替换为它自己的公钥后，坏人使用自己的私钥对数据生成数字签名，并假冒发送者给接收者发送数据，接收者使用了坏人公钥，所以依据能够验证成功，这是接收者使用的就是坏人提供的数据了。证书中心(certificate authority，简称CA)：针对风险情况，证书中心出现了。证书中心用自己的私钥，对发送者的公钥和一些相关信息一起加密，生成数字证书(Digital Certificate)。有了数字证书，发送者在发送数据时就使用数据+数字证书，接收者收到后用证书中心CA的公钥去解开数字证书，拿到发送者的公钥，这时就不必担心公钥被替换了。ps：两篇数字签名文章，一篇原文、一篇翻译，通透！What is a Digital Signature?数字签名是什么？" }, { "title": "网络", "url": "/posts/network/", "categories": "collection, articles", "tags": "", "date": "2019-06-08 00:00:00 +0800", "snippet": " [文章] Who’s Afraid of the Dark? Hype Versus Reality on the Dark Web 暗网的数据研究。看完这个可以一扫解除好友2：暗网的阴影。 [文章] 什么是云原生 简答了解下云原生的概念。 [文章] IaaS，PaaS，SaaS 的区别 " }, { "title": "算法", "url": "/posts/algorithm/", "categories": "collection, articles", "tags": "", "date": "2019-06-08 00:00:00 +0800", "snippet": " [文章] Hashing with SHA-256 [文章] SHA256算法原理详解 两篇讲 SHA-256 算法的文章，结合起来看比较好理解。 附个计算常量 Hash-H0 的代码： import mathimport struct def initHash(): hash8 = [] for i in [2, 3, 5, 7, 11, 13, 17, 19]: h = hex(int(math.modf(math.sqrt(i))[0] * (1 &amp;lt;&amp;lt; 32))) hash8.append(h) print(hash8) def float_to_hex(f): return hex(struct.unpack(&#39;&amp;lt;I&#39;, struct.pack(&#39;&amp;lt;f&#39;, f))[0]) if __name__ == &#39;__main__&#39;: initHash() # [&#39;0x6a09e667&#39;, &#39;0xbb67ae85&#39;, &#39;0x3c6ef372&#39;, &#39;0xa54ff53a&#39;, &#39;0x510e527f&#39;, &#39;0x9b05688c&#39;, &#39;0x1f83d9ab&#39;, &#39;0x5be0cd19&#39;] " }, { "title": "mybatis-generator-lombok-plugin", "url": "/posts/mybatis_generator_lombok_plugin/", "categories": "language, java", "tags": "mybatis, lombok", "date": "2019-06-07 00:00:00 +0800", "snippet": "mybatis-generator-lombok-plugin功能 整合lombok插件实现@Data自动注解，取消getter、setter方法的自动生成。 自定义注释生成器，抓取数据库表的列注释作为实体类注释。用法 git clone到IDEA，根据自己需要进行更改，再添加到本地maven仓库。 git clone到本地，通过maven clean install添加到本地maven仓库。使用1. pom添加插件 添加插件依赖，mybatis-generator-lombok-plugin 根据项目的类型选择数据库依赖，mysql-connector-java或oracle&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.7&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;configurationFile&amp;gt;src/main/resources/generatorConfig.xml&amp;lt;/configurationFile&amp;gt; &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.16&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-generator-lombok-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/plugin&amp;gt;2. 项目添加配置文件添加mybatis-generator配置文件generatorConfig.xml、generatorConfig.properties到项目，并在generatorConfig.xml中引入本插件。&amp;lt;generatorConfiguration&amp;gt; &amp;lt;properties resource=&quot;generatorConfig.properties&quot;/&amp;gt; &amp;lt;context id=&quot;mysql&quot; targetRuntime=&quot;MyBatis3&quot;&amp;gt; &amp;lt;!-- 本地插件，自动注解 @Data --&amp;gt; &amp;lt;plugin type=&quot;com.cy.mybatis.generator.lombok.plugins.LombokPlugin&quot;/&amp;gt; &amp;lt;!-- 本地插件，生成数据库注释 --&amp;gt; &amp;lt;plugin type=&quot;com.cy.mybatis.generator.lombok.plugins.CommentPlugin&quot;/&amp;gt; xxx xxx &amp;lt;/context&amp;gt;&amp;lt;/generatorConfiguration&amp;gt;3. 其他配置及修改 在项目中建好：xml文件目录、domain（pojo）文件目录、dao（mapper接口）文件目录 修改generatorConfig.properties中的属性，如数据库链接、密码、各路径、表名等4. maven插件执行执行插件：mybatis-generator:generate，在各目录下生成xml、domain、dao三类文件。" }, { "title": "埃拉托斯特尼筛法", "url": "/posts/sieve_of_eratosthenes/", "categories": "language, algorithm", "tags": "prime", "date": "2019-06-07 00:00:00 +0800", "snippet": "埃拉托斯特尼筛法，简称埃氏筛法，用来找出一定范围内所有的质数。一、算法描述 列出2及其以后的序列：2，3，4，5，6，7，8，……，n 序列中第一个数字标为质数：2，3，4，5，6，7，8，……，n 划掉后续序列中当前质数倍数的数字：2，3，4，5，6，7，8，……，n 重复2-3步骤，直到当前质数的平方大于等于序列的最大数字，跳出2-3循环，进入5步骤 剩余数字均标记为质数二、代码实现Pythondef eratosthenes(n): IsPrime = [True] * (n + 1) for i in range(2, int(n ** 0.5) + 1): if IsPrime[i]: for j in range(i * i, n + 1, i): IsPrime[j] = False return {x for x in range(2, n + 1) if IsPrime[x]}if __name__ == &quot;__main__&quot;: print(eratosthenes(120))Javapublic class Eratosthenes { public static void solution(int n) { int[] prime = new int[n + 1]; for (int i = 0; i &amp;lt;= n; i++) { prime[i] = i; } for (int i = 2; i &amp;lt;= Math.pow(n, 0.5)+1; i++) { for (int j = i+i; j &amp;lt;= n; j += i) { prime[j] = 0; } } for (int i = 2; i &amp;lt;= n; i++) { if (prime[i] != 0) { System.out.print(prime[i] + &quot; &quot;); } } } public static void main(String[] args) { solution(120); }}" }, { "title": "树莓派 samba 服务器", "url": "/posts/samba/", "categories": "pi", "tags": "samba, crontab, rsync", "date": "2019-06-02 00:00:00 +0800", "snippet": "周末重新在树莓派上配置了个samba服务，一家人给娃传照片用。1、samba配置配置[panda] path = /home/cy/mnt valid users = cy browseable = yes writable = yes write list = pi create mask = 0777 directory mask = 0777 重启服务sudo /etc/init.d/samba restart添加用户sudo smbpasswd -a cy2、手机appiOS下，Documents 6是访问samba的神器，非常好用。添加samba地址路径：服务—添加账号—Windows SMB，输入url（树莓派的ip）、登陆（samba添加的账户）、密码（samba账户密码）。添加samba账户，就可以开始把手机里的照片上传到树莓派下，或者把树莓派下的照片同步到本地。3、备份树莓派总归会有异常的时候，所以在mac上再做下备份。通过crontab定时执行rsync脚本，实现定时同步。其实，如果mac整天开的话，直接在mac上开共享，手机直接传到mac共享中，更方便和安全。rsync同步树莓派上的文件到本地没有公钥的情况下，需要输入ssh密码。rsync -av cy@192.168.0.15:/home/cy/mnt/ ~/cy/熊猫/照片生成公钥并发送到树莓派通过将公钥发送给远程主机，可以避免ssh连接时输入密码。# 生成公钥，有github的同学这步可以省了$ ssh-keygen Enter passphrase (empty for no passphrase): Enter same passphrase again:# 公钥发送到远程主机$ ssh-copy-id -i ~/.ssh/id_rsa.pub cy@192.168.0.15 # 无需密码即可ssh远程主机ssh cy@192.168.0.15做定时任务脚本#!/bin/bashecho ======start====== &amp;gt;&amp;gt; ~/cy/熊猫/panda-`date +%Y%m%d`.log;rsync -av cy@192.168.0.15:/home/cy/mnt/ ~/cy/熊猫/照片 &amp;gt;&amp;gt; ~/cy/熊猫/panda-`date +%Y%m%d`.log;echo ======end====== &amp;gt;&amp;gt; ~/cy/熊猫/panda-`date +%Y%m%d`.log;echo &amp;gt;&amp;gt; ~/cy/熊猫/panda-`date +%Y%m%d`.log;echo &amp;gt;&amp;gt; ~/cy/熊猫/panda-`date +%Y%m%d`.log;生成定时任务# 生成定时任务crontab -e# 在弹出的vi里输入cron语句和脚本路径0 8,18 * * * /home/xxxxx/xxx.sh# 验证crontab -l" }, { "title": "编码、摘要与加密", "url": "/posts/encode_hash_encrypt/", "categories": "other", "tags": "base64, sha, aes, des, rsa", "date": "2019-06-02 00:00:00 +0800", "snippet": "编码（encoding）编码本质是信息形式的转化，譬如十进制到二进制是一种编码。编码是一种双向转化，原始信息通过编码可以得到编码信息，编码信息通过解码可以得到原始信息。（有损编码除外）编码是一对一的。例如：Base64，zip摘要（digest）摘要是通过哈希函数对任意大小的信息/数据生成固定大小的摘要信息。摘要是一种单向转化，原始信息通过摘要可以生成唯一的哈希值，但无法从摘要还原出原始信息。摘要是多对一的，即可能存在多个原始数据对应同一个摘要。例如：MD5，SHA加密（encryption）加密是将明文信息转化为难以读取的密文内容，使之不可读。加密是一种双向转化，原始信息通过加密密钥转化为加密信息，加密信息通过解密密钥被还原为原始信息。加密是一对一的。加密密钥与解密密钥一致的加密方法称为对称加密；反之，加密密钥与解密密钥不一致的加密方法称为非对称加密。非对称加密的密钥分别称为公钥（public key）与私钥（private key）。例如：AES，DES，RSA一、编码：Base64Base64是一种典型的编码。通常用在小图像的处理上，把二进制的图像文件转为文本，在网页上显示时再从文本转为图像，方便传输。典型的例子还有迅雷的专用下载链接：thunder://QUFtYWduZXQ6P3h0PXVybjpidGloOkM5MUExNEIwRjBEMDZDRUM3MzUwQjRERUJFOTFBNTI5MzU4Nzg5QjNaWg==，也是Base64编码后的。原理Base64用64（2^6）个字符来表示任意二进制数据。所有类型的文件，无论什么格式从计算机角度来看，都可以看成是二进制的文件。所以理论上任何文件、字符串都可以通过Base64进行编码。具体原理： 建立一个64长度的字符数组，作为码表。 对要编码的数据进行3字节转4字节处理，每次顺序取数据的3个字节，共计3*8=24位，然后每6位进行高位补零得到4个新字节。 由于数据长度不一定是3的整数倍，因此需要在数据的末尾补充\\x00保证数据按照3的倍数对齐，每补一个\\x00，编码后的字符串就会相应增加一个=用以表示补了多少字节，在解码的时候根据=的个数减去末尾的字节。 从3字节到4字节转化完成后，再查码表把字节转为字符，由于转化后的字节只有低6位有效，所以只需要一个64（2^6）长度的码表就可以满足查表的要求。例子import base64# 读图像with open(&#39;base64-sample.jpg&#39;, &#39;rb&#39;) as f: # 读字节 data = f.read() print(len(data)) print(data) # base64编码 encode_data = base64.b64encode(data) print(len(encode_data)) print(encode_data)以上代码： 打开图像读取字节 进行base64编码 打印编码后的字符。在chrome浏览器地址栏输入：data:image/jpg(图片的格式);base64,base64字符串，就可以直接从浏览器中看到图像。二、摘要算法摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串。f(data) = digest，摘要算法可以理解为f()，其中digest长度为固定值。摘要算法特性：在已知f()的情况下，由f(data)正向推出digest非常容易，但由digest逆向推出data则为不可解。因此摘要为单向。常见的摘要算法：MD5 Message Digest Algorithm 5，流行度极高，在很多文件下载校验中使用，但目前被发现存在碰撞冲突风险； 任意长度输出为128bit=16字节摘要SHA1 SHA：Security Hash Algorithm，由美国国家安全局NSA设计的安全散列算法系列； SHA1输出长度为160bit=20字节摘要SHA256 继SHA1出现的算法(属于SHA-2类)，安全性较SHA1更高； SHA256输出长度为256bit=32字节摘要。例子MD5、SHA1、SHA256对hello world!进行摘要算法，分别得到32、40、64位的16进制字符串，乘以4就分别是：128bit、160bit、256bit。import hashlibmd5 = hashlib.md5()md5.update(&#39;hello world!&#39;.encode(&#39;utf-8&#39;))sha1 = hashlib.sha1()sha1.update(&#39;hello world!&#39;.encode(&#39;utf-8&#39;))sha256 = hashlib.sha256()sha256.update(&#39;hello world!&#39;.encode(&#39;utf-8&#39;))print(&#39;md5: {}, sha1: {}, sha256: {}&#39;.format(md5.hexdigest(), sha1.hexdigest(), sha256.hexdigest()))print(&#39;md5: {}, sha1: {}, sha256: {}&#39;.format(len(md5.hexdigest()), len(sha1.hexdigest()), len(sha256.hexdigest())))md5: fc3ff98e8c6a0d3087d515c0473f8677, sha1: 430ce34d020724ed75a196dfc2ad67c77772d169, sha256: 7509e5bda0c762d2bac7f90d758b5b2263fa01ccbc542ab5e3df163be08e6ca9md5: 32, sha1: 40, sha256: 64应用 文件传输，发送方分别发出数据文件和摘要信息并公布摘要算法，接收方接收到数据文件后使用相同的摘要算法对数据文件进行验证，看是否为相同的摘要信息。 密码加密，用户登陆密码一般不以明文存储在数据库中，一方面是防止运维人员干坏事，另一方面是避免数据库被入侵后用户密码暴露。因此，在用户注册时对用户密码进行摘要处理得到摘要信息，再将摘要信息录入数据库就可以避免明文密码的暴露风险。而在用户登陆时额外要做的，只是再对用户输入的密码进行一次摘要处理。碰撞摘要算法把无限的数据集（无长度限制）映射到一个有限的摘要集（摘要长度限制），必然存在碰撞的情况，即不同的数据生成了相同的摘要。虽然常见几种算法设计都很好的避免了这种情况，但并不代表不会发生。从安全的角度来说，同时使用两种摘要算法可以把碰撞出现的概率减小到不计。加盐 salt摘要算法理论上无法逆向从摘要推出数据，但并不代表完全无法破解。把常见的数据/信息/密码等，先正向通过摘要算法生成摘要，并做成数据-摘要一一对应的彩虹表，那么拿到摘要信息后在彩虹表中进行检索就可以获取到原始数据/信息/密码。加盐就是为了防止这种情况。加盐的摘要算法是：f(data + salt) = digest。计算某一数据的摘要时，根据不同口令（salt）计算出不同的摘要。要验证哈希值，必须同时提供正确的口令（salt），而口令（salt）是黑客无法提前获知的。HmacHmac是一个标准的加盐算法import hmacdata = b&#39;Hello, world!&#39;salt = b&#39;secret&#39;h = hmac.new(salt, data, digestmod=&#39;MD5&#39;)print(h.hexdigest())fa4ee7d173f2d97ee79022d1a7355bcf三、加密算法加密是把明文转为密文，使数据/文件/信息变为不可读，或者说加密算法使得数据/文件/信息加密后得到的密文在直接读取的情况下无意义。同时，加密算法还要保证加密可逆，即在拥有密钥的情况下，可以从密文得到原文。加密算法分为对称加密和非对称加密。对称加密：加/解密的密钥相同。非对称加密：加/解密的密钥不同，有私钥、公钥之分。常见的对称加密算法：AES、DES。常见的非对称加密算法：RSA。加解密使用相同密钥：公钥加密-私钥解密 或者 私钥加密-公钥解密：DESDES：Data Encryption Standard，数据加密标准。 DES现在已经不是一种安全的加密方法，主要因为它使用的56位密钥过短。 DES作为一个标准已经被高级加密标准（AES）所取代。AESAES：Advanced Encryption Standard，高级加密标准。 AES已然成为对称密钥加密中最流行的算法之一。RSARSA是一种非对称加密算法。非对称加密也叫公开密钥加密。阮一峰的这两篇博文把RSA解释的非常通透了。只需要理解几个基本概念和定理就可以看懂。RSA算法原理（一）RSA算法原理（二）互质，欧拉函数，费马小定理，欧拉定理，模逆元RSA概念非对称加密可以这样理解：private(public(x))=y，public(private(x))=y，使用public密钥加密的数据只可以通过private密钥解密，使用private密钥加密的数据只可以通过public密钥解密。 对称加密算法的一个最大弱点在于：密钥只有一套，加解密都使用同一套密钥，加密方需要把密钥告诉给解密方。当加解密双方处在不安全的网络环境时，密钥的暴露就会导致加密信息泄露。 非对称加密算法的优点在于：密钥有两套，加解密双方各持一套密钥。 1. A生成两套密钥(公钥、私钥)，私钥由A自己保存，公钥是公开的；2. B获得A发布的公钥，将数据使用公钥加密，并将加密后的密文secret发出；3. B处于不安全的网络环境中，B发出的密文secret不仅传给了A，网络中的黑客C也同时截获了密文secret；4. 收到密文secret后，由于C没有私钥，因此他无法解密secret；5. 收到密文secret后，A通过自己持有的私钥解密了secret，同时私钥只在本地保存未经过网络传输，因此私钥安全性非常高；6. 如果B在发出密文secret后，丢失了原数据，那么B的处境将会与C一样，无法通过破解密文secret得到原数据。 RSA生成过程1. 取两个大质数p、q；2. 计算r（φ(N)），N=p*q，φ(N)=φ(p)φ(q)=(p-1)(q-1)；3. 随机选取e，e需与r互质；4. 计算d，d是e关于r的模逆元，ed≡1(mod r)5. (N，e)为公钥，(N，d)为私钥RSA可靠性RSA可靠性 = 已知公钥N、e，计算私钥d1. ed≡1(mod r)，公钥中e，要计算d还需要知道r；2. r=φ(N)=φ(p)φ(q)=(p-1)(q-1)，要计算r，需要知道p、q；3. N=p*q，将N因式分解才能得到p、q因此，破解RSA等价于：对N进行因数分解。大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科： 　　对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。 　　假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。 　　只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。RSA加密算法，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。RSA加解密及证明# 加密，公钥(N，e)。data的e次幂对N取余，且data必须小于N。data^e ≡ secret (mod N)# 解密，私钥(N，d)。secre的d次幂对N取余。secret^d ≡ data (mod N)# 证明1. 由 data^e ≡ secret (mod N) 可以推出 secret = data^e - k*N2. 将1式代入可得：secret^d = (data^e - k*N)^d3. 将2式去括号可得：secret^d = data^ed - k*N^d4. 由 ed ≡ 1 (mod r) 可以推出 ed = 1 + Kr5. 将4式代入2式可得：secret^d = data^(1+Kr) - k*N^d只需证明：data^(1+Kr) ≡ data (mod N)，即可证明：secret^d ≡ data (mod N)# 证明：data^(1+Kr) ≡ data (mod N)data与N互质时： 1. 根据欧拉定理：data^r ≡ 1 (mod N) 2. 由1式可得：data^Kr ≡ 1 (mod N) 3. 由2式可得：data^(1+Kr) ≡ data (mod N)data与N非互质时： 1. 由于N由两个质数p、q相乘得到，因此N只有p、q两个因数，若data与N非互质，则data必为p或q的整数倍 2. 由1可得：data = xp 或者 data = yq，且x与q互质、y与p互质(因为data &amp;lt; N，所以x一定小于q，所以x一定与q互质) 3. 以 data = xp 为例，此时data与q互质且q为质数，根据欧拉定理：data^(q-1) ≡ 1 (mod q) 4. 由3式可得：date^((q-1)*K(p-1)) ≡ 1 (mod q) 5. 因(q-1)*K(p-1) = r，由4式可得：data^Kr ≡ 1 (mod q) 6. 将5式分解可得：data^Kr = 1 + tq 7. 将3的条件：data = xp 代入6式，可得：xp^Kr = 1 + tq，进一步可得：xp^(1+Kr) = xp + txpq 8. 将3的条件：xp = data 代入7式，可得：data^(1+Kr) = data + tx*N 9. 由8式可得：data^(1+Kr) ≡ data (mod N)以上，给出了RSA的加解密过程，并进行了证明。需要注意的是：RSA加密的数据必须是整数且数据值必须小于N，之所以要小于N，是因为在data与N非互质的证明中，需要用到第3条data与q互质，而data与q互质的前提是第2条：data = xp，data &amp;lt; N。" }, { "title": "PyCharm 远程解释器", "url": "/posts/pycharm_remote_debug/", "categories": "language, python", "tags": "", "date": "2019-06-01 00:00:00 +0800", "snippet": "PyCharm可以通过配置远程解释器来运行或者调试远程代码，譬如树莓派上的代码。PyCharm解释器是系统级的配置，可以不依赖项目进行配置。1、配置路径2019.1.2版本，配置路径：Configure – Preferences – Project Interpreter – add – SSH Interpreter输入ssh的Host（IP地址）、用户名（Username）、密码（Password），并选择树莓派上的python解释器。2、使用远程解释器配置好远程解释器后，在项目级的配置中选择远程解释器，就可以在本地通过PyCharm对远程代码进行运行和调试了。Path mapping：是本地文件和远程文件的映射。在调试和运行过程中，本地文件夹和远程文件夹会保持同步。" }, { "title": "PCB 工具", "url": "/posts/eagle/", "categories": "tool", "tags": "pcb", "date": "2019-05-26 00:00:00 +0800", "snippet": "Mac下的PCB工具没怎么用过，找到一款Eagle。下载地址下载安装好好，注册登陆就有这种非商业用途的免费License：EAGLE Free License For Non-Commercial Use And Evaluation Purposes。一、教程视频：Tutorial Series for CadSoft Eaglegithub：Eagle-Tutorial-Series一个外国小哥出的教程，看完基本上可以上手了，从绘制原理图到生成工厂生产所需的gerber文件。二、安装Mac下安装好后，会在’～/Documents‘目录下建立’Eagle‘文件夹。1 目录Documents Eagel   cam：自定义cam job的存放位置，由cam处理器调用，cam job我理解就是pcb到gerber的转换规则   libraries：自己添加的元件库文件放在这里   projects：本地项目默认保存在这里   ……：设计规则等等 2 添加元件库 Adafruit-Eagle-Library：4年前的一个库了，但里边常用的封装还是有的，像SMT常见的0805、0603、0402都齐全，还有USB、PINHEADER等等，基本的使用肯定够了。 安装方法：直接把lbr文件放到libraries目录下。 Library Manager：软件自带的库管理，可以在这里找线上的库，并安装到本地。 安装方法：打开软件—右键元件库open library manager—切换到Availible标签页—浏览或搜索—选中相应的库，点use。 supply1、supply2：两个电源、接地的符号库，画原理图的时候比较有用，可以直接从library manager安装。 三、CAM作业在 DXP、Protel下画过图的童鞋，参照第一部分的教程，就可以操作了，画出原理图和PCB问题不大。但到生产环节还有个问题，之前加工都是把DXP生成的PCB文件直接发给工厂进行加工。Eagle下没有PCB格式文件，只有.brd后缀的文件，这玩意估计工厂没法生产，所以要把.brd转成gerber文件。CAM作业就是用来转换的。Gerber，是印刷线路板行业软件中用于描述印刷线路板图像的标准格式。一般要给工厂的gerber包含：线路层（.gtl、.gbl）、阻焊层（.gts、.gbs）、字符层（丝印层，.gto、.gbo）、外形（.gko）和钻孔（.txt）。gerber274x_L2.cam，是我做好的一个双层板CAM作业，可以直接用来转换双层板。转换内容：" }, { "title": "开源", "url": "/posts/systems/", "categories": "collection, sources", "tags": "", "date": "2019-05-26 00:00:00 +0800", "snippet": " ArchiveOS 收集所有开源的操作系统的网站。 CTOLib 码库 每日更新收录实用的开源项目和资源，目前共有49504个收录，并归类到658个分类中。 勒索病毒解密工具 一个收集勒索病毒解密工具的仓库。 Hello GitHub 跟踪收集 GitHub 新项目的《Hello GitHub》的官网。 " }, { "title": "前端", "url": "/posts/frondend/", "categories": "collection, sources", "tags": "", "date": "2019-05-26 00:00:00 +0800", "snippet": " RemixIcon 一套免费高质量的开源图标库，目前有1500多枚图标，提供矢量图和字体图标文件，可用于商业用途。 Precise UI 一个轻量级 React 组件库，提供70多个组件，特点是比较简洁。 water.css 一个极小化的 CSS 框架，用来快速为网页加上简单样式，特别是不必使用任何 class。 hanzi-writer 一个演示汉字笔画顺序的 JS 库。 " }, { "title": "书", "url": "/posts/books/", "categories": "collection, sources", "tags": "", "date": "2019-05-26 00:00:00 +0800", "snippet": " love2.io 一个收集开源书籍的网站。 kindle电子书分享网 个人业余时间搞得一个小网站，以解决自己找电子书的烦恼，后端基于rails，可以参考技术方案。 " }, { "title": "博文", "url": "/posts/blogs/", "categories": "collection, sources", "tags": "", "date": "2019-05-26 00:00:00 +0800", "snippet": " 阮一峰日志整理 阮一峰每周分享的分类整理。 命令行的艺术 一篇命令行的详细介绍，各种任务可以使用什么命令。 arl 各种语言最受欢迎的项目，按照 GitHub Star 的数量排行。 Well, one of the best ways to learn something new is to watch how it is done by others. Python - 100天从新手到大师 针对初学者的 Python 教程。 Curl Cookbook 中文简译版：curl 的用法指南 " }, { "title": "系统", "url": "/posts/system/", "categories": "collection, articles", "tags": "", "date": "2019-05-25 00:00:00 +0800", "snippet": " [PDF] Linux: a Portable Operating System Linus Torvalds 的硕士毕业论文，介绍 Linux 系统如何适配不同的硬件架构。 " }, { "title": "电子", "url": "/posts/electronic/", "categories": "collection, articles", "tags": "", "date": "2019-05-25 00:00:00 +0800", "snippet": " [文章] How to Read a Schematic 内容比较好理解，各种原理图中符号的介绍。补充两个只记着名字的二极管。 肖特基二极管（Schottky）：以其发明人肖特基博士命名，SBD 是肖特基势垒二极管（Schottky Barrier Diode）的简称。最显著的特点为反向恢复时间极短（可以小到几纳秒），正向导通压降仅 0.4V 左右。其多用作高频、低压、大电流整流二极管、续流二极管、保护二极管，也有用在微波通信等电路中作整流二极管、小信号检波二极管使用。在通信电源、变频器等中比较常见。 齐纳二极管（Zener）：稳压二极管。利用 pn 结反向击穿状态，其电流可在很大范围内变化而电压基本不变的现象，制成的起稳压作用的二极管。 [文章] Raspberry Pi GPIO Pinout: What Each Pin Does 树莓派GPIO介绍： 每个引脚最大输出电流为16mA 同一时刻所有引脚总输出电流不超过51mA " }, { "title": "软件", "url": "/posts/softwares/", "categories": "collection, interesting", "tags": "", "date": "2019-05-24 00:00:00 +0800", "snippet": " Convert images to LaTeX 数学公式的截图 OCR 转为 LaTex 代码的桌面软件，三个系统的版本都有。 Motrix 一款桌面端下载工具，支持下载 HTTP、FTP、BT、磁力链、百度网盘等资源。 git_curate 项目的 Git 仓库有很多分支，你都忘记了哪些分支是有用的，导致不敢删除。这个工具可以显示每个分支的详细情况，以及是否已经合并了，帮助判断是否应该删除这个分支。 Fika Chrome 浏览器插件，可以将网页转成可以专心阅读的样式，内置四种主题。 Darling Darling 的意思是 Darwin + Linux。它是一个转换层，允许在 Linux 直接运行 macOS 的二进制文件。 cdecl C 语言声明转为英文，有 online 和命令行工具。 tldr 以示例的方式展示命令的用法，简化版的 man page。 instantbox 可以直接从浏览器访问的 linux 系统沙箱，docker-compose 技术。 ttyd 可以直接从浏览器访问的 terminal，挺有意思的。 " }, { "title": "项目", "url": "/posts/projects/", "categories": "collection, interesting", "tags": "", "date": "2019-05-24 00:00:00 +0800", "snippet": " High-tech automatic Infrared heater aimer 高科技人体单自由度追踪小太阳。 树莓派+摄像头+算法，实现人体识别；树莓派+驱动器+步进电机，实现单自由度追踪。 mjrovai 一个IoT大牛，里边有很多树莓派、Arduino、物联网的项目。 halo 优秀的开源 Java 博客系统，国产软件，有良好的中文支持。 SAFE 这个项目在印度尼西亚婆罗州的热带雨林里面，放置了十几个录音设备，然后将每个小时录到的声音放到网上，让访问者听到每天不同时辰的大自然的声音。 我的透明创业实验 一个正在进行的创业实验，一年时间做10个小产品，看看能否达到每月被动收入1000美元的目标。 " }, { "title": "在线工具", "url": "/posts/online/", "categories": "collection, interesting", "tags": "", "date": "2019-05-24 00:00:00 +0800", "snippet": " MikuTools 该网站收集一系列轻量级工具，比如各大视频网站的视频在线下载工具。 I love IMG 该网站提供各种在线的图像编辑工具，比如图像缩放、压缩、裁剪、水印等。 QuickChart 一个通过url生成图表、二维码的在线开源服务。 html中嵌入以下代码可以快速生成图表，url中&amp;amp;c之后为生成图表的json数据。 &amp;lt;img src=&quot;https://quickchart.io/chart?width=500&amp;amp;height=300&amp;amp;c={type:&#39;bar&#39;,data:{labels:[&#39;January&#39;,&#39;February&#39;,&#39;March&#39;,&#39;April&#39;, &#39;May&#39;], datasets:[{label:&#39;Dogs&#39;,data:[50,60,70,180,190]},{label:&#39;Cats&#39;,data:[100,200,300,400,500]}]}}&quot;/&amp;gt; Screen Record 一个浏览器里面的录屏工具，非常简单好用。 Cedreo 一个 3D 的家居建模渲染软件，还可以生成平面图，免费注册使用。 Koonchi We transform your photos into 100% hand-drawn, beautiful, paintings. Bringing your memories alive. 照片上传到该网站，它会去找印度艺术家，把照片画成画作，再把画寄回给你。A3 大小的画作，收费在1000元人民币左右，尺寸放大收费增加。 Colorize 黑白照片自动上色的服务。 图形计算器 网站左侧输入公式，右侧自动输出图像，非常直观。 多吉搜索 一个新的国产搜索引擎，个人作品，据称目标是成为百度的替代方案之一。 Storyteller 无代码交互式教程编辑器，挺有意思的，做教程或者 knowledge sharing 都比较方便。 " }, { "title": "游戏", "url": "/posts/games/", "categories": "collection, interesting", "tags": "", "date": "2019-05-24 00:00:00 +0800", "snippet": " PacVim 通过吃豆子（PacMan）游戏学习 Vim 操作的命令行游戏。 " }, { "title": "树莓派介绍及安装", "url": "/posts/pi_setup/", "categories": "pi", "tags": "", "date": "2019-05-19 00:00:00 +0800", "snippet": "树莓派 Raspberry Pi，是一款基于Linux的单片机计算机。一、参数官网： 树莓派3B+产品简介 树莓派3B+外形图 树莓派3B+原理图 硬件规范参数： CPU：BCM2837B0，64位 1.4GHz 四核 Cortex-A53 (ARMv8) 内存：1GB LPDDR2 SDRAM 存储：Micro-SD卡接口，用于安装系统和存储数据 网络：基于USB2.0的以太网（最大吞吐量300Mbps)；2.4GHz和5GHz双频Wi-Fi（支持802.11.b/g/n/ac ） 蓝牙：蓝牙4.2，低功耗蓝牙（BLE） 供电：5V/2.5A直流；以太网供电（PoE），需要额外购买和安装PoE HAT模块 显示：HDMI GPIO：40引脚，双排插针 接口：4 x USB2.0；相机串行接口（CSI）；显示串行接口（DSI） 尺寸：85mm x 56mm x 19.5mm，50g 价格：35$二、系统安装1 下载镜像官网地址 官方镜像，都是基于debian的。共有三种：最小镜像，300+MB；桌面环境镜像，1GB左右；桌面环境+推荐软件镜像，2GB左右。Micro-SD卡大的童鞋，推荐桌面环境+推荐软件的镜像。 第三方镜像，官网给了十种，有些看起来挺炫酷的，像OSMC。 2 烧录镜像MacOS：ether，开源软件，傻瓜式操作，非常好用。Windows：ether，Win32 DiskImager3 接外设或者开SSH 接外设：HDMI显示器、USB鼠标、USB键盘都接上，上电等开机完成。进入系统后配置好Wi-Fi，并在命令行通过raspi-config命令进入配置界面，在配置界面中开启ssh、vnc。 开SSH：没有显示器和多余鼠标键盘的话，就需要先开启ssh。树莓派上电后，本地通过ssh连到树莓派，然后再配置vnc等开启。树莓派如何开ssh？sd卡里直接新建ssh文件就打开了树莓派的ssh功能。touch ssh树莓派ssh，默认用户名：pi；默认密码：raspberry。树莓派如何接入网络？ 接网线方式：树莓派网口插入网线，网线另外一端得是能够动态配置IP的设备，普通的家用路由器就可以。 Wi-Fi方式：sd卡里新建wpa_supplicant.conf文件，文件内容如下。country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network={ ssid=&quot;wifi名字&quot; psk=&quot;wifi密码&quot; key_mgmt=WPA-PSK priority=1}4 VNC初次登陆后，在命令行通过raspi-config进入配置界面，配置打开VNC。开启了VNC，就可以通过VNC Viewer等工具进行远程桌面连接了。三、配置1 换源软件源sudo nano /etc/apt/sources.list# 把下边的copy进去，注释或者备份旧的deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpideb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi系统源sudo nano /etc/apt/sources.list.d/raspi.list# 把下边的copy进去，注释或者备份旧的deb https://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui更新sudo apt-get update;sudo apt-get upgrade;sudo apt-get dist-upgrade;sudo rpi-update;2 文件共享在树莓派上搭个samba服务器，方便和本地互传文件。安装sambasudo apt-get update;sudo apt-get install samba; 配置sambanano /etc/samba/smb.conf# 注销掉默认的[homes]共享路径，新增以下共享[cy-pi] path = /home/pi valid users = pi browseable = yes writable = yes write list = pi create mask = 0777 directory mask = 0777重启sambasudo /etc/init.d/samba restart添加samba用户sudo smbpasswd -a pi# 输入密码New SMB password: Retype new SMB password:Added user pi.访问MacOS： Finder下：cmd+k，输入smb://ip 在网络中找Windows： 运行中：输入\\\\ip手机： Android：es浏览器等等 iOS：documents（所有文件）、infuse（视频） NAS后续要是想做NAS的话，直接自动挂载个硬盘就好。" }, { "title": "树莓派 GPIO", "url": "/posts/pi_gpio/", "categories": "pi", "tags": "", "date": "2019-05-19 00:00:00 +0800", "snippet": "GPIO：General Purpose Input Output，通用输入输出。可以理解为树莓派电路板插针上的pin脚。下文统一用pin脚指代。一、pin脚映射树莓派有三种pin脚映射：BOARD、BCM、Pi4J/WiringPi。1、BOARD/BCMBOARD、BCM：这两种映射方式可以在pinout网站查看，或者在终端输入pinout查看。BOARD：下图中从左到右依次为1-39pin和2-40pin；BCM：下图中的14、15、18、23、24、25、8、7、1、12、16、20、21等pin。玩过单片机的同学应该知道，很多单片机带有丰富的片内外设。譬如MSP430单片机，芯片里不仅有MCU，还有定时器、看门狗、UART、SPI、I2C等常见模块。树莓派的SoC也是一样，集成了很多模块，因此它的pin脚也具备复用功能。如：UART、I2C、SPI。不开启复用功能时为通用pin脚，具备输入输出功能；开启复用功能后，就具备了相应模块的功能。譬如BCM模式下的14、15脚（上图紫色），开启复用功能后就可以与串口进行通信。2、Pi4J/WiringPiWiringPi是用c写的树莓派GPIO库。Pi4J是树莓派GPIO的Java库，依赖于WiringPi。Pi4J/WiringPi模式下的pin脚映射如下图。二、基本使用1、Python安装：pip3 install RPi.GPIO教程：raspberry-gpio-python，从基本使用到输入/输出再到pwm，样例写的很清晰了，直接在板子上试就可以了。基本套路就是：# 1、引入包import RPi.GPIO as GPIO# 2、设定模式BOARD、BCM，Python只有这两种GPIO.setmode(GPIO.BOARD)# 3、设定输入、输出GPIO.setup(12, GPIO.OUT)# 4、开始输入或者输出GPIO.input(12)GPIO.output(12, GPIO.LOW)# 5、关闭资源GPIO.cleanup(12)GPIO.cleanup()2、Java安装：通过maven引入或者直接下载jar包作为lib，Pi4J :: Java Library (Core)  » 1.2教程：官网的examples很详尽了。下面是个pin脚的例子，控制GPIO_01（Python下的BOARD.12）高电平5s再低电平5s两个来回，最后输入个1秒的高电平脉冲。如果接了led，会看到相应的led亮灭和脉冲。（ps：接led时记得接限流电阻）import com.pi4j.io.gpio.GpioController;import com.pi4j.io.gpio.GpioFactory;import com.pi4j.io.gpio.GpioPinDigitalOutput;import com.pi4j.io.gpio.PinState;import com.pi4j.io.gpio.RaspiPin;/** * This example code demonstrates how to perform simple state * control of a GPIO pin on the Raspberry Pi. * * @author Robert Savage */public class ControlGpioExample { public static void main(String[] args) throws InterruptedException { System.out.println(&quot;&amp;lt;--Pi4J--&amp;gt; GPIO Control Example ... started.&quot;); // create gpio controller final GpioController gpio = GpioFactory.getInstance(); // provision gpio pin #01 as an output pin and turn on final GpioPinDigitalOutput pin = gpio.provisionDigitalOutputPin(RaspiPin.GPIO_01, &quot;MyLED&quot;, PinState.HIGH); // set shutdown state for this pin pin.setShutdownOptions(true, PinState.LOW); System.out.println(&quot;--&amp;gt; GPIO state should be: ON&quot;); Thread.sleep(5000); // turn off gpio pin #01 pin.low(); System.out.println(&quot;--&amp;gt; GPIO state should be: OFF&quot;); Thread.sleep(5000); // toggle the current state of gpio pin #01 (should turn on) pin.toggle(); System.out.println(&quot;--&amp;gt; GPIO state should be: ON&quot;); Thread.sleep(5000); // toggle the current state of gpio pin #01 (should turn off) pin.toggle(); System.out.println(&quot;--&amp;gt; GPIO state should be: OFF&quot;); Thread.sleep(5000); // turn on gpio pin #01 for 1 second and then off System.out.println(&quot;--&amp;gt; GPIO state should be: ON for only 1 second&quot;); pin.pulse(1000, true); // set second argument to &#39;true&#39; use a blocking call // stop all GPIO activity/threads by shutting down the GPIO controller // (this method will forcefully shutdown all GPIO monitoring threads and scheduled tasks) gpio.shutdown(); System.out.println(&quot;Exiting ControlGpioExample&quot;); }}" }, { "title": "ncdu", "url": "/posts/ncdu/", "categories": "tool", "tags": "", "date": "2019-05-18 00:00:00 +0800", "snippet": "ncdu，NCurses Disk Usage，增强版du。安装：brew install ncdu使用：ncdu [options] dir例子：全系统扫描，ncdu -x / 命令/按键 说明 –color dark 增加显示颜色 -h 帮助 ? 帮助 hjkl 左下上右 d 删除选择文件 g 是否显示百分比 e 是否显示隐藏文件 文件标识 说明 ！ 读目录时发生错误 . 读子目录时发生错误，因此当前大小不准 @ 既不是文件也不是目录 e 空文件夹 " }, { "title": "bat", "url": "/posts/bat/", "categories": "tool", "tags": "", "date": "2019-05-18 00:00:00 +0800", "snippet": "bat，cat增强版，自动less、格式化输出、代码高亮、git集成、非打印字符显示。安装：brew install bat格式化输出、代码高亮：git集成：非打印字符显示：-A" }, { "title": "终端录屏", "url": "/posts/asciinema/", "categories": "tool", "tags": "asciinema", "date": "2019-05-18 00:00:00 +0800", "snippet": " asciinema，终端录制安装：brew install asciinema使用：asciinema rec filename：进行录制，完毕时通过exit或ctrl+d结束，结束后会生成一个*.cast后缀的JSON文件；asciinema play filename：播放录制的文件。 asciicast2gif，从cast文件生成git安装依赖：brew install ImageMagick gifsicle node安装：npm install –global asciicast2gif使用：asciicast2gif input.cast output.git" }, { "title": "日志框架", "url": "/posts/log_framework/", "categories": "language, java", "tags": "slf4j, log4j2", "date": "2019-04-21 00:00:00 +0800", "snippet": "一、日志框架Slf4j，简单日志门面（Simple Logging Facade for Java）为各种日志框架提供了统一的接口封装，包括java.util.logging、logback、Log4j等，使用户在部署时可以灵活配置自己想要的Logging APIs实现。应用开发时，需要统一按照slf4j的API进行开发；部署时，选择不同的日志系统Jar包加入Java ClassPath中，即可自动转换到不同的日志框架上。slf4j隐藏了具体的转换、适配细节，将应用和具体日志框架解耦，如果在类路径中没有发现绑定的日志实现，则默认使用NOP实现。slf4j unbound：slf4j-api.jar，默认会使用NOP方式实现；slf4j NOP：slf4j-api.jar + slf4j-nop.jar，丢弃所有日志；slf4j simple：slf4j-api.jar + slf4j-simple.jar，一个简单的日志实现；slf4j + jdk：slf4j-api.jar + slf4j-jdk14，使用jdk官方日志；slf4j + logback：slf4j-api.jar + logback-core.jar + logback-classic.jar，logback实现；slf4j + log4j2：slf4j-api.jar + log4j-slf4j-impl.jar + log4j-api.jar + log4j-core.jar，log4j2实现。二、配置文件（slf4j + log4j2）2.1 加载顺序参考官网：https://logging.apache.org/log4j/2.x/manual/configuration.htmllog4j2可以加载四种类型配置文件：json、yaml、xml、properties。加载优先级为classpath下的：1）log4j2-test.properties2）log4j2-test.yaml、log4j2-test.yml3）log4j2-test.json、log4j2-test.jsn4）log4j2-test.xml5）log4j2.properties6）log4j2.yaml、log4j2.yml7）log4j2.json、log4j2.jsn8）log4j2.xml配置文件缺失时的默认配置：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Configuration status=&quot;WARN&quot;&amp;gt; &amp;lt;Appenders&amp;gt; &amp;lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&amp;gt; &amp;lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&amp;gt; &amp;lt;/Console&amp;gt; &amp;lt;/Appenders&amp;gt; &amp;lt;Loggers&amp;gt; &amp;lt;Root level=&quot;error&quot;&amp;gt; &amp;lt;AppenderRef ref=&quot;Console&quot;/&amp;gt; &amp;lt;/Root&amp;gt; &amp;lt;/Loggers&amp;gt;&amp;lt;/Configuration&amp;gt;2.2 标签 ** Configuration**：配置文件root节点 ** status**：log4j本身的日志级别； ** monitorinterval**：配置更新检测时间间隔（s）； ** Appenders**：定义日志输入目的地，如console、file   ** Console**：日志输出到控制台     ** name**：appender名字；     ** target**：SYSTEM_OUT、SYSTEM_ERR；       PatternLayout：输出格式   ** File**：日志输出到文件     ** name**：appender名字；     ** fileName**：文件名；     ** append**：是否追加方式；     ** PatternLayout**：输出格式   ** RollingFile**：日志输出到滚动文件，该文件超过指定时间、大小后，可以执行归档或者删除等操作     ** name**：appender名字；     ** fileName**：文件名；     ** filePattern**：归档时的文件名；     ** PatternLayout**：输出格式     ** Polices**：归档策略       ** CronTriggeringPolicy**：Cron表达式触发       ** OnStartupTriggeringPolicy**：JVM启动时触发       ** SizeBasedTriggeringPolicy**：基于文件大小       ** TimeBasedTriggeringPolicy**：基于时间       ** CompositeTriggeringPolicy**：多个触发策略的混合，如同时基于文件大小和时间     ** DefaultRolloverStrategy**：默认触发策略       ** max**：最大保留文件数，与%i配合； ** Loggers**：定义logger   ** Root**：根logger，默认使用该logger进行日志输出     ** level**：日志输出级别，All &amp;lt; Trace &amp;lt; Debug &amp;lt; Info &amp;lt; Warn &amp;lt; Error &amp;lt; Fatal &amp;lt; OFF；     ** AppenderRef**：指向appender   ** Logger**：自定义logger     ** level**：日志输出级别，All &amp;lt; Trace &amp;lt; Debug &amp;lt; Info &amp;lt; Warn &amp;lt; Error &amp;lt; Fatal &amp;lt; OFF；     ** name**：指定该logger所适用的类或者类所在的包全路径，继承自Root节点；     ** AppenderRef**：指向appender。未指定时，使用root中的appender；指定后，指定的appender和root中的appender均输出日志，设置logger的additivity=”false”后可只在指定的appender中进行输出 2.3 样例&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&amp;gt; &amp;lt;appenders&amp;gt; &amp;lt;console name=&quot;console&quot; target=&quot;SYSTEM_OUT&quot;&amp;gt; &amp;lt;PatternLayout pattern=&quot;[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n&quot;/&amp;gt; &amp;lt;/console&amp;gt; &amp;lt;File name=&quot;file&quot; fileName=&quot;log/test.log&quot; append=&quot;false&quot;&amp;gt; &amp;lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n&quot;/&amp;gt; &amp;lt;/File&amp;gt; &amp;lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;${sys:user.home}/logs/info.log&quot; filePattern=&quot;${sys:user.home}/logs/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log&quot;&amp;gt; &amp;lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&amp;gt; &amp;lt;PatternLayout pattern=&quot;[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n&quot;/&amp;gt; &amp;lt;Policies&amp;gt; &amp;lt;TimeBasedTriggeringPolicy/&amp;gt; &amp;lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&amp;gt; &amp;lt;/Policies&amp;gt; &amp;lt;/RollingFile&amp;gt; &amp;lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;${sys:user.home}/logs/warn.log&quot; filePattern=&quot;${sys:user.home}/logs/$${date:yyyy-MM}/warn-%d{yyyy-MM-dd}-%i.log&quot;&amp;gt; &amp;lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&amp;gt; &amp;lt;PatternLayout pattern=&quot;[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n&quot;/&amp;gt; &amp;lt;Policies&amp;gt; &amp;lt;TimeBasedTriggeringPolicy/&amp;gt; &amp;lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&amp;gt; &amp;lt;/Policies&amp;gt; &amp;lt;DefaultRolloverStrategy max=&quot;20&quot;/&amp;gt; &amp;lt;/RollingFile&amp;gt; &amp;lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;${sys:user.home}/logs/error.log&quot; filePattern=&quot;${sys:user.home}/logs/$${date:yyyy-MM}/error-%d{yyyy-MM-dd}-%i.log&quot;&amp;gt; &amp;lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&amp;gt; &amp;lt;PatternLayout pattern=&quot;[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n&quot;/&amp;gt; &amp;lt;Policies&amp;gt; &amp;lt;TimeBasedTriggeringPolicy/&amp;gt; &amp;lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&amp;gt; &amp;lt;/Policies&amp;gt; &amp;lt;/RollingFile&amp;gt; &amp;lt;/appenders&amp;gt; &amp;lt;loggers&amp;gt; &amp;lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&amp;gt; &amp;lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&amp;gt;&amp;lt;/logger&amp;gt; &amp;lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&amp;gt;&amp;lt;/logger&amp;gt; &amp;lt;root level=&quot;all&quot;&amp;gt; &amp;lt;appender-ref ref=&quot;Console&quot;/&amp;gt; &amp;lt;appender-ref ref=&quot;RollingFileInfo&quot;/&amp;gt; &amp;lt;appender-ref ref=&quot;RollingFileWarn&quot;/&amp;gt; &amp;lt;appender-ref ref=&quot;RollingFileError&quot;/&amp;gt; &amp;lt;/root&amp;gt; &amp;lt;/loggers&amp;gt;&amp;lt;/Configuration&amp;gt;" }, { "title": "htop", "url": "/posts/htop/", "categories": "tool", "tags": "", "date": "2019-04-20 00:00:00 +0800", "snippet": "htop，一个用于Unix系统的交互式进程查看器，支持命令行界面下的鼠标操作。1-4：cpu负载Mem：内存使用情况Swp：交换区占用情况PID：进行的标识号USER：运行此进程的用户PRI：进程的优先级NI：进程的优先级别值，默认的为0，可以进行调整VIRT：进程占用的虚拟内存值RES：进程占用的物理内存值SHR：进程占用的共享内存值S：进程的运行状况，R表示正在运行、S表示休眠，等待唤醒、Z表示僵死状态%CPU：该进程占用的CPU使用率%MEM：该进程占用的物理内存和总内存的百分比TIME+：该进程启动后占用的总的CPU时间COMMAND：进程启动的启动命令名称 命令 功能命令 说明 h, ? F1 htop帮助 C, S F2 htop设定 / F3 搜索进程名 \\ F4 增量进程名过滤器 t F5 显示树形结构 +, - F6 树形结构功能打开时，展开/折叠树形结构 &amp;gt;, . F6 选择排序列 ] F7 可减少nice值，提高对应进程的优先级，需root权限 [ F8 可增加nice值，降低对应进程的优先级 k F9 对进程传递信号 q F10 结束htop p   隐藏/显示程序路径 u   显示一个给定的用户的进程 H   显示/隐藏用户线程 K   显示/隐藏内核线程 P   按CPU使用排序 M   按内存使用排序 T   按Time+使用排序 I   倒转排序顺序 e   显示进程环境变量 l   显示进程打开的文件 s   选择某进程，按s:用strace追踪进程的系统调用 " }, { "title": "Guava 字符串处理", "url": "/posts/guava_string/", "categories": "language, java", "tags": "guava", "date": "2019-04-16 00:00:00 +0800", "snippet": "Guava，包含了若干被Google的Java项目广泛依赖的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。所有这些工具每天都在被Google的工程师应用在产品服务中。一、连接器[Joiner]连接器通过分隔符把字符串或者map连接起来，并可以替换或者跳过null。 方法 描述 Joiner.on(char separator) 生成Joiner，连接字符为separator Joiner.on(String separator) 生成Joiner，连接字符串为separator skipNulls() 跳过null值 useForNull(String nullText) 用nullText代替null值 withKeyValueSeparator(char keyValueSeparator) 生成MapJoiner，k-v连接字符keyValueSeparator withKeyValueSeparator(String keyValueSeparator) 生成MapJoiner，k-v连接字符串keyValueSeparator join(Iterable&amp;lt;?&amp;gt; parts)   join(Iterator&amp;lt;?&amp;gt; parts)   join(Object[] parts)   @Testpublic void joinerTest() { List&amp;lt;String&amp;gt; list = Lists.newArrayList(&quot;China&quot;, &quot;Japan&quot;, null, &quot;American&quot;); Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); map.put(&quot;CHN&quot;, &quot;China&quot;);map.put(&quot;JP&quot;, &quot;Japan&quot;); map.put(&quot;USA&quot;, &quot;American&quot;);map.put(null, &quot;Null&quot;); Joiner joiner = Joiner.on(&quot;;&quot;).skipNulls(); String s = joiner.join(list); assertEquals(&quot;China;Japan;American&quot;, s); Joiner joiner1 = Joiner.on(&quot;;&quot;).useForNull(&quot;N/A&quot;); String s1 = joiner1.join(list); assertEquals(&quot;China;Japan;N/A;American&quot;, s1); Joiner joiner2 = Joiner.on(&quot;; &quot;).useForNull(&quot;N/A&quot;); Joiner.MapJoiner mapJoiner = joiner2.withKeyValueSeparator(&quot; -&amp;gt; &quot;); String s2 = mapJoiner.join(map); log.info(&quot;MapJoiner join {}&quot;, s2); //[INFO] MapJoiner join {N/A -&amp;gt; Null;USA -&amp;gt; American;JP -&amp;gt; Japan;CHN -&amp;gt; China}}二、拆分器[Splitter]JDK内建字符串拆分工具有一些古怪特性。比如，String.split丢弃了字符尾部的空白字符。String[] ss = &quot;,a,,b,&quot;.split(&quot;,&quot;);log.info(Arrays.toString(ss));//[INFO] [, a, , b]使用拆分器可以避免以上奇怪问题，拆分器通过分隔符对字符串进行切分。 方法 描述 Splitter.on(char separator) 生成Splitter，分隔字符为separator Splitter.on(CharMatcher separatorMatcher) 生成Splitter，分隔符为guava的CharMatcher Splitter.on(String separator) 生成Splitter，分隔字符串为separator Splitter.on(Pattern separatorPattern) 生成Splitter，分隔符为正则表达式 Splitter.onPattern(String separatorPattern) 生成Splitter，分隔符为正则表达式字符串 Splitter.fixedLength(int length) 生成Splitter，使用固定切分长度 limit(int limit) 限制切分数量 omitEmptyStrings() 剔除空字符串 trimResults() 剔除首尾空格 trimResults(CharMatcher trimmer) 剔除首尾CharMatcher字符 withKeyValueSeparator(char separator) 生成MapSplitter，k-v切分字符separator withKeyValueSeparator(String separator) 生成MapSplitter，k-v切分字符串separator withKeyValueSeparator(Splitter keyValueSplitter) 生成MapSplitter，k-v拆分器keyValueSplitter @Testpublic void splitterTest() { String s = &quot;;China; Japan;;American ; France ;&quot;; List&amp;lt;String&amp;gt; lists = Splitter.on(&#39;;&#39;).splitToList(s); log.info(lists.toString()); //[INFO] [, China, Japan, , American , France , ] lists = Splitter.on(&quot;;&quot;).trimResults().splitToList(s); log.info(lists.toString()); //[INFO] [, China, Japan, , American, France, ] lists = Splitter.on(&quot;;&quot;).omitEmptyStrings().splitToList(s); log.info(lists.toString()); //[INFO] [China, Japan, American , France ] lists = Splitter.on(&quot;;&quot;).omitEmptyStrings().trimResults().splitToList(s); log.info(lists.toString()); //[INFO] [China, Japan, American, France]}三、字符匹配器[CharMatcher]一个CharMatcher代表一类字符。CharMatcher之间可以通过逻辑运算实现交、并、非。 方法 描述 CharMatcher.any() 匹配所有字符的匹配器 CharMatcher.anyOf(CharSequence sequence) 匹配sequence中所有字符的匹配器 CharMatcher.ascii() ascii码的匹配器 CharMatcher.breakingWhitespace() 可换行的空白字符的匹配器( CharMatcher.forPredicate(Predicate&amp;lt;? super Character&amp;gt; predicate) 基于lambda表达式的匹配器，Predicate用于分配lambda表达式 CharMatcher.inRange(char startInclusive, char endInclusive) [startInclusive, endInclusive]间所有字符的匹配器 CharMatcher.is(char match) 单字符匹配器 CharMatcher.isNot(char match) 除此单字符的匹配器 CharMatcher.javaIsoControl() Java控制字符匹配器，\\t \\n \\r CharMatcher.none() 无字符的匹配器，匹配不到任何字符 CharMatcher.noneOf(CharSequence sequence) 除sequence中字符外，其他字符都匹配的匹配器 CharMatcher.whitespace() 空格匹配器 and(CharMatcher other) 并 or(CharMatcher other) 交 negate() 非 matchesAnyOf(CharSequence sequence) 匹配器匹配到sequence中任一字符 matchesAllOf(CharSequence sequence) 匹配器匹配到sequence中所有字符 matchesNoneOf(CharSequence sequence) 匹配器未匹配到sequence中任一字符 indexIn(CharSequence sequence) 第一个匹配到的index，无匹配则-1 indexIn(CharSequence sequence, int start) 从start开始，第一个匹配到的index，无匹配则-1 lastIndexIn(CharSequence sequence) 最后一个匹配到的index，无匹配则-1 countIn(CharSequence sequence) 匹配器从sequence中匹配到的字符数量 removeFrom(CharSequence sequence) 从sequence中去除匹配器中的字符 retainFrom(CharSequence sequence) 从sequence中保留匹配器中的字符 replaceFrom(CharSequence sequence, char replacement) 用replacement代替匹配到的字符 replaceFrom(CharSequence sequence, CharSequence replacement) 用replacement代替匹配到的字符 trimFrom(CharSequence sequence) 删除首尾匹配到的字符 trimLeadingFrom(CharSequence sequence) 删除首部匹配到的字符 trimTrailingFrom(CharSequence sequence) 删除尾部匹配到的字符 collapseFrom(CharSequence sequence, char replacement) 连续匹配到的字符，用replacement代替 trimAndCollapseFrom(CharSequence sequence, char replacement) 删除首尾匹配到的字符，中间连续匹配到的字符用replacement代替 @Testpublic void charMatcherTest() { String input = &quot;&quot;; String result = &quot;&quot;; input = &quot;H*el.lo,}12&quot;; CharMatcher matcher0 = CharMatcher.forPredicate(Character::isLetter); CharMatcher matcher1 = CharMatcher.forPredicate(Character::isLowerCase); result = matcher0.and(matcher1).retainFrom(input); assertEquals(&quot;ello&quot;, result); input = &quot;H*el.lo,}12&quot;; CharMatcher matcher = CharMatcher.anyOf(&quot;Hel&quot;); result = matcher.retainFrom(input); assertEquals(&quot;Hell&quot;, result); result = matcher.removeFrom(input); assertEquals(&quot;*.o,}12&quot;, result); input = &quot; hel lo &quot;; result = CharMatcher.is(&#39; &#39;).collapseFrom(input, &#39;-&#39;); assertEquals(&quot;-hel-lo-&quot;, result); result = CharMatcher.is(&#39; &#39;).trimAndCollapseFrom(input, &#39;-&#39;); assertEquals(&quot;hel-lo&quot;, result);}四、字符集[Charsets]Charsets针对所有Java平台都要保证支持的六种字符集提供了常量引用。尝试使用这些常量，而不是通过名称获取字符集实例。 方法 描述 Charsets.ISO_8859_1   Charsets.US_ASCII   Charsets.UTF_8   Charsets.UTF_16   Charsets.UTF_16BE   Charsets.UTF_16LE   五、格式器[CaseFormat]格式器对字符串进行大小写格式化。 方法 描述 LOWER_CAMEL 小驼峰，lowerCamel，方法名 UPPER_CAMEL 大驼峰，LowerCamel，类名 LOWER_HYPHEN 小写+连字符，lower-hyphen LOWER_UNDERSCORE 小写+下划线，C++变量名 UPPER_UNDERSCORE 大写+下划线，常量名 to(CaseFormat format, String str) 将str从当前格式专为目标格式 converterTo(CaseFormat targetFormat) 返回当前格式到目标格式的转换器 @Testpublic void caseFormatTest() { String input = &quot;&quot;; String result = &quot;&quot;; Converter&amp;lt;String, String&amp;gt; camelConverter = CaseFormat.LOWER_CAMEL.converterTo(CaseFormat.UPPER_UNDERSCORE); input = &quot;lowerCamel&quot;; result = camelConverter.convert(input); assertEquals(&quot;LOWER_CAMEL&quot;, result); input = &quot;UPPER_UNDERSCORE&quot;; result = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, input); assertEquals(&quot;UpperUnderscore&quot;, result);}" }, { "title": "Git", "url": "/posts/git/", "categories": "tool", "tags": "git", "date": "2019-01-13 00:00:00 +0800", "snippet": "Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。A Visual Git Reference 以图形化方式加深对 git 命令的理解。一、Git库建立git 库可以通过本地新建和克隆远程仓库两种方式实现。#本地新建git init #在当前目录建立git库#克隆远程仓库git clone &amp;lt;远程仓库地址&amp;gt; #clone完成后，当前目录下会生成一个远程仓库项目名的文件夹二、Git库状态git有4种文件状态：untracked、unmodified、modified、staged。 untracked，当有新文件加入工作目录时，这个新文件就属于untracked状态。如果需要对其进行版本控制，通过git add命令进行添加；如果不需要进行版本控制，最好把文件名放入.gitignore（git检测.gitignore文件，所有列入.gitignore的文件都会被git忽略）文件中，这样git不会对其进行管理。 git add . #添加当前文件夹下所有文件到git库git add &amp;lt;filename&amp;gt; #添加filename文件到git库 unmodified，工作空间内新添加的文件、没有更改过的文件、staged状态下commit的文件都处于unmodified状态。本地库新建好，通过git add新添加的文件会由untracked状态变为unmodified状态；远程仓库克隆好之后，未做任何更改时，所有文件都是unmodified状态；staged状态下的文件，通过git commit可以变为unmodified状态。 modified，unmodified状态下的文件发生更改后处于modified状态。 staged，暂存区，更改的文件通过git add命令后变为staged状态。 三、分支git分支可以使开发工作从主线上分离出来。常见的团队协作分支：master分支 master为主分支，也是用于部署生产环境的分支，确保master分支稳定性 master分支一般由develop以及hotfix分支合并，任何时间都不能直接修改代码develop分支 develop为开发分支，始终保持最新完成以及bug修复后的代码 一般开发的新功能时，feature分支都是基于develop分支下创建的feature分支 开发新功能时，以develop为基础创建feature分支 分支命名：feature/ 开头的为特性分支，命名规则: feature/user_module、feature/cart_modulerelease分支 release为预上线分支，发布提测阶段，会release分支代码为基准提测当有一组feature开发完成，首先会合并到develop分支，进入提测时，会创建release分支。如果测试过程中存在bug需要修复，则直接由开发者在release分支修复并提交。当测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。hotfix分支 分支命名：hotfix/开头的为修复分支，它的命名规则与feature分支类似 线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支git branch #查看本地分支git branch -r #查看远程分支git branch -a #查看所有分支git branch &amp;lt;分支名&amp;gt; #创建新分支git checkout &amp;lt;分支名&amp;gt; #切换分支git branch -b &amp;lt;分支名&amp;gt; #创建并切换到新分支四、本地库与远程库git有4个工作区：remote、repository、index、workspace remote，远程仓库，共享代码、团队协作的仓库 repository，本地仓库，git commit之后文件所在位置 index，暂存区，git add之后文件所在位置 workspace，工作区1. git fetch当远程仓库更新后，可以通过git fetch将远程仓库的更新全部更新到本地仓库，这样本地仓库与远程仓库保持一致。本地仓库可以checkout出任一分支并在其基础上进行开发或工作。git fetch &amp;lt;远程主机名&amp;gt; #全部更新git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt; #只更新分支2. git pull当本地有跟踪的远程分支时，可以通过git pull进行该分支的更新与合并。当本地没有跟踪远程分支时，可以通过git pull拉取其他远程分支并与本地特定分支合并。git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt; #拉取远程分支并合并到本地分支git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt; #拉取远程分支合并到本地当前分支，可以省略本地分支名git pull &amp;lt;远程主机名&amp;gt; #本地当前分支与远程分支有追踪关系，可以省略远程分支名、本地分支名git pull #当前分支只有一个追踪分支3. git push将本地分支推送到远程仓库。git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt; #推送本地分支到远程仓库的分支git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt; #推送本地分支到远程仓库有追踪关系的分支，如果没有追踪关系则远程仓库新建分支git push &amp;lt;远程主机名&amp;gt; :&amp;lt;远程分支名&amp;gt; #删除远程分支git push &amp;lt;远程主机名&amp;gt; --delete &amp;lt;远程分支名&amp;gt; #删除远程分支git push &amp;lt;远程主机名&amp;gt; #本地当前分支与远程分支有追踪关系git push #本地当前分支只有一个追踪分支4. 建立追踪分支建立远程分支的本地追踪分支有三种方式。 git push本地分支到远程仓库时 git checkout远程分支为本地分支时 git branch建立追踪git push --set-upstream &amp;lt;远程主机名&amp;gt; &amp;lt;本地追踪分支名&amp;gt; #在远程仓库创建分支，本地分支追踪该分支git checkout --track &amp;lt;远程主机名&amp;gt;/&amp;lt;远程追踪分支名&amp;gt; #在本地仓库创建分支，追踪远程仓库的分支git branch --set-upstream [本地追踪分支名] [远程追踪分支名] #建立本地分支和远程仓库分支的追踪关系git branch -vv #查看分支追踪情况五、Git常用命令1. 新建# 在当前目录新建一个Git代码库git init# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url]2. 配置git配置文件为.gitconfig，可以全局配置，也可以在项目下配置。# 显示当前的Git配置git config --list# 编辑Git配置文件git config -e [--global]# 设置提交代码时的用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot;# 显示配置文件位置git config --list --show-origin3. 文件操作# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed]4. 提交# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -am [message]# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ...5. 分支# 列出所有本地分支git branch# 列出本地分支及其 track 的远程分支git branch -vv# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 从远程分支创建一个本地分支，并切换到该分支，同时本地分支会 track 远程分支git checkout -b [local-branch] [origin/branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]git branch -u [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]# 删除分支，可以删除已合并的分支git branch -d [branch-name]# 删除分支，可以删除未合并的分支git branch -d [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch]git push origin :&amp;lt;branch&amp;gt;# 合并分支到当前分支git merge &amp;lt;branch&amp;gt;# 显示已合并到某分支的分支git branch --merged [branch]# 显示没合并到某分支的分支git branch --no-merged [branch]6. 查看信息# 显示有变更的文件git status# 简略版git status -s# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]git diff --staged [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog7. 远程# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all8. 撤销# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop9. 帮助git help &amp;lt;verb&amp;gt;git &amp;lt;verb&amp;gt; --help# 简略版帮助文档git &amp;lt;verb&amp;gt; -h10. 标签# 列出所有标签git tag# 列出特定名称标签git tag -l &quot;*tagname*&quot;# 检出标签git checkout tagname# 检出标签到分支git checkout -b branchname tagname11. 变基# 合并提交，前开后闭git rebase -i [startpoint] [endpoint]# 合并提交，默认 endpoint 为 HEADgit rebase -i [startpoint]# 当前分支变基到 mastergit rebase master [branch]## C 在 B 之后的补丁，变基到 A 上# A : 分支名称或者 commit_id (此 id 不在 C 上) # B : 分支名称（此分支与 C 有共同的祖先 commit）或者 commit_id (此 id 在 C 上) # C : 分支名称git rebase --onto A B C 六、忽略文件仓库根目录下的 .gitignore 文件可以指定 git 不需要进行版本控制的文件，加入到 .gitignore 文件中的文件不会再被 git 管理，并且不会被推送到远端仓库。.gitignore 文件规则如下。 所有空行或者以 # 开头的行都会被 git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符 [abc] 匹配任何一个列在方括号中的字符 [a-z] 范围单个字符匹配 问号（?）只匹配一个任意字符 两个星号（**）匹配任意目录" }, { "title": "Mac 工具配置", "url": "/posts/mac_tool/", "categories": "tool", "tags": "mac", "date": "2019-01-12 00:00:00 +0800", "snippet": "一、SublimeSublime Text 是一套跨平台的文本编辑器，支持基于 Python 的插件。Sublime Text是专有软件，可透过包（Package）扩展。大多数的包使用自由软件授权发布，并由社群建置维护。配置在命令行可使用 Sublime 打开文本文件。官方配置配置方法$ ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl$ echo &quot;export EDITOR=&#39;subl -w&#39;&quot; &amp;gt;&amp;gt; ~/.zshrc使用方法Usage: subl [arguments] [files] edit the given files or: subl [arguments] [directories] open the given directories or: subl [arguments] - edit stdinArguments: --project &amp;lt;project&amp;gt;: Load the given project --command &amp;lt;command&amp;gt;: Run the given command -n or --new-window: Open a new window -a or --add: Add folders to the current window -w or --wait: Wait for the files to be closed before returning -b or --background: Don&#39;t activate the application -s or --stay: Keep the application activated after closing the file -h or --help: Show help (this message) and exit -v or --version: Show version and exit--wait is implied if reading from stdin. Use --stay to not switch backto the terminal when a file is closed (only relevant if waiting for a file).Filenames may be given a :line or :line:column suffix to open at a specificlocation.二、ZshZ shell（Zsh）是一款可用作交互式登录的 shell 及脚本编写的命令解释器。Zsh对 Bourne shell 做出了大量改进，同时加入了 bash、ksh 及 tcsh 的某些功能。1. 切换 shellMac 默认 shell 是 bash，自带 zsh。$ cat /etc/shells #查看系统自带shell$ echo $SHELL #查看当前shell$ chsh -s /bin/zsh #切换为zsh2. 安装 Oh-My-ZshOh-My-Zsh 是一款社区驱动的命令行工具，是基于 zsh 命令行的一个扩展工具集，提供了丰富的扩展功能，如：主题配置，插件机制，内置的便捷操作等，可以给我们一种全新的命令行使用体验。安装#自动安装$ wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh#手动安装$ git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh$ cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc配置$ subl ~/.zshrc#更改主题ZSH_THEME=&quot;my-robbyrussell&quot; #可更改的主题：ls ~/.oh-my-zsh/themes #添加插件plugins=(git osx autojump sublime autosuggestions)修改主题使用了默认主题 robbyrussell，直接编辑 robbyrussell.zsh-theme 可以更改终端提示符。#默认提示符#PROMPT=&#39;${ret_status} %{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)&#39;#更改后的提示符，‘c’改为‘d’，‘当前目录’改为‘绝对路径’，增加‘&amp;gt;’提示符PROMPT=&#39;${ret_status} %{$fg[cyan]%}%d%{$reset_color%} $(git_prompt_info)&amp;gt; &#39;#其他配置%D #系统日期（年-月-日）%T #系统时间（时：分）%* #系统时间（时：分：秒）%n #用户名%B - %b #开始到结束使用粗体打印%U - %u #开始到结束使用下划线打印%d #当前目录%~ #当前目录相对~的路径%M #计算机的主机名%m #计算机的主机名（在第一个句号之前截断）%l #当前的tty安装插件#osx, plugins=(osx)#内置，直接配置开启。#Command #Descriptiontab #Open the current directory in a new terminal tabofd #Open the current directory in a Finder windowcdf #cd to the current Finder directorypfd #Return the path of the frontmost Finder windowpfs #Return the current Finder selectionquick-look #Quick-Look a specified fileman-preview #Open a specified man page in Preview app#autojump, plugins=(autojump)brew install autojump#Command #Descriptionj -s #查看当前记录的目录状态和权重j &#39;dir&#39; #跳转到dir目录j -h #查看帮助#sublime, plugins=(sublime)#内置，直接配置开启#Command #Descriptionst #打开ststt #打开当前目录#autosuggestions, plugins=(zsh-autosuggestions)git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions#输入命令时，会有灰色提示，按右箭头或者ctrl+e使用。3. 快捷键⌃ + u：清空当前行⌃ + a：移动到行首⌃ + e：移动到行尾⌃ + f：向前移动⌃ + b：向后移动⌃ + p：上一条命令⌃ + n：下一条命令⌃ + r：搜索历史命令⌃ + y：召回最近用命令删除的文字⌃ + h：删除光标之前的字符⌃ + d：删除光标所指的字符⌃ + w：删除光标之前的单词⌃ + k：删除从光标到行尾的内容⌃ + t：交换光标和之前的字符⌘ + n：新建窗口⌘ + t：新建标签页⌘ + w：关闭当前页⌘ + 数字 &amp;amp; ⌘ + 方向键：切换标签页" }, { "title": "struct 处理二进制", "url": "/posts/struct/", "categories": "language, python", "tags": "", "date": "2019-01-12 00:00:00 +0800", "snippet": "一、struct模块struct模块可以用来处理二进制，把整数、浮点数、字符串等生成字节流，或者由字节流生成浮点数、字符串等。常用函数struct.pack(format, v1, v2, ...)#Return a bytes object containing the values v1, v2, … packed according to the format string format. The arguments must match the values required by the format exactly.#按照format格式，从v1、v2、...生成bytes，返回bytesstruct.unpack(format, buffer)#Unpack from the buffer buffer (presumably packed by pack(format, ...)) according to the format string format. The result is a tuple even if it contains exactly one item. The buffer’s size in bytes must match the size required by the format, as reflected by calcsize().#按照format，从bytes生成tuple，返回tuplestruct.calcsize(format)#Return the size of the struct (and hence of the bytes object produced by pack(format, ...)) corresponding to the format string format.#返回format格式对应的字节数目format格式[order][format]#order可选，定义字节对齐方式 Character Byte order Size Alignment @ native native native = native standard none &amp;lt; little-endian standard none &amp;gt; big-endian standard none ! network (= big-endian) standard none [order]：可选，用于表示字节对齐方式。 Format C Type Python type Standard size x pad byte no value   c char bytes of length 1 1 b signed char integer 1 B unsigned char integer 1 ? _Bool bool 1 h short integer 2 H unsigned short integer 2 i int integer 4 I unsigned int integer 4 l long integer 4 L unsigned long integer 4 q long long integer 8 Q unsigned long long integer 8 n ssize_t integer   N size_t integer   e   float 2 f float float 4 d double float 8 s char[] bytes   p char[] bytes   P void * integer   [format]：数字+格式，数字表示该格式的字节数目。示例import structa = 1b = 0.0c = &#39;hello&#39;print(struct.calcsize(&#39;&amp;gt;if5s&#39;))#13：&amp;gt;表示大端，i表示4字节integer，f表示4字节float，5s表示5字节bytess_bytes = struct.pack(&#39;&amp;gt;if5s&#39;, a, b, c.encode(&#39;utf-8&#39;))print(s_bytes)#b&#39;\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00hello&#39;s_tuple = struct.unpack(&#39;&amp;gt;if5s&#39;, s_bytes)print(s_tuple)#(1, 0.0, b&#39;hello&#39;)二、读取MNIST数据MNIST是一个手写数字图像数据集，包含60000个训练图像和10000个测试图像，图像以字节形式存储在文件中。train-images-idx3-ubyte.gz: training set images (9912422 bytes)，训练图像集train-labels-idx1-ubyte.gz: training set labels (28881 bytes)，训练图像标签集t10k-images-idx3-ubyte.gz: test set images (1648877 bytes) ，测试图像集t10k-labels-idx1-ubyte.gz: test set labels (4542 bytes)，测试图像标签集文件格式offset：偏置，可以理解为起始字节。type：类型，数据占用的字节数。value：对应的值。譬如，offset为0004，type为32 bit integer，value为60000，表示从文件的第0004个字节开始读4个字节得到的值应为60000。 [offset] [type] [value] [description] 0000 32 bit integer 0x00000801(2049) magic number (MSB first) 0004 32 bit integer 60000 number of items 0008 unsigned byte ?? label 0009 unsigned byte ?? label ……       xxxx unsigned byte ?? label TRAINING SET LABEL FILE (train-labels-idx1-ubyte), labels values are 0 to 9. [offset] [type] [value] [description] 0000 32 bit integer 0x00000803(2051) magic number 0004 32 bit integer 60000 number of images 0008 32 bit integer 28 number of rows 00012 32 bit integer 28 number of columns 0016 unsigned byte ?? pixel 0017 unsigned byte ?? pixel ……       xxxx unsigned byte ?? pixel TRAINING SET IMAGE FILE (train-images-idx3-ubyte), pixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).读取数据load_mnist，从MNIST加载数据；show_zero2nine，显示数字0-9的图像；show_different_number，显示不同数字的图像。import osimport structimport numpy as npimport matplotlib.pyplot as pltdef load_mnist(path, kind=&#39;train&#39;): labels_path = os.path.join(path, &#39;%s-labels-idx1-ubyte&#39; % kind) images_path = os.path.join(path, &#39;%s-images-idx3-ubyte&#39; % kind) with open(labels_path, &#39;rb&#39;) as lbpath: # 读magic number和number of items，MSB label_magic, label_num = struct.unpack(&#39;&amp;gt;2I&#39;, lbpath.read(8)) labels = np.fromfile(lbpath, dtype=np.uint8) with open(images_path, &#39;rb&#39;) as imgpath: # 读magic number和number of images、rows、cols，MSB image_magic, image_num, rows, cols = struct.unpack(&#39;&amp;gt;4I&#39;, imgpath.read(16)) images = np.fromfile(imgpath, dtype=np.uint8).reshape(image_num, rows*cols) return label_magic, label_num, labels, image_magic, image_num, imagesdef show_zero2nine(images, labels): fig, axes = plt.subplots(nrows=2, ncols=5) axes = axes.flatten() for ax, i in zip(axes, range(10)): image = images[labels == i][0].reshape(28, 28) ax.set_axis_off() ax.imshow(image, cmap=&#39;Greys&#39;) plt.show()def show_different_number(images, labels, number=0): fig, axes = plt.subplots(nrows=5, ncols=5) axes = axes.flatten() for ax, i in zip(axes, range(25)): image = images[labels == number][i].reshape(28, 28) ax.set_axis_off() ax.imshow(image, cmap=&#39;Greys&#39;) plt.show()if __name__ == &#39;__main__&#39;: data_path = &#39;/Users/cy/Coding/git/mnist/data/&#39; number = 1 label_magic, label_num, labels, image_magic, image_num, images = load_mnist(data_path) print(&#39;label_magic number: %d, label number: %d.&#39; % (label_magic, label_num)) print(&#39;image magic number: %d, image number: %d.&#39; % (image_magic, image_num)) show_zero2nine(images, labels) show_different_number(images, labels, number)" }, { "title": "matplotlib 颜色映射", "url": "/posts/matplotlib/", "categories": "language, python", "tags": "", "date": "2019-01-12 00:00:00 +0800", "snippet": "Colormap reference，matplotlib不同颜色的映射图，绘图时可参考。cmap=plt.get_cmap(colorname)cmap=&#39;colorname&#39;生成不同颜色的映射图import numpy as npimport matplotlib.pyplot as pltcmaps = [(&#39;Perceptually Uniform Sequential&#39;, [ &#39;viridis&#39;, &#39;plasma&#39;, &#39;inferno&#39;, &#39;magma&#39;]), (&#39;Sequential&#39;, [ &#39;Greys&#39;, &#39;Purples&#39;, &#39;Blues&#39;, &#39;Greens&#39;, &#39;Oranges&#39;, &#39;Reds&#39;, &#39;YlOrBr&#39;, &#39;YlOrRd&#39;, &#39;OrRd&#39;, &#39;PuRd&#39;, &#39;RdPu&#39;, &#39;BuPu&#39;, &#39;GnBu&#39;, &#39;PuBu&#39;, &#39;YlGnBu&#39;, &#39;PuBuGn&#39;, &#39;BuGn&#39;, &#39;YlGn&#39;]), (&#39;Sequential (2)&#39;, [ &#39;binary&#39;, &#39;gist_yarg&#39;, &#39;gist_gray&#39;, &#39;gray&#39;, &#39;bone&#39;, &#39;pink&#39;, &#39;spring&#39;, &#39;summer&#39;, &#39;autumn&#39;, &#39;winter&#39;, &#39;cool&#39;, &#39;Wistia&#39;, &#39;hot&#39;, &#39;afmhot&#39;, &#39;gist_heat&#39;, &#39;copper&#39;]), (&#39;Diverging&#39;, [ &#39;PiYG&#39;, &#39;PRGn&#39;, &#39;BrBG&#39;, &#39;PuOr&#39;, &#39;RdGy&#39;, &#39;RdBu&#39;, &#39;RdYlBu&#39;, &#39;RdYlGn&#39;, &#39;Spectral&#39;, &#39;coolwarm&#39;, &#39;bwr&#39;, &#39;seismic&#39;]), (&#39;Qualitative&#39;, [ &#39;Pastel1&#39;, &#39;Pastel2&#39;, &#39;Paired&#39;, &#39;Accent&#39;, &#39;Dark2&#39;, &#39;Set1&#39;, &#39;Set2&#39;, &#39;Set3&#39;, &#39;tab10&#39;, &#39;tab20&#39;, &#39;tab20b&#39;, &#39;tab20c&#39;]), (&#39;Miscellaneous&#39;, [ &#39;flag&#39;, &#39;prism&#39;, &#39;ocean&#39;, &#39;gist_earth&#39;, &#39;terrain&#39;, &#39;gist_stern&#39;, &#39;gnuplot&#39;, &#39;gnuplot2&#39;, &#39;CMRmap&#39;, &#39;cubehelix&#39;, &#39;brg&#39;, &#39;gist_rainbow&#39;, &#39;rainbow&#39;, &#39;jet&#39;, &#39;nipy_spectral&#39;, &#39;gist_ncar&#39;])]gradient = np.linspace(0, 1, 256)gradient = np.vstack((gradient, gradient))def plot_color_gradients(cmap_category, cmap_list): # Create figure and adjust figure height to number of colormaps nrows = len(cmap_list) figh = 0.35 + 0.15 + (nrows + (nrows-1)*0.1)*0.22 fig, axes = plt.subplots(nrows=nrows, figsize=(6.4, figh)) fig.subplots_adjust(top=1-.35/figh, bottom=.15/figh, left=0.2, right=0.99) axes[0].set_title(cmap_category + &#39; colormaps&#39;, fontsize=14) for ax, name in zip(axes, cmap_list): ax.imshow(gradient, aspect=&#39;auto&#39;, cmap=plt.get_cmap(name)) ax.text(-.01, .5, name, va=&#39;center&#39;, ha=&#39;right&#39;, fontsize=10, transform=ax.transAxes) # Turn off *all* ticks &amp;amp; spines, not just the ones with colormaps. for ax in axes: ax.set_axis_off()for cmap_category, cmap_list in cmaps: plot_color_gradients(cmap_category, cmap_list)plt.show()映射图" }, { "title": "使用 Jekyll 和 GitHub 搭建个人博客", "url": "/posts/jekyll_github_blog/", "categories": "tool", "tags": "jekyll, github", "date": "2019-01-03 00:00:00 +0800", "snippet": "一、Jekyll 环境搭建Jekyll 官网、Jekyll 中文网 Jekyll 介绍 Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 Markdown）和 Liquid 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。 Jekyll 结构 Jekyll 的核心其实是一个文本转换引擎。它的概念其实就是：你用你最喜欢的标记语言来写文章，可以是 Markdown, 也可以是 Textile，或者就是简单的 HTML，然后 Jekyll 就会帮你套入一个或一系列的布局中。在整个过程中你可以设置 URL 路径，你的文本在布局中的显示样式等等。这些都可以通过纯文本编辑来实现，最终生成的静态页面就是你的成品了。 一个基本的 Jekyll 网站的目录结构一般是这样： .├── _config.yml├── _drafts| ├── begin-with-the-crazy-ideas.textile| └── on-simplicity-in-technology.markdown├── _includes| ├── footer.html| └── header.html├── _layouts| ├── default.html| └── post.html├── _posts| ├── 2007-10-29-why-every-programmer-should-play-nethack.textile| └── 2009-04-26-barcamp-boston-4-roundup.textile├── _site├── .jekyll-metadata└── index.html Jekyll 安装 安装 ruby 更改 gem 源 $ gem source -r https://rubygems.org/$ gem source -a https://gems.ruby-china.com$ gem source*** CURRENT SOURCES *** https://gems.ruby-china.com 安装 Jekyll $ sudo gem install jekyll bundle 新建 $ jekyll new myblog 运行 $ cd myblog$ jekyll serveServer address: http://127.0.0.1:4000/Server running... press ctrl-c to stop. 本地查看 浏览器输入 http://127.0.0.1:4000/ 写博文 发表一篇新文章，需要做的就是在 _posts 文件夹中创建一个新的文件。 文件名的命名非常重要。Jekyll 要求一篇文章的文件名遵循下面的格式： 年-月-日-标题.MARKUP2011-12-31-new-years-eve-is-awesome.md2012-09-12-how-to-write-a-blog.textile 二、GitHub PagesGitHub Pages 官网 GitHub Pages 介绍 GitHub Pages 可以为你或者你的项目提供介绍网页，它是由 GitHub 官方托管和发布的。你可以使用 GitHub 提供的页面自动生成器。也可以做个人博客，是个轻量级的博客系统，没有麻烦的配置。使用标记语言如Markdown，不需自己搭建服务器，还可以绑定自己的域名。 GitHub Pages 使用 GitHub Pages 使用非常简单，直接参考官网教程。 GitHub 上创建新仓库， 新仓库名为：username.github.iousername 是自己 GitHub 用户名，如果没有使用自己的用户名，个人博客可能会无法访问。 将新建仓库克隆到本地 $ git clone https://github.com/username/username.github.io 在本地仓库创建 index.html 文件 $ cd username.github.io$ echo &quot;Hello World&quot; &amp;gt; index.html 把本地仓库 push 到 GitHub 上 $ git add .$ git commit -m &quot;Initial commit&quot;$ git push -u origin master 访问 浏览器访问：https://username.github.io可以看到刚才写入 index.html 的 “Hello World” 三、搭配 Jekyll 和 GitHub 不使用主题样式 直接把 Jekyll 生成文件夹下的所有内容 copy 到 username.github.io 的本地仓库即可。 Jekyll 生成文件夹 copy 文件夹下所有内容到自己的本地仓库 本地仓库 push 到 GitHub 浏览器访问 使用主题样式 Jekyll Themes，有各种主题样式可以下载，也可以直接在网上搜索喜欢的主题样式，都是大牛做好的。 下载或者克隆主题 copy 主题文件夹下所有内容到自己的本地仓库 本地仓库 push 到 GitHub 浏览器访问 " } ]
